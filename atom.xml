<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinHaW</title>
  
  <subtitle>LinHaW 的 博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-18T14:42:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>团队协作代码规范</title>
    <link href="http://yoursite.com/2018/06/18/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/06/18/团队协作代码规范/</id>
    <published>2018-06-18T08:37:36.000Z</published>
    <updated>2018-06-18T14:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两个程序员可以写出3种风格代码,前端尤其明显(我也曾经是写过后端代码的人),主要是JS留下的后遗症。虽然现在主流的编辑器如webstorm或者Visual Studio可能加上eslint强行限制你那天马行空的代码。我对代码本身就有”洁癖”,对自己对别人也一样,如何防止你那讨厌的同事写上糟糕的代码来”污染”你那圣神的代码,这篇文章会给出”紧箍咒”让所有人必须遵从约定好的代码风格以保存项目的整洁性。</p></blockquote><h2 id="eslint-standards"><a href="#eslint-standards" class="headerlink" title="eslint standards"></a>eslint standards</h2><p>业界已经提出一种标准方案–<u>JavaScript Standard Style</u></p><blockquote><p>以下的代码演示均来<u>《webpack渐入佳境之打包优化篇》</u></p></blockquote><p>我们需要安装以下依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.02.01.png" alt=""></p><ul><li>根目录下创建.eslintrc文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"extends"</span>: <span class="string">"standard"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样eslint就可以帮我们校验代码,但因为我们这个项目是vue开发,eslint它并不能识别里面的js代码(.vue文件并非传统的.js文件),我们需要有一个东西可以识别任意格式文件里面的javascript标签</p><ul><li>eslint-plugin-html</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint-plugin-html -D</div></pre></td></tr></table></figure><p>修改.eslintrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">"plugins"</span>: [</div><div class="line">   <span class="string">"html"</span></div><div class="line"> ],</div></pre></td></tr></table></figure><p>修改package.json 添加命令去校验代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">   ...</div><div class="line"> + &quot;lint&quot;: &quot;eslint --ext .js --ext .jsx --ext .vue src/&quot;,</div><div class="line">   &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</div><div class="line"> &#125;,</div></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.09.00.png" alt=""></p><p>可以看到控制台已经抛出错误,例如空格符跟tab缩进混用, 多打了一个空格之类。eslint可以帮我们处理比较简单错误</p><p>修改package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js --ext .jsx --ext .vue src/"</span>,</div><div class="line">+ <span class="string">"lint-fix"</span>: <span class="string">"eslint --fix --ext .js --ext .jsx --ext .vue src/"</span>,</div></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint-fix</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.20.28.png" alt=""></p><p>我们发现错误减少了,但还是报了空格和tab缩进混合使用错误,这些问题在很多现代编辑器很帮你处理好,我们也可以手动修改覆盖编辑器默认属性。</p><p>创建.editorconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = <span class="literal">true</span></div><div class="line"></div><div class="line">[*]</div><div class="line">charset = utf-8</div><div class="line">end_of_line = lf</div><div class="line">indent_size = 2   //缩进单位</div><div class="line">indent_style = space   //空格   </div><div class="line">insert_final_newline = <span class="literal">true</span> //最后换行</div><div class="line">trim_trailing-whitesplace = <span class="literal">true</span>  //句尾去掉空格</div></pre></td></tr></table></figure><blockquote><p>“root = true”是指只读取到这个配置文件就结束,不再往上层目录找,end_of_line指定回车换行符,window使用的是CRLF,linux和osx都是LF</p></blockquote><p>但是每次都敲命令行感觉又很繁琐,能不能让它自动检查每次代码更新进行eslint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint-loader babel-eslint -D</div></pre></td></tr></table></figure><p>修改.eslintrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&quot;parser&quot;: &quot;babel-eslint&quot;</div></pre></td></tr></table></figure><p>这样处理是因为webpack最终都是需要经过babel编译(es5),而eslint它是支持es6和es7,这样可能会导致一些奇奇怪怪的问题。</p><p>配置eslint-loader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">    rules: [</div><div class="line">     + &#123;</div><div class="line">     +  <span class="built_in">test</span>: /\.(vue|js|jsx)$/,</div><div class="line">     +   loader: <span class="string">'eslint-loader'</span>,</div><div class="line">     +   exclude: /node_modules/, //已经经过babel处理,所以去掉</div><div class="line">     +   enforce: <span class="string">'pre'</span></div><div class="line">     + &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">test</span>: /\.vue$/,</div><div class="line">        loader: <span class="string">'vue-loader'</span></div><div class="line">      &#125;,</div><div class="line">      ...</div></pre></td></tr></table></figure><blockquote><p>enforce: ‘pre’  是因为.vue文件我们已经制定vue-loader去处理,我们不希望eslint-loader处理.vue文件,我们只是希望在vue-loader处理之前先进行eslint语法检查。</p></blockquote><p>最后,如果你希望所有人都把本地的代码规范问题都解决后才能提交,可以尝试这么做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i husky -D</div></pre></td></tr></table></figure><p>它会在.git文件里面生成一个hooks,它会读取我们在package.json里面配置的信息</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2022.29.27.png" alt=""></p><p>修改package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">"precommit"</span>: <span class="string">"npm run lint-fix"</span>,</div><div class="line"><span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"</span></div></pre></td></tr></table></figure><p>这样我们每次 <u>git commit -m ‘log’</u>的时候它都会先进行一次eslint检查,通过了才能成功commit</p><blockquote><p>注意,安装husky之前必须确保项目中已经有.git文件,否者hook将会写入失败。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;两个程序员可以写出3种风格代码,前端尤其明显(我也曾经是写过后端代码的人),主要是JS留下的后遗症。虽然现在主流的编辑器如webstorm或者Visual Studio可能加上eslint强行限制你那天马行空的代码。我对代码本身就有”洁癖”,对自己
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="eslint" scheme="http://yoursite.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>webpack渐入佳境之打包优化篇</title>
    <link href="http://yoursite.com/2018/06/16/webpack%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%E4%B9%8B%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/16/webpack渐入佳境之打包优化/</id>
    <published>2018-06-16T14:59:29.000Z</published>
    <updated>2018-06-16T15:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>继上一篇,我们已经做了build操作,但我们只做了webpack的构建工作,它目前并不具备服务器功能,接下来我们先来完善它</p></blockquote><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server跟webpack不同点在于它提供了实时加载的服务,并且只能用于开发环境</p><blockquote><p>修改 package.json</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">...</div><div class="line">   <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.config.js"</span></div><div class="line"> &#125;,</div></pre></td></tr></table></figure><blockquote><p>配置区分对应模式</p><ul><li>package.json</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config webpack.config.js"</span>,</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure><p>这里需要安装<u>cross-env</u>这个包来处理不同平台(osx、win)的差异,如win需要配置成<strong>set NODE_ENV= development</strong> 之类</p><ul><li>webpack.config.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">+ const isDev = process.env.NODE_ENV === <span class="string">'development'</span></div></pre></td></tr></table></figure><p>可以通过process.env去读取在命令设置的变量名NODE_ENV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">+ target: <span class="string">'web'</span>  //运行在浏览器</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">+ <span class="keyword">if</span> (isDev) &#123;</div><div class="line">+  config.devtool = <span class="string">'#cheap-module-eval-source-map'</span>  //帮助调试代码 <span class="built_in">source</span>Map</div><div class="line">+  config.devServer = &#123;</div><div class="line">+   port: <span class="string">'8000'</span>,</div><div class="line">+    host: <span class="string">'0.0.0.0'</span>,</div><div class="line">+   overlay: &#123;</div><div class="line">+      errors: <span class="literal">true</span>  //捕获webpack编译过程错误,并显示到页面</div><div class="line">+   &#125;,</div><div class="line">+    open: <span class="literal">true</span>   //自动打开浏览器</div><div class="line">+  &#125;</div><div class="line">+ &#125;</div></pre></td></tr></table></figure><p>上面就是简单的服务器配置</p><blockquote><p>创建入口文件 index.html</p></blockquote><p>到目前为止我们还看不到效果,我们需要把前面打包压缩的文件放到一个html文件去显示。正好webpack已经为我们提供了一个插件–<u>html-webpack-plugin</u>,会自动为我们创建一个简单的html文件,文档是这么说明的,这里贴上就不做翻译。</p><blockquote><p>This is a webpack plugin that simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation. You can either let the plugin generate an HTML file for you, supply your own template using lodash templates or use your own loader.</p></blockquote><ul><li>webpack.config.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ const HtmlPlugin = require(<span class="string">'html-webpack-plugin'</span>)</div><div class="line">+ const webpack = require(<span class="string">'webpack'</span>)</div><div class="line"></div><div class="line">  ...</div><div class="line">+ plugins: [</div><div class="line">+  new webpack.DefinePlugin(&#123;</div><div class="line">+    <span class="string">'process.env'</span>: &#123;</div><div class="line">+      NODE_ENV: isDev ? <span class="string">'"development"'</span> :<span class="string">'"production"'</span></div><div class="line">+    &#125;</div><div class="line">+  &#125;),</div><div class="line">+  new HtmlPlugin()</div><div class="line">+ ]</div></pre></td></tr></table></figure><p>此外我们添加了一个webpack提供的一个插件<u>DefinePlugin</u>,它会在编译时期创建全局变量,我们在写js代码也可以引用process.env.NODE_ENV去做逻辑判断。</p><p>敲下<strong>npm run dev</strong>你会看到如下:</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wpcode1.png" alt="code"></p><ul><li>HMR配置</li></ul><p>webpack为我们提供了热加载的功能,这样不会因为节点的增删改而刷新整个页面影响体验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config.devServer = &#123;</div><div class="line">   + hot: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">+ config.plugins.push(</div><div class="line">+    new webpack.HotModuleReplacementPlugin(),</div><div class="line">+    new webpack.NoEmitOnErrorsPlugin()</div><div class="line">+ )</div></pre></td></tr></table></figure><h2 id="分离css打包"><a href="#分离css打包" class="headerlink" title="分离css打包"></a>分离css打包</h2><p>从这里开始讲会webpack的打包优化,首先我们先看看bundle.js打包后的样子</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wp2.png" alt="code"></p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wp3.png" alt="code"></p><p>上面的图片可以看到,css依旧以js的形式打包在一起,显然这样子做浏览器缓存并不合理.</p><ul><li>extract-text-webpack-plugin</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i extract-text-webpack-plugin</div></pre></td></tr></table></figure><p>通过装这个插件,webpack会自动帮我们把除javascript文件以外的文件打包成静态文件,最终作为外链的形式加入到html的head中</p><blockquote><p>修改配置文件对开发环境和正式环境打包进行调整</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isDev) &#123;</div><div class="line">+  config.module.rules.push(&#123;</div><div class="line">+    <span class="built_in">test</span>: /\.styl$/,</div><div class="line">+    use: [</div><div class="line">+          <span class="string">'style-loader'</span>,  //将 JS 字符串生成为 style 节点</div><div class="line">+         <span class="string">'css-loader'</span>,   //将 CSS 转化成 CommonJS 模块</div><div class="line">+          &#123;</div><div class="line">+            loader: <span class="string">'postcss-loader'</span>,</div><div class="line">+            options: &#123;</div><div class="line">+            <span class="built_in">source</span>Map: <span class="literal">true</span>   //复用上一个loader的<span class="built_in">source</span>Map</div><div class="line">+          &#125;</div><div class="line">+        &#125;,</div><div class="line">+          <span class="string">'stylus-loader'</span></div><div class="line">+      ]</div><div class="line">  &#125;)</div><div class="line"> ...</div><div class="line">+ &#125; <span class="keyword">else</span> &#123;</div><div class="line">+  config.output.filename = <span class="string">'[name].[chunkhash:8].js'</span></div><div class="line">+  config.module.rules.push(</div><div class="line">+    &#123;</div><div class="line">+     <span class="built_in">test</span>: /\.styl$/,</div><div class="line">+      use: ExtractPlugin.extract(&#123;</div><div class="line">+        fallback: <span class="string">'style-loader'</span>,</div><div class="line">+        use: [</div><div class="line">+          <span class="string">'css-loader'</span>,</div><div class="line">+          &#123;</div><div class="line">+            loader: <span class="string">'postcss-loader'</span>,</div><div class="line">+            options: &#123;</div><div class="line">+              <span class="built_in">source</span>Map: <span class="literal">true</span></div><div class="line">+            &#125;</div><div class="line">+          &#125;,</div><div class="line">+          <span class="string">'stylus-loader'</span></div><div class="line">+        ]</div><div class="line">+      &#125;)</div><div class="line">+    &#125;,</div><div class="line">+  )</div><div class="line">+  config.plugins.push(</div><div class="line">+    new ExtractPlugin(<span class="string">'styles.[contentHash:8].js'</span>)</div><div class="line">+  )</div></pre></td></tr></table></figure><blockquote><p>注意:所有打包出来的js模块的hash值都是一样的,chunkhash会根据每个chunk(entry里面定义的不同节点)生产不同的hash值,如果我们用了不同的entry或者把类库文件单独打包,必须使用chunkhash.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run buid</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/extract1.png" alt="code"></p><h2 id="第三方类库打包"><a href="#第三方类库打包" class="headerlink" title="第三方类库打包"></a>第三方类库打包</h2><p>第三方类库对比业务代码比较稳定,我们希望浏览器能够长缓存它,所以我们也要讲它们分离出来减少http请求和流量</p><p>先看代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ config.entry = &#123;</div><div class="line">+    app: path.join(__dirname, <span class="string">'./src/index'</span>),</div><div class="line">+    vendor: [<span class="string">'vue'</span>]</div><div class="line">+  &#125;</div><div class="line">  config.output.filename = <span class="string">'[name].[chunkhash:8].js'</span></div><div class="line">  ...</div><div class="line">  </div><div class="line">config.plugins.push(</div><div class="line">    new ExtractPlugin(<span class="string">'styles.[contentHash:8].js'</span>),</div><div class="line">+   new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">+   name: <span class="string">'vendor'</span></div><div class="line">+  &#125;)</div><div class="line">  )</div></pre></td></tr></table></figure><p>我们定了一个新的entry,指定了app和vendor,app是原来打包的入口模块, vendor则是存放第三方库,如vue</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.20.16.png" alt="code"></p><p>我们发现生成app.xxx和vendor.xxx,并且app的体积变小了</p><h2 id="分离webpack相关代码"><a href="#分离webpack相关代码" class="headerlink" title="分离webpack相关代码"></a>分离webpack相关代码</h2><p>使用webpack构建应用程序中,主要有三种代码类型:</p><ul><li>你编写的代码</li><li>代码中依赖的第三方库</li><li>webpack的runtime和manifest</li></ul><p>这里的<u>Manifest</u>不是android里面的manifest.xml。试想一下,当你敲下<u>npm run build</u>之后会生成一个html去承载分离出来的各种资源文件如css,这时候你在里面所引用的绝对路径或者相对路径对应目录都不复存在,webpack就是利用manifest数据来处理所有模块的交互。<br>当浏览器开始执行、解析和映射应用程序时,它会保存所有模块的详细要点,这个数据集合就是<strong>Manifest</strong>,当完成打包应发送给浏览器,会在运行时通过Manifest来解析和加载模块,这时候你代码中的<u>import</u>或者<u>require</u>都会转换为<strong>webpack_require</strong>方法。,通过使用manifest中的数据,<strong>runtime</strong>能够通过ID检索对对应模块,在模块交互的时候,runtime处理内容包括: 链接模块所需的加载和解析逻辑(如浏览器中的已加载模块的连接以及懒加载模块的执行逻辑)</p><blockquote><p>webpack.config.js </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">config.plugins.push(</div><div class="line">  ...</div><div class="line">+   new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">+      name: <span class="string">'runtime'</span></div><div class="line">+   &#125;)</div><div class="line">  )</div></pre></td></tr></table></figure><p>这里把app.js中连接各个模块的webpack代码分离出来, 当有新模块加入,webpack给每个模块加id区分,插入顺序可能会在中间,从而是id发生变化, 这样会使hash值发生变化导致长缓存失效。</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.51.17.png" alt="code"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.53.36.png" alt="code"></p><p>好了,一些webpack的基本操作就先写这些, 等后面再更新一篇关于webpack深入高级的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;继上一篇,我们已经做了build操作,但我们只做了webpack的构建工作,它目前并不具备服务器功能,接下来我们先来完善它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webpack-dev-server&quot;&gt;&lt;a href=&quot;#webpac
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>mvvm底层原理及伪代码实现</title>
    <link href="http://yoursite.com/2018/06/06/mvvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/06/06/mvvm底层原理及伪代码实现/</id>
    <published>2018-06-06T02:10:06.000Z</published>
    <updated>2018-06-08T08:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于mvc、mvp和mvvm 这三者的关系这篇文章不会展开叙述,如果你不了解他们, 暂且可以理解他们的演变过程为mvc -&gt; mvp -&gt; mvvm。写这篇文章的时候,mvvm其实网上已经有很多写的不错的文章,为什么还要写这篇文章,你可以说我是浪费时间,but,我只想站在我的角度把我的思考方式写出来,至于是否已经有人发表过,I don’t give a shit!这篇文章会以<u><strong>Vue</strong></u>的角度来分析,但并不影响另外两个框架的理解, 你懂的~</p></blockquote><h2 id="谈一谈设计模式"><a href="#谈一谈设计模式" class="headerlink" title="谈一谈设计模式"></a>谈一谈设计模式</h2><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/mvvm.png" alt="design"></p><p>mvvm采用的是观察者模式,如图所示, 我们需要监听者(Observer)、观察者列表(Dep)、订阅者(Watcher)这三个身份。</p><table><thead><tr><th>身 份</th><th>职 责</th></tr></thead><tbody><tr><td>监听者(Observer)</td><td>监听ViewModel中Data的变化,并通知观察者列表,但它并不关心观察者列表有是谁从哪来。</td></tr><tr><td>观察者列表(Dep)</td><td>订阅者给了观察者列表一个特殊能力, Data数据一旦变动, 利用这个特殊能力(update)回调给订阅者。</td></tr><tr><td>订阅者(Watcher)</td><td>负责向观察者列表中添加(订阅)列表,并附带buff给它,一旦接收到观察者列表回调回来的data后,就将它更新到View。</td></tr></tbody></table><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>我们先贴上一段代码,如果你是vuer肯定很熟悉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">   title: <span class="string">'vue code'</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">   clickMe: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.title = <span class="string">'vue code click'</span>;</div><div class="line">   &#125;,</div><div class="line">  &#125;,</div><div class="line">  mounted: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    window.setTimeout(() =&gt; &#123;</div><div class="line">    this.title = <span class="string">'timeout 1000'</span>;</div><div class="line">   &#125;, 1000);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面要介绍Vue双向数据绑定中用到的一个核心Api(<strong>Object.defineProperty()</strong>)去实现数据监听的。它的详细用法我们不会详细展开,如果你不清楚,点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">MDN</a>花个5分钟就知道怎么回事了。</p><p>代码呈上</p><blockquote><p>defineProperty.html</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"input"</span> onchange=<span class="string">"dochange(this)"</span>&gt;</div></pre></td></tr></table></figure><blockquote><p>defineProperty.js</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var data = &#123;name: <span class="string">'lynhao'</span>&#125;;</div><div class="line">observe(data);</div><div class="line"></div><div class="line"><span class="keyword">function</span> observe(data) &#123;</div><div class="line"> <span class="keyword">if</span> (!data || typeof data !== <span class="string">'object'</span>) <span class="built_in">return</span>;</div><div class="line"> // 取出所有属性遍历</div><div class="line"> Object.keys(data).forEach(<span class="keyword">function</span>(key) &#123;</div><div class="line">   defineReactive(data, key, data[key]);</div><div class="line"> &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> defineReactive(data, key, val) &#123;</div><div class="line">  Object.defineProperty(data, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">false</span>,</div><div class="line">    get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">     <span class="built_in">return</span> val;</div><div class="line">    &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newVal) &#123;</div><div class="line">console.log(<span class="string">'监听到值变化了 '</span>, val, <span class="string">' --&gt; '</span>, newVal);</div><div class="line">val = newVal;</div><div class="line">  &#125;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> dochange(e) &#123;</div><div class="line">  data.name = e.value</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-1-实现监听者"><a href="#2-1-实现监听者" class="headerlink" title="2.1 实现监听者"></a>2.1 实现监听者</h4><p>代码呈上</p><blockquote><p>定义Observer构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Observer (data) &#123;</div><div class="line">  this.data = data;</div><div class="line">  this.loop2React(data);  //遍历data</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在Observer原型对象中添加loop2React和defineReactive,实现对data中的属性监听</p></blockquote><ul><li>Observer</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observer.prototype = &#123;</div><div class="line">    loop2React: <span class="keyword">function</span> (data) &#123;</div><div class="line">        var self = this;</div><div class="line">        Object.keys(data).forEach(<span class="keyword">function</span> (key) &#123;</div><div class="line">            self.defineReactive(data, key, data[key]);</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    defineReactive: <span class="keyword">function</span> (data, key, val) &#123;</div><div class="line">        var childObj = observe(val);</div><div class="line">        Object.defineProperty(data, key, &#123;</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            get: <span class="keyword">function</span> <span class="function"><span class="title">getter</span></span> () &#123;</div><div class="line">             <span class="built_in">return</span> val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> observe (value, vm) &#123;</div><div class="line">    <span class="keyword">if</span> (!value || typeof value !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> new Observer(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="2-1-1-添加观察者列表Dep"><a href="#2-1-1-添加观察者列表Dep" class="headerlink" title="2.1.1 添加观察者列表Dep"></a>2.1.1 添加观察者列表Dep</h5><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">Observer.prototype = &#123;</div><div class="line">    ...省略</div><div class="line">    defineReactive: <span class="keyword">function</span> (data, key, val) &#123;</div><div class="line">  +      var dep = new Dep();</div><div class="line">    /**</div><div class="line">     * var childObj = observe(val); </div><div class="line">     * 通过递归调用observe,可以深度遍历data对象,如</div><div class="line">     * data: &#123;</div><div class="line">     *  category: &#123;</div><div class="line">     *  animal: xxx</div><div class="line">     * &#125;</div><div class="line">     * &#125;</div><div class="line">    **/</div><div class="line">        var childObj = observe(val);</div><div class="line">        Object.defineProperty(data, key, &#123;</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            get: <span class="keyword">function</span> <span class="function"><span class="title">getter</span></span> () &#123;</div><div class="line">               /**</div><div class="line">                * Dep.target其实指向Watcher的实例</div><div class="line">                * 前面我们说过订阅者会添加观察者列表</div><div class="line">                **/</div><div class="line">  +              <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">  +                 dep.addSub(Dep.target);</div><div class="line">  +              &#125;</div><div class="line">                <span class="built_in">return</span> val;</div><div class="line">            &#125;,</div><div class="line">  +          <span class="built_in">set</span>: <span class="keyword">function</span> setter (newVal) &#123;</div><div class="line">  +              <span class="keyword">if</span> (newVal === val) &#123;</div><div class="line">  +                  <span class="built_in">return</span>;</div><div class="line">  +              &#125;</div><div class="line">  +              val = newVal;</div><div class="line">  +              dep.notify(); //data数据变动触发</div><div class="line">  +          &#125;,</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> observe (value, vm) &#123;</div><div class="line">    <span class="keyword">if</span> (!value || typeof value !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> new Observer(value);</div><div class="line">&#125; </div><div class="line">+ <span class="keyword">function</span> <span class="function"><span class="title">Dep</span></span> () &#123;</div><div class="line">+    this.subs = [];  //列表</div><div class="line">+ &#125;</div><div class="line">+ Dep.prototype = &#123;</div><div class="line">+    addSub: <span class="keyword">function</span> (sub) &#123;</div><div class="line">+        this.subs.push(sub);</div><div class="line">+    &#125;,</div><div class="line">+    notify: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">+        this.subs.forEach(<span class="keyword">function</span> (sub) &#123;</div><div class="line">+            sub.update();  //update 最终调用的是watcher的回调函数</div><div class="line">+        &#125;);</div><div class="line">+    &#125;</div><div class="line">+ &#125;;</div></pre></td></tr></table></figure><h4 id="2-2-实现订阅者"><a href="#2-2-实现订阅者" class="headerlink" title="2.2 实现订阅者"></a>2.2 实现订阅者</h4><ul><li>Watcher</li></ul><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Watcher (vm, exp, cb) &#123;</div><div class="line">    this.cb = cb;  //回调函数</div><div class="line">    this.vm = vm;</div><div class="line">    this.exp = exp;</div><div class="line">    this.value = this.get();  // 将自己添加到订阅器的操作</div><div class="line">&#125;</div><div class="line">Watcher.prototype = &#123;</div><div class="line">    update: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        this.run();</div><div class="line">    &#125;,</div><div class="line">    run: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        var value = this.vm.data[this.exp];  // 取到最新值</div><div class="line">        var oldVal = this.value;</div><div class="line">        <span class="keyword">if</span> (value !== oldVal) &#123;</div><div class="line">            this.value = value;</div><div class="line">            this.cb.call(this.vm, value, oldVal);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        Dep.target = this;  // 缓存自己</div><div class="line">        /**</div><div class="line">         *  强制执行监听器里的get函数,把</div><div class="line">         *  this指向了Dep.target,也就是说这个时候订阅者已经</div><div class="line">         *  向Dep中添加了观察者列表</div><div class="line">         *  例如当前我们观察到data中name这个属性,会自动触发</div><div class="line">         *  观察者中监听的getter函数</div><div class="line">         *  </div><div class="line">        **/</div><div class="line">        var value = this.vm.data[this.exp];</div><div class="line">        Dep.target = null;  // 释放自己,确保不会重复添加</div><div class="line">        <span class="built_in">return</span> value;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="实现Compile编译器"><a href="#实现Compile编译器" class="headerlink" title="实现Compile编译器"></a>实现Compile编译器</h2><p>前面的工作只是做了数据层面操作,我们还得将那些data定义的变量解析成数据。</p><p>代码呈上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Compile (el, vm) &#123;</div><div class="line">    this.vm = vm;</div><div class="line">    this.el = document.querySelector(el);</div><div class="line">    this.fragment = null;</div><div class="line">    this.init();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Compile.prototype = &#123;</div><div class="line">    init: function () &#123;</div><div class="line">        if (this.el) &#123;</div><div class="line">            this.fragment = this.nodeToFragment(this.el);</div><div class="line">            this.compileElement(this.fragment);</div><div class="line">            this.el.appendChild(this.fragment);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(&apos;Dom元素不存在&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    nodeToFragment: function (el) &#123;</div><div class="line">        var fragment = document.createDocumentFragment();</div><div class="line">        var child = el.firstChild;</div><div class="line">        while (child) &#123;</div><div class="line">            // 将Dom元素移入fragment中</div><div class="line">            fragment.appendChild(child);</div><div class="line">            child = el.firstChild;</div><div class="line">        &#125;</div><div class="line">        return fragment;</div><div class="line">    &#125;,</div><div class="line">    compileElement: function (el) &#123;</div><div class="line">        var childNodes = el.childNodes;</div><div class="line">        var self = this;</div><div class="line">        [].slice.call(childNodes).forEach(function (node) &#123;</div><div class="line">            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</div><div class="line">            var text = node.textContent;</div><div class="line">  //判断是否元素节点还是文本节点以及其他类型的节点</div><div class="line">            if (self.isElementNode(node)) &#123;</div><div class="line">                self.compile(node);</div><div class="line">            &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</div><div class="line">                self.compileText(node, reg.exec(text)[1]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</div><div class="line">                self.compileElement(node);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>考虑到初始化是页面渲染带来的重绘和重排带来的性能问题,这里我们用到document.createDocumentFragment去创建了一个虚拟节点,我们知道DocumentFragment是不属于文档流的,但它却拥有其他创建dom节点的方法。</p><ul><li>compile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">compile: function (node) &#123;</div><div class="line">        var nodeAttrs = node.attributes;</div><div class="line">        var self = this;</div><div class="line">        Array.prototype.forEach.call(nodeAttrs, function (attr) &#123;</div><div class="line">            var attrName = attr.name;</div><div class="line">            //判断是否是指令,例如v-text</div><div class="line">            if (self.isDirective(attrName)) &#123;</div><div class="line">                var exp = attr.value;</div><div class="line">                var dir = attrName.substring(2);</div><div class="line">                if (self.isEventDirective(dir)) &#123;  // 事件指令</div><div class="line">                    self.compileEvent(node, self.vm, exp, dir);</div><div class="line">                &#125; else &#123;  // v-model 指令</div><div class="line">                    self.compileModel(node, self.vm, exp, dir);</div><div class="line">                &#125;</div><div class="line">                node.removeAttribute(attrName);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>剩余代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Compile.prototype = &#123;</div><div class="line">     ...省略</div><div class="line">      compileText: function (node, exp) &#123;</div><div class="line">        var arr = exp.split(&apos;.&apos;)</div><div class="line">        var self = this;</div><div class="line">        /**深度遍历,例如:</div><div class="line">         * &#123; </div><div class="line">         *   data: &#123;</div><div class="line">         *     a: &#123;</div><div class="line">         *       b: &quot;c&quot;</div><div class="line">         *     &#125;</div><div class="line">         *   &#125;</div><div class="line">         * &#125;</div><div class="line">        **/</div><div class="line">        </div><div class="line">        var _vm = this.vm</div><div class="line">        for(let i=0; i&lt;arr.length; i++) &#123;</div><div class="line">            _vm = _vm[arr[i]]</div><div class="line">        &#125;</div><div class="line">        var initText = _vm[exp];</div><div class="line">        this.updateText(node, initText);</div><div class="line">        new Watcher(this.vm, exp, function (value) &#123;</div><div class="line">            self.updateText(node, value);</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    compileEvent: function (node, vm, exp, dir) &#123;</div><div class="line">        var eventType = dir.split(&apos;:&apos;)[1];</div><div class="line">        var cb = vm.methods &amp;&amp; vm.methods[exp];</div><div class="line"></div><div class="line">        if (eventType &amp;&amp; cb) &#123;</div><div class="line">            node.addEventListener(eventType, cb.bind(vm), false);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    compileModel: function (node, vm, exp, dir) &#123;</div><div class="line">        var self = this;</div><div class="line">        var val = this.vm[exp];</div><div class="line">        this.modelUpdater(node, val);</div><div class="line">        new Watcher(this.vm, exp, function (value) &#123;</div><div class="line">            self.modelUpdater(node, value);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        node.addEventListener(&apos;input&apos;, function (e) &#123;</div><div class="line">            var newValue = e.target.value;</div><div class="line">            if (val === newValue) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            self.vm[exp] = newValue;</div><div class="line">            val = newValue;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    updateText: function (node, value) &#123;</div><div class="line">        node.textContent = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class="line">    &#125;,</div><div class="line">    modelUpdater: function (node, value, oldValue) &#123;</div><div class="line">        node.value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class="line">    &#125;,</div><div class="line">    isDirective: function (attr) &#123;</div><div class="line">        return attr.indexOf(&apos;v-&apos;) == 0;</div><div class="line">    &#125;,</div><div class="line">    isEventDirective: function (dir) &#123;</div><div class="line">        return dir.indexOf(&apos;on:&apos;) === 0;</div><div class="line">    &#125;,</div><div class="line">    isElementNode: function (node) &#123;</div><div class="line">        return node.nodeType == 1;</div><div class="line">    &#125;,</div><div class="line">    isTextNode: function (node) &#123;</div><div class="line">        return node.nodeType == 3;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="实例化MVVM"><a href="#实例化MVVM" class="headerlink" title="实例化MVVM"></a>实例化MVVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Vue (options) &#123;</div><div class="line">    var self = this;</div><div class="line">    this.data = options.data;</div><div class="line">    this.methods = options.methods;</div><div class="line"></div><div class="line">    observe(this.data);</div><div class="line">    new Compile(options.el, this);</div><div class="line">    options.mounted.call(this); // 所有事情处理好后执行mounted函数</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>测试代码</p></blockquote><ul><li>index.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">       el: <span class="string">'#app'</span>,</div><div class="line">       data: &#123;</div><div class="line">           title: <span class="string">'hello mvvm'</span></div><div class="line">         &#125;,</div><div class="line">         methods: &#123;</div><div class="line">           clickMe: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">               this.title = <span class="string">'mvvm click'</span>;</div><div class="line">           &#125;,</div><div class="line">       &#125;,</div><div class="line">       mounted: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">           window.setTimeout(() =&gt; &#123;</div><div class="line">               this.title = <span class="string">'timeout 1000'</span>;</div><div class="line">           &#125;, 1000);</div><div class="line">       &#125;,</div><div class="line">   &#125;);</div></pre></td></tr></table></figure><p>index.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">       &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</div><div class="line">       &lt;input v-model=<span class="string">"name"</span>&gt;</div><div class="line">       &lt;button v-on:click=<span class="string">"clickMe"</span>&gt;click me!&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><blockquote><p>此处为效果图</p></blockquote><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/mvvm.gif" alt="mvvm"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于mvc、mvp和mvvm 这三者的关系这篇文章不会展开叙述,如果你不了解他们, 暂且可以理解他们的演变过程为mvc -&amp;gt; mvp -&amp;gt; mvvm。写这篇文章的时候,mvvm其实网上已经有很多写的不错的文章,为什么还要写这篇文章,你可
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>原型链深入透彻全面释疑及应用</title>
    <link href="http://yoursite.com/2018/05/20/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B7%B1%E5%85%A5%E9%80%8F%E5%BD%BB%E5%85%A8%E9%9D%A2%E9%87%8A%E7%96%91%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/20/原型链深入透彻全面释疑及应用/</id>
    <published>2018-05-20T03:22:41.000Z</published>
    <updated>2018-06-06T09:48:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开始文章之前,大家先自查对原型链的认知到哪里?能否给自己讲清楚原型、构造函数、实例对象、原型链的概念以及他们彼此的联系,还有经常用的instanceof背后原理是否理解,等看完整篇文章后再回头看看这段话,看看对他们的理解是否有进一步加深</p></blockquote><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>什么是原型,我觉得可以这么通俗去理解,只要它是对象,它就有属于它的原型。用代码解释我觉得应该可以让大脑更容易理解并记忆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;</div><div class="line">  this.name = <span class="string">'foo'</span></div><div class="line">&#125;</div><div class="line">var foo = new Foo()</div></pre></td></tr></table></figure><p>这段代码再常见不过,我们定义了一个Foo函数,然后实例化,你能快速指出哪个是实例对象和构造函数器吗?</p><blockquote><p>《在你不知道的JS》一书中,作者说了js其实不像其他oop语言一样会有构造函数,准确说应该是构造函数调用。</p></blockquote><p>是的,我们通过new的方式创建对象,这时<strong>Foo()</strong>就是构造函数,而foo就是实例对象,你答对了吗?也许你有个疑问,为什么new就可以创建一个对象?这个问题我们后面再会解释</p><h3 id="1-1-原型对象"><a href="#1-1-原型对象" class="headerlink" title="1.1 原型对象"></a>1.1 原型对象</h3><p><img src="http://picturegit-1251927503.file.myqcloud.com/prototype.png" alt="bower_gulp"></p><p>如上图,如果你看懂了,原型链这块你就已经掌握了,就没必要看下去了,或者你想挑刺也行</p><p>首先原型对象的好处在于它可以让所以的对象实例共享它所包含的属性和方法,换句话就是我们不用再构造函数中重复定义对象实例的信息</p><p>不推荐的代码呈上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Cat(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> this.eat = eat</div><div class="line">&#125;</div><div class="line">function eat() &#123;</div><div class="line"> console.log(this.food)</div><div class="line">&#125;</div><div class="line">function Dog(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> this.eat = eat</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将eat函数添加到原型对象上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Animal() &#123;&#125;</div><div class="line">Animal.prototype.eat = function() &#123;</div><div class="line"> console.log(this.food)</div><div class="line">&#125;</div><div class="line">function Cat(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> Animal.call(this, this.food)</div><div class="line">&#125;</div><div class="line">function Dog(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> Animal.call(this, this.food)</div><div class="line">&#125;</div><div class="line">Cat.prototype = new Animal()</div><div class="line">Dog.prototype = new Animal()</div></pre></td></tr></table></figure><p>如果看不懂或者因代码量变多而困惑也没关系,你只要先知道原型对象是干啥用就行,至于为什么这么写后面我们会详细讲解。</p><p>构造函数和实例是如何联系?</p><ul><li>通过new关键字创建对象</li></ul><p>js引擎会给每个构造函数都添加一个<strong>prototype</strong>对象,我们通过Function.prototype就可以访问到原型对象,同理,实例对象也有一个访问原型对象的的属性__proto__,如前面那段代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.__proto__ === Foo.prototype //<span class="literal">true</span></div></pre></td></tr></table></figure><p>如果对象有继承关系我们怎么去区分它的原型对象指向那个构造函数呢?<strong>constructor</strong>就是来做这件事</p><h3 id="1-2-原型链原理"><a href="#1-2-原型链原理" class="headerlink" title="1.2 原型链原理"></a>1.2 原型链原理</h3><p>原型链常作为实现继承的主要方法,前面说过,每个构造函数都有自己的原型对象,原型对象都有一个指向构造函数的指针,而实例对象都包含一个(__proto__)指向原型对象的内部。那么如果让原型对象指向另一个类型的实例对象,很显然原型对象将包含一个指向另一个原型的指针,另一个原型也包含一个指向另一个构造函数的指针,层层递进就成为了<strong>原型链</strong>,注意,访问一个实例的时候, 如果在实例本身没有找到调用的属性或者方法, 它会通过__proto__向原型对象上找,如果找不到,继续往上一个原型对象里面的__proto__找,直到Object.prototype,如果找不到则原路返回 。</p><p>如下面代码,我们通过实例对象去访问category对象上的name,因为实例本身并没有name,所有它会通过原型链往上找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Cat(food) &#123;</div><div class="line">  this.food = food</div><div class="line">&#125;</div><div class="line">Cat.prototype.eat = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(this.food)</div><div class="line">&#125;</div><div class="line">Cat.prototype.category = &#123;</div><div class="line">  name: <span class="string">"animal"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">let</span> cat = new Cat(<span class="string">"fish"</span>)</div><div class="line">cat.category.name</div></pre></td></tr></table></figure><h3 id="1-3-instanceof-原理"><a href="#1-3-instanceof-原理" class="headerlink" title="1.3 instanceof 原理"></a>1.3 instanceof 原理</h3><p>我们经常用<strong>instanceof</strong>去判断对象类型,实质上它是判断实例对象的__proto__跟构造函数.prototype 是不是同一个引用</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p> js有哪几种创建对象方式?给你3秒钟想想</p><p> …</p><p> …</p><p> …</p><p>时间到,答案是3种</p><ol><li>字面量创建</li><li>构造函数</li><li>Object.create()</li></ol><h3 id="2-1-字面量创建"><a href="#2-1-字面量创建" class="headerlink" title="2.1 字面量创建"></a>2.1 字面量创建</h3><p>通过直接声明对象的方式比较常见,这里直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;name: &apos;o1&apos;&#125;;</div><div class="line">var o2 = new Object(&#123;name: &apos;o2&apos;&#125;);</div></pre></td></tr></table></figure><h3 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h3><p>前面我们提到到通过普通函数如何通过<strong>new</strong>关键字”处理”后它就升级为构造函数,那么new背后做了什么操作呢?</p><p> new原理:</p><ul><li>第一步: 创建一个空对象,关联构造函数的原型对象</li><li>第二步: 将构造函数作用域赋给新对象,即将this指向新对象</li><li>第三步: 执行构造函数</li><li>第四步: 判断是否有返回值,如果返回对象,这返回,如果不是,则返回关联构造函数对象</li></ul><blockquote><p>伪代码实现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var _new = <span class="keyword">function</span>(cst) &#123;</div><div class="line">  var obj = Object.create(cst.prototype)</div><div class="line">  var o = cst.call(obj)</div><div class="line">  <span class="keyword">if</span>(o.constructor === Object) &#123;</div><div class="line">   <span class="built_in">return</span> o</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">return</span> obj</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-Object-create"><a href="#2-3-Object-create" class="headerlink" title="2.3 Object.create()"></a>2.3 Object.create()</h3><p><strong>Object.create()</strong>这种对象的方式我觉得你应该很少用,但你有想过它背后的工作原理,或者说它创建对象的过程都做什么?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aa = Object.create(a)</div></pre></td></tr></table></figure><ul><li>释疑</li></ul><p>Object.create会创建一个新对象的原型对象赋值给aa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aa.__proto__ === a</div></pre></td></tr></table></figure><p>aa本身是个空对象,要访问a上的属性 也通过__proto__ 去访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var p = &#123;name: <span class="string">'p'</span>&#125;</div><div class="line">var o = Object.create(p)</div><div class="line"></div><div class="line">o.__proto__.name // <span class="string">'p'</span></div></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>在原生js中,一般继承有两种方式</p><ol><li>通过call/apply 改变this指针</li><li>通过原型链继承</li></ol><h3 id="3-1-借用构造函数实现继承"><a href="#3-1-借用构造函数实现继承" class="headerlink" title="3.1 借用构造函数实现继承"></a>3.1 借用构造函数实现继承</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Child().type // <span class="string">'one'</span></div></pre></td></tr></table></figure><p>缺点: <strong>只能继承构造函数上的属性和方法,不能访问父类原型对象上的属性或方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'group'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"><span class="built_in">let</span> child = new Child()</div><div class="line">child.hasOwnProperty(<span class="string">'group'</span>) // <span class="literal">false</span></div></pre></td></tr></table></figure><h3 id="3-2-继承原型链实现继承"><a href="#3-2-继承原型链实现继承" class="headerlink" title="3.2 继承原型链实现继承"></a>3.2 继承原型链实现继承</h3><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'group'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent()</div><div class="line"><span class="built_in">let</span> child = new Child()</div><div class="line">child.type   // <span class="string">'one'</span></div><div class="line">child.hasOwnProperty(<span class="string">'group'</span>)  //<span class="literal">true</span></div></pre></td></tr></table></figure><p>缺点: <strong>原型链被污染</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = [1,2,3]</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent()</div><div class="line"><span class="built_in">let</span> child1 = new Child()</div><div class="line"><span class="built_in">let</span> child2 = new Child()</div><div class="line">child1.group.push(<span class="string">'4'</span>) // [1, 2, 3, 4]</div><div class="line">child2.group // [1, 2, 3, 4]</div></pre></td></tr></table></figure><p>可以看到,我们分别实例化了两个对象child1和child2,我们只希望在child1添加一个元素,但child2的表现出乎我们意料.为什么呢? 因为new这个操作实际上this指向了被实例的对象上,所以从原型链的角度child1和child2都指向Child的原型对象上</p><h3 id="3-3-组合方式"><a href="#3-3-组合方式" class="headerlink" title="3.3 组合方式"></a>3.3 组合方式</h3><p>结合前面两种继承方式实现功能互补</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">    Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line"><span class="built_in">let</span> child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line"></div><div class="line">child1.group.push(<span class="string">'4'</span>) ;</div><div class="line">// Child &#123;<span class="built_in">type</span>: <span class="string">"one"</span>, group: Array(4)&#125;</div><div class="line">child2.group ;</div><div class="line">// Child &#123;<span class="built_in">type</span>: <span class="string">"one"</span>, group: Array(3)&#125;</div></pre></td></tr></table></figure><p>似乎问题得到解决,我们通过实例化构造函数生成两个不同地址的实例,同时又拥有相同的实例属性。细心的你可能已经发现我把group声明在构造函数,那么如果将它添加到原型链上呢是否还可以呢? 你可以暂停阅读先自己去试试</p><p>同样,上面的写法也有缺点: <strong>在子类构造函数执行父类构造函数,没法判断子类的构造函数</strong></p><h3 id="3-4-组合方式优化"><a href="#3-4-组合方式优化" class="headerlink" title="3.4 组合方式优化"></a>3.4 组合方式优化</h3><p>上面那种组合方式,我们在new Child的时候,父类的构造函数被调用了两次,但其实这是多余的.</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = Parent.prototype;</div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div></pre></td></tr></table></figure><p>恩,同样虽然解决多次(2次)调用父类构造函数问题后,它同样存在瑕疵: <strong>没法判断子类的构造函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = Parent.prototype;</div><div class="line"><span class="built_in">let</span> child1 = new Child();</div><div class="line"><span class="built_in">let</span> child2 = new Child();</div><div class="line"></div><div class="line">child1 instanceof Child  //<span class="literal">true</span></div><div class="line">child1 instanceof Parent //<span class="literal">true</span></div></pre></td></tr></table></figure><h3 id="3-5-组合方式再优化"><a href="#3-5-组合方式再优化" class="headerlink" title="3.5 组合方式再优化"></a>3.5 组合方式再优化</h3><p><img src="http://picturegit-1251927503.file.myqcloud.com/prototype.png" alt="bower_gulp"></p><p>不知道你对前面这张原型链还有没印象, 我们说通过<strong>constructor</strong>来区分原型对象的构造函数</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = Object.create(Parent.prototype);</div><div class="line">Child.prototype.constructor = Child; //弥补重写原型丢失的constructor</div><div class="line"></div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line"></div><div class="line">child1.__proto__.constructor === Child //<span class="literal">true</span></div><div class="line">child1.__proto__.constructor === Parent //<span class="literal">false</span></div></pre></td></tr></table></figure><p>有人把这种方式叫做<strong>寄生组合方式继承</strong>,它优点在于弥补前面几种继承方式的缺点,高效体现在只调用了一次父函数,避免了在子函数原型对象上创建多余属性,同时原型链又保持”干净”不变.</p><blockquote><p>好了,原型链这块的所以知识点就这么多了,不知道你看完大脑有没有回路呢?</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开始文章之前,大家先自查对原型链的认知到哪里?能否给自己讲清楚原型、构造函数、实例对象、原型链的概念以及他们彼此的联系,还有经常用的instanceof背后原理是否理解,等看完整篇文章后再回头看看这段话,看看对他们的理解是否有进一步加深&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>{}+{} in Javascript</title>
    <link href="http://yoursite.com/2018/05/17/in-Javascript/"/>
    <id>http://yoursite.com/2018/05/17/in-Javascript/</id>
    <published>2018-05-17T07:37:48.000Z</published>
    <updated>2018-06-02T05:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>【译】by lynhao</p><blockquote><p>涉及Javascript专有名词考虑不影响理解均不作翻译</p></blockquote><p>最近,Gary Bernhardt在”Wat”的闪电讲座上指出Javascript的一个有趣的怪癖:当你添加对象或者数组的时候会得到意想不到的结果.这篇文章解释了这些结果</p><p>在javascript中添加常用的规则很简单:你只能添加数字和字符串,其他类型的值将会转换成他们其中的一种,为了理解它的转换的工作原理,我们首先需要先了解其他一些事情.每当提到段落（如§9.1）时,它就是指代ECMA-262语言标准（ECMAScript 5.1）。</p><p>让我们先从一个快速的复习开始.javascript有两种类型:primitives(基元) and objects(对象),原始类型包括:undefined,null, booleans,numbers,和strings,除此之外其他值都是对象,包括了数组和函数</p><a id="more"></a><h2 id="1-转换值"><a href="#1-转换值" class="headerlink" title="1.转换值"></a>1.转换值</h2><p>加号运算符执行三种转换:  把值转换为<em>primitives</em>, <em>numbers</em>和<em>strings</em></p><h3 id="1-1-通过ToPrimitive-将值转化为primitives"><a href="#1-1-通过ToPrimitive-将值转化为primitives" class="headerlink" title="1.1 通过ToPrimitive()将值转化为primitives"></a>1.1 通过ToPrimitive()将值转化为primitives</h3><pre><code>ToPrimitive(input, PreferredType?)</code></pre><p>可选参数<em>PreferredType</em>是Number 或 String。它只是表示一种<br>偏好, 结果总是可以是任何原始值。如果PreferredType是Number,则执行以下步骤来转换输入的值(§9.1):</p><ol><li>如果输入是原始类型, 则直接返回它</li><li>否者, 输入的值是一个对象, 则调用obj.valueOf().如果结果返回是原始类型,则返回</li><li>否者,调用obj.toString. 如果结果是一个原始类型,则返回</li><li>否者,抛出一个TypeError异常</li></ol><p>如果PreferredType 是String, 2和3步骤交换.如果缺失PreferredType, 那么对于Date的实例设置为String, 其他的值设置为Number</p><h3 id="1-2-通过ToNumber-将值转换为数字"><a href="#1-2-通过ToNumber-将值转换为数字" class="headerlink" title="1.2 通过ToNumber()将值转换为数字"></a>1.2 通过ToNumber()将值转换为数字</h3><ul><li>undefined -&gt; NaN</li><li>null -&gt; +0</li><li>boolean -&gt; (  true -&gt; 1, false -&gt; 0 )</li><li>number -&gt; 不需要转换</li><li>string -&gt; 解析字符串中的数字. 例如: “324”-&gt; 324 (译者: 除字符串数字之外都转为 “NaN”)</li></ul><h3 id="1-3通过ToString（）将值转换为字符串"><a href="#1-3通过ToString（）将值转换为字符串" class="headerlink" title="1.3通过ToString（）将值转换为字符串"></a>1.3通过ToString（）将值转换为字符串</h3><ul><li>undefined -&gt; “undefined”</li><li>null -&gt; + “null”</li><li>oolean -&gt; (  true -&gt; “true” , false -&gt; “false” )</li><li>number -&gt; 解析成字符串数字</li><li>string -&gt; 不需要转换</li></ul><h3 id="1-4-小试牛刀"><a href="#1-4-小试牛刀" class="headerlink" title="1.4 小试牛刀"></a>1.4 小试牛刀</h3><p>下面object允许您观察转换过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">      valueOf: function () &#123;</div><div class="line">          console.log(&quot;valueOf&quot;);</div><div class="line">          return &#123;&#125;; // 不是原始类型</div><div class="line">      &#125;,</div><div class="line">      toString: function () &#123;</div><div class="line">          console.log(&quot;toString&quot;);</div><div class="line">          return &#123;&#125;; // 不是原始类型</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>Number作为函数调用(跟构造函数相反)内部调用ToNumber():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; Number(obj)</div><div class="line">valueOf</div><div class="line">toString</div><div class="line">typeError: 不能将object转换成原始类型的值</div></pre></td></tr></table></figure><h2 id="2-加法"><a href="#2-加法" class="headerlink" title="2. 加法"></a>2. 加法</h2><p>给出下面的加法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value1 + value2</div></pre></td></tr></table></figure><p>为了分析上面的表达式, 采取以下步骤(§11.6.1):</p><ol><li>将两个操作符转换为primitives (数学表示法，而不是JavaScript <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prim1：= ToPrimitive（value1）</div><div class="line">rim2：= ToPrimitive（value2）</div></pre></td></tr></table></figure></li></ol><pre><code>&gt; PreferredType 被忽略因此Number为non-dates,String为dates</code></pre><ol><li>如果prim1或prim2是一个字符串,则将其转换为字符串并返回连接的结果</li><li>否者,将prim1和prim2都转换成数字并返回他们的总和 </li></ol><h3 id="2-1-预期结果"><a href="#2-1-预期结果" class="headerlink" title="2.1 预期结果"></a>2.1 预期结果</h3><p>添加两个数组,一切按预期运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [] + []</div><div class="line">&apos;&apos;</div></pre></td></tr></table></figure><p>首先将[]转换为primitives尝试返回数组本身（this）的valueOf（）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; var arr = [];</div><div class="line">&gt; arr.valueOf() === arr</div><div class="line">true</div></pre></td></tr></table></figure><p>因为返回的结果不是原始类型,紧接着调用toString()返回空字符串(原始类型的值).因此[]+[]返回是两个空字符串联后的结果</p><p>添加数组和对象也符合我们的期望:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [] + &#123;&#125; </div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>补充说明: 将空对象转换成字符串会得到下面的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; String(&#123;&#125;)</div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>之前的结果是””和 ‘[object Object]’ 串联后的返回的。</p><p>更多对象转换为primitives的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 5 + new Number（7）</div><div class="line">12 </div><div class="line">&gt; 6 + &#123;valueOf：function（）&#123;return 2&#125;&#125; </div><div class="line">8 </div><div class="line">&gt;“abc”+ &#123;toString：function（）&#123;return“def”&#125;&#125; </div><div class="line">&apos;abcdef&apos;</div></pre></td></tr></table></figure><h3 id="2-2-意外的结果"><a href="#2-2-意外的结果" class="headerlink" title="2.2. 意外的结果"></a>2.2. 意外的结果</h3><p>如果+的第一个操作符是一个空的对象字面量(如在FireFox的控制台看到的结果)情况就会变得很诡异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + &#123;&#125;</div><div class="line">NaN</div></pre></td></tr></table></figure><p>这里发生了什么?问题在于javascript将第一个{}解析成空的<br>代码块并忽略它.NaN是通过判断+{}(加号后跟第二个{})来计算的.<br>你在这里看到的加号不是二进制的加法运算符而是一个<br>一元前缀运算符,它用与Number()相同方式将其操作符转换<br>成数字.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; +“3.65” </div><div class="line">3.65</div></pre></td></tr></table></figure><p>下面的表达式都是等效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+&#123;&#125;</div><div class="line">   Number(&#123;&#125;)</div><div class="line">   Number(&#123;&#125;.toString())  // &#123;&#125;.valueOf() 不是原始类型的值</div><div class="line">   Number(&quot;[object Object]&quot;)</div><div class="line">   NaN</div></pre></td></tr></table></figure><p>为什么第一个{}被解析成代码块?因为完整的输入值被解析成语句,并且在语句的<br>花括号被解析成开始代码块.因此,你可以通过强制将输入值解析为表达式来解决问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;（&#123;&#125; + &#123;&#125;）</div><div class="line">&apos;[object Object] [object Object]&apos;</div></pre></td></tr></table></figure><p>function或者method的参数也总是被解析成表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; console.log(&#123;&#125; + &#123;&#125;)</div><div class="line">[object Object][object Object]</div></pre></td></tr></table></figure><p>前面解释之后,你应该不再对以下结果感到好奇了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + []</div><div class="line">0</div></pre></td></tr></table></figure><p>再分析一次, 被解析成代码块后跟着+[],以下表达式是等效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+[]</div><div class="line">   Number([])</div><div class="line">   Number([].toString())  // [].valueOf() 不是原始类型的值</div><div class="line">   Number(&quot;&quot;)</div><div class="line">   0</div></pre></td></tr></table></figure><p>有趣的是,<em>Node.js REPL</em>分析其输入值与<em>Firefox</em>或<em>Chrome</em>不同(它甚至使用与Node.js相同的V8 JavaScript引擎.以下的输入值被解析成表达式结果并没有那么出乎意料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + &#123;&#125;</div><div class="line">&apos;[object Object][object Object]&apos;</div><div class="line">&gt; &#123;&#125; + []</div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>这样做的好处是更像使用输入值作为console.log()的参数时获得的结果。但它也不像使用输入值作为程序中的语句。</p><h2 id="3-这是什么意思呢？"><a href="#3-这是什么意思呢？" class="headerlink" title="3.这是什么意思呢？"></a>3.这是什么意思呢？</h2><p>在大多数情况下,理解+在javascript运行机制并没有那么难.你只能添加数字或者字符串.</p><p>对象被转换为字符串（如果另一个操作符是字符串）或数字（否则),如果你想合并数组,你需要用一个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [1, 2].concat([3, 4])</div><div class="line">[ 1, 2, 3, 4 ]</div></pre></td></tr></table></figure><p>Javascript中没有内置的方式去”拼接”(合并)对象.你需要使用库如<em>Underscore</em>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; var o1 = &#123;eeny:1, meeny:2&#125;;</div><div class="line">&gt; var o2 = &#123;miny:3, moe: 4&#125;;</div><div class="line">&gt; _.extend(o1, o2)</div><div class="line">&#123; eeny: 1,</div><div class="line">  meeny: 2,</div><div class="line">  miny: 3,</div><div class="line">  moe: 4 &#125;</div></pre></td></tr></table></figure><p>注意：与Array.prototype.concat（）不同，extend（）修改它的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; o1</div><div class="line">&#123; eeny: 1,</div><div class="line">  meeny: 2,</div><div class="line">  miny: 3,</div><div class="line">  moe: 4 &#125;</div><div class="line">&gt; o2</div><div class="line">&#123; miny: 3, moe: 4 &#125;</div></pre></td></tr></table></figure><p>如果您对操作符有更多兴趣，可以阅读<u>“Fake operator overloading in JavaScript”</u>。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ol><li><strong>JavaScript values: not everything is an object</strong></li></ol><hr><p>原文地址: <a href="http://2ality.com/2012/01/object-plus-object.html" target="_blank" rel="external"><strong>http://2ality.com/2012/01/object-plus-object.html</strong></a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【译】by lynhao&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;涉及Javascript专有名词考虑不影响理解均不作翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近,Gary Bernhardt在”Wat”的闪电讲座上指出Javascript的一个有趣的怪癖:当你添加对象或者数组的时候会得到意想不到的结果.这篇文章解释了这些结果&lt;/p&gt;
&lt;p&gt;在javascript中添加常用的规则很简单:你只能添加数字和字符串,其他类型的值将会转换成他们其中的一种,为了理解它的转换的工作原理,我们首先需要先了解其他一些事情.每当提到段落（如§9.1）时,它就是指代ECMA-262语言标准（ECMAScript 5.1）。&lt;/p&gt;
&lt;p&gt;让我们先从一个快速的复习开始.javascript有两种类型:primitives(基元) and objects(对象),原始类型包括:undefined,null, booleans,numbers,和strings,除此之外其他值都是对象,包括了数组和函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件委托之一二事</title>
    <link href="http://yoursite.com/2018/04/08/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%B9%8B%E4%B8%80%E4%BA%8C%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/04/08/事件委托之一二事/</id>
    <published>2018-04-08T04:03:23.000Z</published>
    <updated>2018-06-01T01:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是指用户或者浏览器自身执行的某种动作, 例如点击事件(click), 鼠标事件(mouseover),按键事件(keyup) 等,为响应某个事件的函数叫做事件处理程序(监听器)</p><h3 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托/代理"></a>事件委托/代理</h3><p>首先之所以需要有时间委托这个概念, 是因为考虑到内存开销和性能优化.试想一下如果我们为了操作一个DOM而到处声明新的引用(对象),会导致增加DOM的访问次数,而JS中函数也是一个对象,对象需要内存空间,所以性能会受影响,如果我们可以在页面生命周期的任何时间点是为它添加事件处理程序,无需等待DOMContentLoaded和load 这两个过程, 并且在同一个范畴内的事件处理程序能够被重用,那么DOM引用减少,内存得到释放,性能就上来.</p><p>所谓的事件委托,是利用了冒泡事件, 通过制定一个处理程序去管理同一类型的事件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=<span class="string">"mylick"</span>&gt;</div><div class="line">&lt;li id=<span class="string">"1"</span>&gt;1&lt;/li&gt;</div><div class="line">&lt;li id=<span class="string">"2"</span>&gt;2&lt;/li&gt;</div><div class="line">&lt;li id=<span class="string">"3"</span>&gt;3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var list = document.getElementById(<span class="string">'mylick'</span>)</div><div class="line">list.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(event) &#123;</div><div class="line">  var target = event.target.id</div><div class="line">  switch (target) &#123;</div><div class="line">     <span class="keyword">case</span> <span class="string">'1'</span>:</div><div class="line">       alert(1)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     <span class="keyword">case</span> <span class="string">'2'</span>:</div><div class="line">       alert(2)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     <span class="keyword">case</span> <span class="string">'3'</span>:</div><div class="line">       alert(3)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     default:</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure><p>ul下的子元素都公用同一个事件处理程序,这就是事件委托</p><h4 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h4><p>传统的事件处理程序,将一个函数赋值给一个事件处理程序属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.onclick = function () &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h4><p>DOM2 包含<u>addEventLinstener</u>和<u>removeEventLinstener</u>两个处理事件方法,接收三个参数: 事件处理名称, 处理函数 和一个布尔值, true表示采用事件捕获, false表示采用事件冒泡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var handler = function () &#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">btn.addEventListener(&apos;click&apos;, handler, false)</div><div class="line">btn.removeEventListener(&apos;click&apos;, handler, false)</div></pre></td></tr></table></figure><h4 id="IE事件处理"><a href="#IE事件处理" class="headerlink" title="IE事件处理"></a>IE事件处理</h4><p>IE跟DOM有所区别, 它提供了attachEvent和detachEvent 两个事件处理方法,但attachEvent()添加的事件处理都会默认被添加到事件冒泡阶段.<br>跟DOM2不同的是, 第一个参数指定的时间名必须是”on+type”开头,而且,attachEvent事件处理是在全局作用域中执行,而DOM却是在所属元素作用域中执行,这一点要注意.</p><h3 id="跨浏览器限制"><a href="#跨浏览器限制" class="headerlink" title="跨浏览器限制"></a>跨浏览器限制</h3><p>我们可以用polyfill写法来越过浏览器对事件处理的差异,一般做法是提供addHandler和removeHandler这两个Api, 分别传入三个参数: 操作元素, 事件名称, 事件处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">  addHandler: function (ele, type, fn) &#123;</div><div class="line">    if (ele.addEventListener) &#123;</div><div class="line">      ele.addEventListner(type, fn, false)</div><div class="line">    &#125; else if (ele.attachEvent) &#123;</div><div class="line">      ele.attachEvent(&apos;on&apos;+type, fn, false)</div><div class="line">    &#125; else &#123;</div><div class="line">      ele[&apos;on&apos;+type] = fn</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">   removeHandler: function (ele, type, fn) &#123;</div><div class="line">    if (ele.removeEventListener) &#123;</div><div class="line">      ele.removeEventListner(type, fn, false)</div><div class="line">    &#125; else if (ele.detachEvent) &#123;</div><div class="line">      ele.detachEvent(&apos;on&apos;+type, fn, false)</div><div class="line">    &#125; else &#123;</div><div class="line">      ele[&apos;on&apos;+type] = null</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>–<br>参考资料: 红宝书</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h3&gt;&lt;p&gt;事件是指用户或者浏览器自身执行的某种动作, 例如点击事件(click), 鼠标事件(mouseover)
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack渐入佳境</title>
    <link href="http://yoursite.com/2018/04/03/webpack%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/"/>
    <id>http://yoursite.com/2018/04/03/webpack渐入佳境/</id>
    <published>2018-04-02T16:22:13.000Z</published>
    <updated>2018-06-16T15:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只会使用CLI,技术永远得不到提升,既然你看到这篇文章说明你渴望学习到webpack更多干货,不讲太多废话,直接进入主题,此文假设您已经具备一定的前端基础,至少知道node是什么玩意就行.</p></blockquote><a id="more"></a><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir wpDemo   //新建目录</div><div class="line">npm init       //初始化工程</div></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i vue -S</div><div class="line">npm i webpack@3.10.0 vue-loader css-loader vue-template-compiler -D</div></pre></td></tr></table></figure><ul><li>这里我们的工程以3.+为示例</li><li>-D 是指将webpack安装到devDependencies, 因为最终的生产环境并不需要</li><li>-S 会装到dependencies中</li></ul><h2 id="创建src目录"><a href="#创建src目录" class="headerlink" title="创建src目录"></a>创建src目录</h2><p>分别创建App.vue, index.js</p><p>App.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line"> &lt;div id=<span class="string">"app"</span>&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">  <span class="built_in">export</span> default &#123;</div><div class="line">  <span class="function"><span class="title">data</span></span>() &#123;</div><div class="line">   <span class="built_in">return</span> &#123;</div><div class="line">    text: <span class="string">'text'</span></div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style scoped&gt;</div><div class="line"></div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><p>这部分代码只是拿来做模板显示</p><p>index.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">import App from <span class="string">'./app.vue'</span></div><div class="line">const root = document.createElement(<span class="string">'div'</span>)</div><div class="line">document.body.appendChild(root)</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  render: (h) =&gt; h(App)</div><div class="line">&#125;).<span class="variable">$mount</span>(root)</div></pre></td></tr></table></figure><p>这个将会作为webpack的入口文件, 我们通过声明一个Vue的实例,将其挂载到我们创建的root上,然后通过render函数渲染到App.vue中的template 展示到浏览器上</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> wpDemo</div><div class="line">touch webpack-config.js</div></pre></td></tr></table></figure><p>这里我们要实现将代码用webpack进行打包,放到dist目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const path = require(<span class="string">'path'</span>)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: path.join(__dirname, <span class="string">'./src/index'</span>),  //指定入口文件</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,   //指定打包后的文件名</div><div class="line">    path: path.join(__dirname, <span class="string">'dist'</span>)  //打包后输出路径</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">test</span>: /\.vue$/,</div><div class="line">        loader: <span class="string">'vue-loader'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>module.rules 我们用来配置它的规则, 告诉webpack要处理哪种类型的文件,这里是以.vue格式类型文件, 再指定对应的loader去解析它, 因为我们的webpack它只认识javascript,不认得vue</p></blockquote><h2 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h2><p>package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure><p>这样我们就可以通过下面命令去打包项目,最终生成dist,里面存放我们指定的”bundle.js”文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/lynhao/wpDemo" target="_blank" rel="external"><strong>源码地址</strong></a></h2><p>NOT EDN~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;只会使用CLI,技术永远得不到提升,既然你看到这篇文章说明你渴望学习到webpack更多干货,不讲太多废话,直接进入主题,此文假设您已经具备一定的前端基础,至少知道node是什么玩意就行.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread之源码完全解析</title>
    <link href="http://yoursite.com/2018/03/19/HandlerThread%E4%B9%8B%E6%BA%90%E7%A0%81%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/19/HandlerThread之源码完全解析/</id>
    <published>2018-03-19T08:36:32.000Z</published>
    <updated>2018-06-01T01:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文是我还在学校[2016-06-28]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正文开始之前如果你对Handler还存有疑惑，建议先看看我的另一篇文章<strong><u>从源码角度分析Handler、Looper、MessageQueue三角关系</u></strong>再继续看下去，如果已经有了一定的了解了，接下来这篇文章读起来将会很轻松哒~</p><p>在开始HandlerThread源码之前我们先写一个与线程相关的Handler</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><ul><li>time.xml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span></div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=<span class="string">"@+id/id_textview"</span></div><div class="line">        android:text=<span class="string">"正在加载..."</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:paddingTop=<span class="string">"100dp"</span></div><div class="line">        android:textSize=<span class="string">"15sp"</span>/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure><p>布局很简单，一个TextView去展示界面</p><ul><li>TimeActivity.java</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by linhao on 16/6/26.</div><div class="line"> */</div><div class="line">public class TimeActivity extends Activity &#123;</div><div class="line">    private TextView textView;</div><div class="line">    private static int MSG_UPDATE_INFO = 1;</div><div class="line"></div><div class="line">    class MyThread extends Thread&#123;</div><div class="line">        public  Handler mhandler ;</div><div class="line">        public Looper looper;</div><div class="line">        @Override</div><div class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            super.run();</div><div class="line">            Looper.prepare();</div><div class="line">            looper = Looper.myLooper();</div><div class="line">            mhandler = new <span class="function"><span class="title">Handler</span></span>()&#123;</div><div class="line">                @Override</div><div class="line">                public void handleMessage(Message msg) &#123;</div><div class="line">                    super.handleMessage(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private MyThread myThread;</div><div class="line">    //创建主线程handler</div><div class="line">    private Handler mHandler = new Handler();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.block);</div><div class="line">        textView = (TextView) findViewById(R.id.id_textview);</div><div class="line">        //创建后台线程</div><div class="line"></div><div class="line">        initBackThread();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">initBackThread</span></span>() &#123;</div><div class="line">        myThread = new MyThread();</div><div class="line">        myThread.start();</div><div class="line"></div><div class="line">        myThread.mhandler = new Handler(myThread.looper)&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                checkForUpdate();</div><div class="line">                myThread.mhandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    private void <span class="function"><span class="title">checkForUpdate</span></span>() &#123;</div><div class="line">        //模拟耗时操作</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">            mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">                @Override</div><div class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">                    Date date = new Date();</div><div class="line">                    DateFormat today = new SimpleDateFormat(<span class="string">"yyyy年MM月dd日 hh时mm分ss秒 EE"</span>, Locale.CHINA);</div><div class="line">                    textView.setText(today.format(date));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onResume</span></span>() &#123;</div><div class="line">        super.onResume();</div><div class="line">        myThread.mhandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onPause</span></span>() &#123;</div><div class="line">        super.onPause();</div><div class="line">        myThread.mhandler.removeMessages(MSG_UPDATE_INFO);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码我们定义一个内部类MyThread，紧接着通过<u>looper = Looper.myLooper()</u>拿到储存在sThreadLocal的Looper实例,如果这里听不懂的话建议回头看看从源码角度分析Handler、Looper、MessageQueue三角关系这篇文章,重写handleMessage最后调用Looper的loop方法，从MessageQueue中去取消息。定义一个checkForUpdate方法模拟从服务器解析数据，通过post方法创建一个线程，最后在run方法里面更新UI，模拟时钟。</p><blockquote><p>咳咳,这里我得先打住,有谁看到这段代码以为是创建了一个线程请举个手(yo~put ur hands up🙌)！！！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我告诉你其实什么线程都没有被创建，请看源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean post(Runnable r)</div><div class="line">&#123;</div><div class="line">   <span class="built_in">return</span>  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>是不是觉得这几行代码很亲切呢，继续看下去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static Message getPostMessage(Runnable r) &#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="built_in">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，getPostMessage将Runnable的对象r复制给了Message的callback。回头看看sendMessageDelayed是不是很熟悉呢？没错，跟handler的sendMessageDelayed一模一样。我们再看看下面这段代码  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != null) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们拿到Looper对象后通过Looper.loop()方法在MessageQueue中不断轮回拿取数据，然后回调msg.target.dispatch(…),这里通过判断msg.callback是否为空，如果不为空就执行回调方法handleCallback(msg),而在前面我们已经给callback赋值了，就是<strong>Runnable</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static void handleCallback(Message message) &#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>紧接着调用run方法在里面更新我们的UI代码，代码其实就这些，一点也不复杂是不是？<br>插叙就这么多，接着我们打开模拟器Genymotion运行下我们的代码</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/andr1.jpg?raw=true" alt="stack"></p><p>我们发现程序奔溃了，正常思维我们看看日志报什么错误</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/errorCut/andr.jpg?raw=true" alt="stack"></p><p>日志报了个RuntimeException空指针错误，为什么呢？我们再看看这行代码myThread.mhandler = new Handler(myThread.looper)，我们传入新建的thread的looper，这里涉及到了线程并发的问题因为两个线程交叉运行当编译器运行到这段代码时但此时的looper却没被创建就会报出空指正的问题。那我们改如何避免这个问题呢？很幸运google已经帮我事先考虑到了，所以才有了HandlerThread，下面修改下代码，仅两处</p><ul><li>1、定义一个HandlerThread和Handler</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private HandlerThread mCheckMsgThread;</div><div class="line">private Handler mCheckHandler;</div></pre></td></tr></table></figure><p>这里我们不再需要MyThread这个类了，在initBackThread方法内实例化HandlerThread</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mCheckMsgThread = new HandlerThread(<span class="string">"随意"</span>);</div><div class="line">mCheckMsgThread.start();</div></pre></td></tr></table></figure><p>HandleThread需要传入有个线程名字，这里随意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mCheckHandler = new Handler(mCheckMsgThread.getLooper())&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                checkForUpdate();</div><div class="line">                mCheckHandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>我们重新跑一次程序(掉帧得好厉害，但效果还是看得出来啦~)</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/andr.gif?raw=true" alt="stack"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文是我还在学校[2016-06-28]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从源码角度分析Handler、Looper、MessageQueue三角关系</title>
    <link href="http://yoursite.com/2018/03/19/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Handler%E3%80%81Looper%E3%80%81MessageQueue%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/03/19/从源码角度分析Handler、Looper、MessageQueue三角关系/</id>
    <published>2018-03-19T08:03:18.000Z</published>
    <updated>2018-06-01T01:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文是我还在学校[2016-06-27]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上次更新已经有一个多星期了，最近忙于找工作所以更新速度有所延迟，最近老是碰壁，但文章咱们还是要更新的。今天我们来讲讲Handler、Looper、MessageQueue三者的那些事，这是上篇，后面我会继续更新我对Handler的理解。Ok，下面进入今天正题。</p><h3 id="💭什么是Handler？它有啥存在价值？"><a href="#💭什么是Handler？它有啥存在价值？" class="headerlink" title="💭什么是Handler？它有啥存在价值？"></a>💭什么是Handler？它有啥存在价值？</h3><blockquote><p><a href=""><strong>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</strong></a></p><p>我把它概括为:handler是一套消息传递机制，我们可以通过通过它来发消息和接收消息</p></blockquote><h3 id="💭我们可以拿它做什么："><a href="#💭我们可以拿它做什么：" class="headerlink" title="💭我们可以拿它做什么："></a>💭我们可以拿它做什么：</h3><ul><li>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.<br>翻译过来就是：可以调度消息和runnable对象作为将来的执行；将被执行在一个不同的线程自己的行动。其实我们最常见的就是通过handler来更新UI。下面我们就开始从源码角度分析Handler、Looper、MessageQueue。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>每个应用程序都是通过ActivityThread创建的，而在这个线程中里面有个main方法</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/handler.jpg?raw=true" alt="stack"></p><p>我们可以看到在main中有一个Looper.prepareMainLooper(),我们按住cmd+shift+R跳转过去看这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void <span class="function"><span class="title">prepareMainLooper</span></span>() &#123;</div><div class="line">       prepare(<span class="literal">false</span>);</div><div class="line">       synchronized (Looper.class) &#123;</div><div class="line">           <span class="keyword">if</span> (sMainLooper != null) &#123;</div><div class="line">               throw new IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">           &#125;</div><div class="line">           sMainLooper = myLooper();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>单击进入prepare方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里通过<u>判断sThreadLocal.get()判断存储变量是否为空，默认是没有的，所以会调用sThreadLocal.set(new Looper(quitAllowed))创建一个Looper对象。</u>我们继续跟进Looper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到在构造方法中创建了一个MessageQueue(我们称之为消息队列)我们创建了looper对象之后，会通过Looper.loop()去从消息队列中进行消息轮回。紧接着我们单击进入loop这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static void <span class="function"><span class="title">loop</span></span>() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == null) &#123;</div><div class="line">        throw new RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    // Make sure the identity of this thread is that of the <span class="built_in">local</span> process,</div><div class="line">    // and keep track of what that identity token actually is.</div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        <span class="keyword">if</span> (msg == null) &#123;</div><div class="line">            // No message indicates that the message queue is quitting.</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        // This must be <span class="keyword">in</span> a <span class="built_in">local</span> variable, <span class="keyword">in</span> <span class="keyword">case</span> a UI event sets the logger</div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != null) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">     <span class="keyword">if</span> (logging != null) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback    );</div><div class="line">        &#125;</div><div class="line">       // Make sure that during the course of dispatching the</div><div class="line">        // identity of the thread wasn<span class="string">'t corrupted.</span></div><div class="line">        final long newIdent = Binder.clearCallingIdentity();</div><div class="line">        if (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, "Thread identity changed from 0x"</div><div class="line">                    + Long.toHexString(ident) + " to 0x"</div><div class="line">                    + Long.toHexString(newIdent) + " while dispatching to "</div><div class="line">                    + msg.target.getClass().getName() + " "</div><div class="line">                    + msg.callback + " what=" + msg.what);</div><div class="line">        &#125;</div><div class="line">     msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面代码第一句的位置我们看到有个myLooper方法，跟进进去我们看到它的返回值是从ThreadLocal存储的Looper实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static @Nullable Looper <span class="function"><span class="title">myLooper</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> sThreadLocal.get();</div><div class="line">&#125;  </div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != null) &#123;</div><div class="line">       throw new RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);    &#125;</div><div class="line">   sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final MessageQueue queue = me.mQueue;是拿到looper实例中的消息队列MessageQueue 源码上边已经贴出了</p><p>第三处高亮( for (;;)…)就是消息轮回最关键的部分，可以看到它其实就是一个死循环，并从消息队列中取出消息，如果为空的话就阻塞，不为空的话它会调用第四处高亮位置的代码 msg.target.dispatchMessage(msg)。这里的msg.target其实指的就是handler自己本身，我们使用handler去更新UI，通过sendEmptyMessage发送消息，然后重写handleMessage去回调，这里面底层就是通过msg.target.dispatchMessage去发送的。下面我们看看具体的涉及的源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessage(Message msg)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">return</span> sendMessageDelayed(msg, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; 0) &#123;</div><div class="line">        delayMillis = 0;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一直跳到sendMessageAtTime后拿到mQueue，进行放空判断，最后返回我们期待已久的enqueueMessage方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>msg.target = this;这句代码就是把当前的handler赋值给msg的目标地址，最终调用queue.enqueueMessage将消息发送给handler自己，最终保存到消息队列中去。<br>到这里流程已经很清晰了，首先我们先通过Looper的prepare去创建一个looper对象，该实例中保存了一个MessageQueue给mQueue，紧接着通过Looper的loop方法，通过一个没有任何参数约束的for语句死循环将消息队列中的消息不断轮回，最后调用msg.target.dispatchMessage(msg)</p><p><em>我们回过来看看dispatchMessage</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != null) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也就是为什么我们要重写handleMessage这个方法的原因 ，因为msg.target.dispatchMessage(msg)是最终调用的方法，而msg的值是什么？就是我们之前在enqueueMessage消息队列中储存的信息~<br>最后总结handler、Messagequeue和looper这三者中的三角关系：<br>首先handler负责去发送消息，通过looper进行一对一的绑定【Looper.myLooper()】，然后looper将消息回传给handler，最后handler自己对发送过来消息进行处理。p.s可能你会跟我一样在第一次第一次接触handler有这样的疑惑—为什么我们很多时候没有通过Looper.prepare()和Looper.loop()方法去创建一个Looper对象？如果你还有这个问题的话，请回头看看第一段~<br>ok，这篇文章就先说到这儿，如有哪儿说得不好请麻烦指出不尽感激哈~最后再说一句个人感受：就是每一次用到handler这种异步处理机制都会有不同的认识，大家一起加油吧😊</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文是我还在学校[2016-06-27]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018,请抓紧时间</title>
    <link href="http://yoursite.com/2018/02/23/2018-%E8%AF%B7%E6%8A%93%E7%B4%A7%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2018/02/23/2018-请抓紧时间/</id>
    <published>2018-02-23T12:31:21.000Z</published>
    <updated>2018-06-01T01:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时不待人"><a href="#时不待人" class="headerlink" title="时不待人"></a>时不待人</h3><p>明天就要返工了, 难免有点抵触情绪, 我也好久没更新博客了,这篇文章归类为<a href=""><strong>生活类</strong></a>, 我不想在这里写太多我的太多心声, 因为我不想让一些认识我的人但不了解我的人知道或揣摩我的动态, 前几天在扇贝看到一句话, 翻译过来大概意思就是 做事要抓紧,尽快实现它,越拖延实现它的概率越低, 我就是这么一个人, 我有时总会以我只读了两年大学安慰自己, 或者以我才转前端不到一年给自己找借口(我从17年3月份从Java转为web前端), 既然”书”读的少, 那自己就要更加约束自己, 2018, 我有自己的目标, 去年我在工作的之余投入学习的时间不科学, 以至于每到年底总有一种啥都不会的想法, 18年,我希望我能从日常一些小事做起, 例如给自己做饭, 给日常事情安排先后顺序, 这样我就可以少熬夜, 因为熬夜会让人变笨. 好了, 就写到这里, 我并不希望有人看到这篇文章 [当然如果被游客或者爬虫无意看到也无妨, 因为这样的逻辑估计也很难看懂]</p><hr><p><a href=""><strong>Bye</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时不待人&quot;&gt;&lt;a href=&quot;#时不待人&quot; class=&quot;headerlink&quot; title=&quot;时不待人&quot;&gt;&lt;/a&gt;时不待人&lt;/h3&gt;&lt;p&gt;明天就要返工了, 难免有点抵触情绪, 我也好久没更新博客了,这篇文章归类为&lt;a href=&quot;&quot;&gt;&lt;strong&gt;生活类&lt;/s
      
    
    </summary>
    
    
      <category term="person business" scheme="http://yoursite.com/tags/person-business/"/>
    
  </entry>
  
  <entry>
    <title>Charles实现代理</title>
    <link href="http://yoursite.com/2017/08/16/Charles%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/16/Charles实现代理/</id>
    <published>2017-08-16T13:20:25.000Z</published>
    <updated>2018-06-01T01:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="写文起因"><a href="#写文起因" class="headerlink" title="写文起因"></a>写文起因</h3><blockquote><p>今天早上后端一个同事让我改个页面,我一看很简单,花了几分钟就做完并commit到了git上,过了一会那个同事发扣扣说我改漏了一些东西…..</p></blockquote><a id="more"></a><p>是的,前端日常琐事可真不少,特别是改线上的项目,操作比较麻烦,那有什么方法可以解决这个问题呢?(多此一举题目不是说了…).是的,在win平台上很多前端都用一款抓包工具–<a href="http://www.telerik.com/fiddler" target="_blank" rel="external"><strong>Fiddler</strong></a> ,准确说它是一款代理工具,我们可以将服务器上需要改动的文件映射到本地文件,接着我们就可以在本地做需求修改,并且可以在外网上可以看到你修改的内容,是不是很激动还有这种操作呢,嘿嘿嘿~. But,很遗憾,fiddler在win平台上(基于C#开发)运行很完美但在OSX平台上却诟病诸多,所以今天笔者我发现了在OSX跟fiddler有得一拼的工具–<a href="https://www.charlesproxy.com/" target="_blank" rel="external"><strong>Charles</strong></a></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/charles.png?raw=true" alt="stack"></p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>既然说到这款神器,那就介绍它是如何实现代理的</p><ol><li>设置全局代理,否者你会抓不到包的</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/1.png?raw=true" alt="stack"></p><ol><li>设置匹配规则(这只是个筛选)</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic2.png?raw=true" alt="stack"></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic3.png?raw=true" alt="stack"></p><ol><li>禁用缓存(这个不勾选也不影响), 设置代理的本地路径</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic4.png?raw=true" alt="stack"></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic5.png?raw=true" alt="stack"></p><p>好了,通过上面的步骤就已经成功代理了! But, Charles是一款付费软件,试用期官方给了30天, 网上给了好多破解版,有的说把charles.jar替换了就行, 中间涉及到修改osx的安全隐私权限,笔者没有打算尝试这样做,好在,我无意发现有个<a href=""><strong>generous man</strong></a>无私贡献出了他的Registered Name和License Key,这里贴上他的<a href="https://zhile.io" target="_blank" rel="external"><strong>博客</strong></a>地址以示感谢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Charles Proxy License</div><div class="line">// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</div><div class="line">// Charles 4.1.3目前是最新版，可用。</div><div class="line">Registered Name: https://zhile.io</div><div class="line">License Key: 48891cf209c6d32bf4</div></pre></td></tr></table></figure><blockquote><p>最后还要声明:尊重版权,尊重劳动成果,但如果有人像那位博主这么慷慨我们也不好拒绝🤗😌🤓</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;写文起因&quot;&gt;&lt;a href=&quot;#写文起因&quot; class=&quot;headerlink&quot; title=&quot;写文起因&quot;&gt;&lt;/a&gt;写文起因&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天早上后端一个同事让我改个页面,我一看很简单,花了几分钟就做完并commit到了git上,过了一会那个同事发扣扣说我改漏了一些东西…..&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>mongodb环境搭建(补充)</title>
    <link href="http://yoursite.com/2017/07/18/mongodb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/07/18/mongodb环境搭建/</id>
    <published>2017-07-18T04:59:35.000Z</published>
    <updated>2018-06-01T01:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>这里只做macos环境下搭建,用wins系统同学有兴趣也可以瞧瞧</p></blockquote><p>–<br>mac用户对<a href=""><strong>HomeBrew</strong></a>这个包管理工具应该再熟悉不过,还没有安装的童鞋可以通过下面命令行安装,具体请参照<a href="https://brew.sh/" target="_blank" rel="external"><strong>官网</strong></a>,这里不是我们这篇文章的重点.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div></pre></td></tr></table></figure><h3 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew update</div><div class="line">brew install mongoldb</div></pre></td></tr></table></figure><blockquote><p>这里有必要多说一句,每次执行brew都会默认执行update操作,请确保你已经开启科学上网模式不然速度你懂得,听说国内也有镜像大家可以自行搜索🔍</p></blockquote><p>安装完成你应该会看到类似这样<br><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.13.22.png" alt="stack"></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>打开终端第一个窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo mongod --config /usr/<span class="built_in">local</span>/etc/mongod.conf  //启动配置文件</div></pre></td></tr></table></figure><p>这时服务器会呈现等待状态等待用户连接,接着command+d开启另一个窗口,连接服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ mongo</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.27.42.png" alt="stack"></p><p>最后打开浏览器,mongodb默认端口是27017,输入127.0.0.1:27017或者localhost:27017,你看到下图就表示成功了~</p><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.21.23.png" alt="stack"></p><blockquote><p>修改补充  time: <a href=""><strong>2017年07月21日16:19:49</strong></a></p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>3天前说的那种方式可能不能完全你的需求,可能我是一个喜欢折腾的人吧,因为这两天我想自己创建一个项目数据库是单独出来而不是跟之前一样默认创建在<a href=""><strong>/data/db</strong></a>下.同样这篇文章不适用于wins系统,但Linux必须支持</p><h4 id="1-1-通过scons编译"><a href="#1-1-通过scons编译" class="headerlink" title="1.1 通过scons编译"></a>1.1 通过scons编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scons all</div></pre></td></tr></table></figure><p>如果编译不通过可以在官网下载对应编译好的二进制文件,我本地是osx,不用这么麻烦直接下载对应的zip文件解压就行,我用的版本是<a href=""><strong>3.4.6</strong></a>,mac用户如果是用前面说的brew直接安装,编译好的文件会放在这个目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/Cellar/mongodb/3.4.6/</div></pre></td></tr></table></figure></p><p>bin目录有几个是要特别留意的</p><ul><li>mongo </li><li>mongod  </li><li>mongodump</li><li>mongorestore</li><li>mongoexport</li><li>mongoimport</li><li>mongooplog</li></ul><h3 id="创建mongodb-pro"><a href="#创建mongodb-pro" class="headerlink" title="创建mongodb_pro"></a>创建mongodb_pro</h3><p>分别创建四个二级目录,分别保存编译好的文件,配置文件,数据库,日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ mkdir mongodb_pro</div><div class="line">➜  ~ <span class="built_in">cd</span> mongodb_pro</div><div class="line">➜  mongodb_pro mkdir data</div><div class="line">➜  mongodb_pro mkdir <span class="built_in">log</span></div><div class="line">➜  mongodb_pro mkdir conf</div><div class="line">➜  mongodb_pro mkdir bin</div></pre></td></tr></table></figure><ul><li>紧接着把之前下载后编译的mongodb文件复制到bin目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -R -n /usr/<span class="built_in">local</span>/Cellar/mongodb/3.4.6/bin/ bin</div></pre></td></tr></table></figure><ul><li>编写conf配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim mongodb.conf</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">port = 12345   </div><div class="line">dbpath = data</div><div class="line">logpath = log/mongod.log </div><div class="line">fork = true   </div><div class="line"></div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">&quot;mongodb.conf&quot; 5L, 65C</div></pre></td></tr></table></figure><ol><li><p>port:端口</p></li><li><p>dbpath:指明monogod数据存储目录</p></li><li><p>logpath:指明日志存储目录,需要指明一个路径</p></li><li><p>fork:表示linux下表明使用后台进程,但wins无效</p></li></ol><blockquote><p>如果不会使用vim的话可以通过本地文本编辑器</p></blockquote><ul><li>回到根目录启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ ./bin/mongod <span class="_">-f</span> conf/mongodb.conf</div></pre></td></tr></table></figure><p>接着你会看到输出这段信息,表示已经启动</p><blockquote><p>about to fork child process, waiting until server is ready for connections.<br>forked process: 4855<br>child process started successfully, parent exiting</p></blockquote><ul><li>查看data,发现里面已经有数据了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro cd data</div><div class="line">➜  data ls</div><div class="line">WiredTiger</div><div class="line">WiredTiger.lock</div><div class="line">WiredTiger.turtle</div><div class="line">WiredTiger.wt</div><div class="line">WiredTigerLAS.wt</div><div class="line">_mdb_catalog.wt</div><div class="line">collection-0-2146738068862245035.wt</div><div class="line">collection-2-2146738068862245035.wt</div><div class="line">diagnostic.data</div><div class="line">index-1-2146738068862245035.wt</div><div class="line">index-3-2146738068862245035.wt</div><div class="line">index-4-2146738068862245035.wt</div><div class="line">journal</div><div class="line">mongod.lock</div><div class="line">sizeStorer.wt</div><div class="line">storage.bson</div></pre></td></tr></table></figure><ul><li>查看日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro cd ./log</div><div class="line">➜  log ls</div><div class="line">mongod.log</div><div class="line">➜  log tail mongod.log</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T15:53:58.281+0800 I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory &apos;/Users/linhao/mongodb_pro/data/diagnostic.data&apos;</div><div class="line">2017-07-21T15:53:58.388+0800 I INDEX    [initandlisten] build index on: admin.system.version properties: &#123; v: 2, key: &#123; version: 1 &#125;, name: &quot;incompatible_with_version_32&quot;, ns: &quot;admin.system.version&quot; &#125;</div><div class="line">2017-07-21T15:53:58.388+0800 I INDEX    [initandlisten]  building index using bulk method; build may temporarily use up to 500 megabytes of RAM</div><div class="line">2017-07-21T15:53:58.406+0800 I INDEX    [initandlisten] build index done.  scanned 0 total records. 0 secs</div><div class="line">2017-07-21T15:53:58.407+0800 I COMMAND  [initandlisten] setting featureCompatibilityVersion to 3.4</div><div class="line">2017-07-21T15:53:58.407+0800 I NETWORK  [thread1] waiting for connections on port 12345</div></pre></td></tr></table></figure><blockquote><p>最后一句可以看到服务等待端客户端连接,对应端口为12345而不是默认的27017</p></blockquote><p>最后利用bin目录下的mongo客户端连接服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/mongo localhost:12345/<span class="built_in">test</span></div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro ./bin/mongo localhost:12345/test</div><div class="line">MongoDB shell version v3.4.6</div><div class="line">connecting to: mongodb://localhost:12345/test</div><div class="line">MongoDB server version: 3.4.6</div><div class="line">Server has startup warnings:</div><div class="line">2017-07-21T16:10:19.703+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T16:10:19.703+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017-07-21T16:10:19.704+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017-07-21T16:10:19.704+0800 I CONTROL  [initandlisten]</div></pre></td></tr></table></figure><p>如需关服务,在游标输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><blockquote><p>但这时会报这个错误:shutdown command only works with the admin database; try ‘use admin’</p></blockquote><p>按照提示这样解决:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server should be down...</div><div class="line">2017-07-21T16:10:09.556+0800 I NETWORK  [thread1] trying reconnect to localhost:12345 (127.0.0.1) failed</div><div class="line">2017-07-21T16:10:09.557+0800 W NETWORK  [thread1] Failed to connect to 127.0.0.1:12345, in(checking socket for error after poll), reason: Connection refused</div><div class="line">2017-07-21T16:10:09.557+0800 I NETWORK  [thread1] reconnect localhost:12345 (127.0.0.1) failed failed</div></pre></td></tr></table></figure><hr><p>全文结束😌</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这里只做macos环境下搭建,用wins系统同学有兴趣也可以瞧瞧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;–&lt;br&gt;mac用户对&lt;a href=&quot;&quot;&gt;&lt;strong&gt;HomeBrew&lt;/strong&gt;&lt;/a&gt;这个包管理工具应该再熟悉不过,还没有安装的童鞋可以通过下面命令行安装,具体请参照&lt;a href=&quot;https://brew.sh/&quot;&gt;&lt;strong&gt;官网&lt;/strong&gt;&lt;/a&gt;,这里不是我们这篇文章的重点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨Generator高逼格操作</title>
    <link href="http://yoursite.com/2017/07/14/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Generator%E9%AB%98%E9%80%BC%E6%A0%BC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/07/14/深入探讨Generator高逼格操作/</id>
    <published>2017-07-14T07:46:39.000Z</published>
    <updated>2018-06-01T01:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>es6 中引入了Generator Function（生成器函数）这个新特性,这篇文章会从以下4个点介绍,文章篇幅会有点长,请备好电源🤖</p></blockquote><ol><li>理解generator✅</li><li>如何用generator特性实现异步请求✅</li><li>generator结合co库实现实现异步请求,自动流程✅</li><li>generator其他应用✅</li></ol><a id="more"></a><h3 id="1-理解Generator"><a href="#1-理解Generator" class="headerlink" title="1.理解Generator"></a>1.理解Generator</h3><p>我们先上段代码,先瞧瞧generator是什么样子,当然你也可以把它叫做<a href=""><strong>生成器</strong></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let tell=function* ()&#123;</div><div class="line">    yield &apos;a&apos;;</div><div class="line">    yield &apos;b&apos;;</div><div class="line">    return &apos;c&apos;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">   let k=tell();</div><div class="line">   </div><div class="line">    k.next()      //&#123;value: &quot;a&quot;, done: false&#125;</div><div class="line">    k.next()      //&#123;value: &quot;b&quot;, done: false&#125;</div><div class="line">    k.next()      //&#123;value: &quot;c&quot;, done: true&#125;</div><div class="line">    k.next()      //&#123;value: undefined, done: true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不知大家有没有见过这种写法,反正我第一次看到也有点懵.首先上面定义了一个<a href=""><strong>function* ()</strong></a>,切记generator并<a href=""><strong>不是函数</strong></a>,它返回的是一个<a href=""><strong>Iterator</strong></a>对象,这个我们下文会解释.这里有必要强调这一点,此外我们还看到<a href=""><strong>yield</strong></a>这个关键字,干什么用的呢,<a href=""><strong>next</strong></a>又是做什么,带着这些困惑我们先看看这段代码是如何运行的</p><ul><li><p>tell()表示创建一个generator对象后,进入”暂停”状态 </p></li><li><p>当调用到next(),会执行yield,返回后面的”a”,返回的value就是它的值,done则表示是否最后一个值,类型是布尔值</p></li><li>当第三次调用next,很明显是最后一个值了,所以返回true,第四次因为压根就找不到值所以返回了’undefined’</li></ul><h4 id="1-1generator传参"><a href="#1-1generator传参" class="headerlink" title="1.1generator传参"></a>1.1generator传参</h4><p>我们也可以在next的时候传递参数,如果看懂了下面的示例相信大家对generator已经有个深刻的理解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">function* paramGenerator() &#123;</div><div class="line">  console.log(yield+&quot;1&quot;);</div><div class="line">  console.log(yield+&quot;2&quot;);</div><div class="line">  console.log(yield+&quot;3&quot;);</div><div class="line">&#125;</div><div class="line">let log = paramGenerator()</div><div class="line">log.next()</div><div class="line">log.next(&quot;a&quot;)</div><div class="line">log.next(&quot;b&quot;)</div><div class="line">log.next(&quot;c&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>恩,给大家10秒钟的时间想想会输出什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">log.next()</div><div class="line">Object &#123;value: 1, done: false&#125;</div><div class="line">log.next(&quot;a&quot;)</div><div class="line"> a</div><div class="line">Object &#123;value: 2, done: false&#125;</div><div class="line">log.next(&quot;b&quot;)</div><div class="line"> b</div><div class="line">Object &#123;value: 3, done: false&#125;</div><div class="line">log.next(&quot;c&quot;)</div><div class="line"> c</div><div class="line">Object &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure><blockquote><p>恭喜你答对了,ok,我们来说说为什么会这样输出</p></blockquote><p>首先,当执行第一个next的时候,generator第一个yield被激活,返回了{value: 1, done: false},紧接立刻进入”暂停”状态,第二个next我们传入了字符串a,执行了第一个console.log语句输出了a,接着yield被激活返回{value: 2, done: false},这一点相信大家都没有疑问,接着它又进入”暂停”状态,同理,第三个next我们继续传入参数”b”,执行第二个console语句输出了b,接着yield被激活返回{value: 3, done: false}.当我们执行第四个语句时,首先执行了第三个console输出了c,这时候value已经没有值所以返回”undefined”,done则表示已经是最后一个值所以返回true.</p><h4 id="1-2-generator与Iterator关系"><a href="#1-2-generator与Iterator关系" class="headerlink" title="1.2 generator与Iterator关系"></a>1.2 generator与Iterator关系</h4><p>前面提到了generator返回是一个Iterator对象,而iterator拥有next的方法,所以我们才可以调用.说到了Iterator,这里要提到<a href=""><strong>Symbol.iterator</strong></a>这个es6的数据类型,迭代协议规定了一些内置类型具有默认迭代行为,而其他类型（如Object）不具有(这个其实很好理解,object就是让我们去往它那填充数据,它肯定不知道我们要填充什么类型数据啦~),带有@@iterator方法的内置类型有：</p><ul><li>Array.prototype<a href="">@@iterator</a></li><li>TypedArray.prototype<a href="">@@iterator</a></li><li>String.prototype<a href="">@@iterator</a></li><li>Map.prototype<a href="">@@iterator</a></li><li>Set.prototype<a href="">@@iterator</a></li></ul><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E7%BB%84%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-19%2017.51.18.png" alt="stack"></p><p>说那么多不如举个🌰,see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let arr=[&apos;hello&apos;,&apos;iterator&apos;];</div><div class="line">  let map=arr[Symbol.iterator]();</div><div class="line">  console.log(map.next());  //&#123;value: &quot;hello&quot;, done: false&#125;</div><div class="line">  console.log(map.next());  //&#123;value: &quot;iterator&quot;, done: false&#125;</div><div class="line">  console.log(map.next());  //&#123;value: undefined, done: true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>怎么,看到它的输出是不是觉得很熟悉,没错前面我们generator调用next就是这种格式,同时也印证了generator返回是一个Iterator对象.<br><a href=""><strong>arr[Symbol.iterator]</strong></a>这个写法表示了这个arr对象具备了迭代的能力,那后面的括号是什么意思,表示arr数组调用iterator这个接口,这个接口已经内部实现好了.那么,我们可不可自定义iterator接口呢.恩可以的,同样举个🌰 see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let obj=&#123;</div><div class="line">    start:[1,3,2],</div><div class="line">    end:[7,9,8],</div><div class="line">    [Symbol.iterator]()&#123;</div><div class="line">      let self=this;</div><div class="line">      let index=0;</div><div class="line">      let arr=self.start.concat(self.end);</div><div class="line">      let len=arr.length;</div><div class="line">      return &#123;</div><div class="line">        next()&#123;</div><div class="line">          if(index&lt;len)&#123;</div><div class="line">            return &#123;</div><div class="line">              value:arr[index++],</div><div class="line">              done:false</div><div class="line">            &#125;</div><div class="line">          &#125;else&#123;</div><div class="line">            return &#123;</div><div class="line">              value:arr[index++],</div><div class="line">              done:true</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  for(let key of obj)&#123;</div><div class="line">    console.log(key);  //1,3,2,7,9,8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不知道大家有没有想过,for…of能不能遍历对象呢?答案是不能的,如果你强行要这么做,会报一个<a href=""><strong>obj[Symbol.iterator] is not a function</strong></a>的错误.代码看一下应该就懂我就不再过多解释了哈哈</p><h3 id="2-如何用generator特性实现异步请求"><a href="#2-如何用generator特性实现异步请求" class="headerlink" title="2.如何用generator特性实现异步请求"></a>2.如何用generator特性实现异步请求</h3><blockquote><p>我们先回顾下传统实现异步操作的方式,一般我们会想到<a href=""><strong>回调</strong></a>和<a href=""><strong>事件触发</strong></a>这两种形式.这里我们主要谈论回调函数,事件触发其实就是采用事件驱动模式,通过一个事件触发另一个事件.</p></blockquote><h4 id="2-1传统Ajax实现异步操作"><a href="#2-1传统Ajax实现异步操作" class="headerlink" title="2.1传统Ajax实现异步操作"></a>2.1传统Ajax实现异步操作</h4><ul><li>业务场景: 执行完a后执行b</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let ajax=function(callback)&#123;</div><div class="line">   console.log(&apos;执行a&apos;);</div><div class="line">   setTimeout(function () &#123;</div><div class="line">     callback&amp;&amp;callback.call()</div><div class="line">   &#125;, 1000);</div><div class="line"> &#125;;</div><div class="line"> ajax(function()&#123;</div><div class="line">   console.log(&apos;执行b&apos;);</div><div class="line"> &#125;)</div></pre></td></tr></table></figure><blockquote><p>代码比较简单,但试想如果执行b后还有c,d,e呢?那代码将会很复杂并且难以维护.为了解决这个问题,所以<a href=""><strong>Promise</strong></a>诞生了.</p></blockquote><h4 id="2-2Promise实现异步操作"><a href="#2-2Promise实现异步操作" class="headerlink" title="2.2Promise实现异步操作"></a>2.2Promise实现异步操作</h4><ul><li>直接上代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function()&#123;</div><div class="line">    console.log(&apos;执行a&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000);</div><div class="line">    &#125;)</div><div class="line">  &#125;;</div><div class="line">  ajax().then(function()&#123;</div><div class="line">    console.log(&apos;promise&apos;,&apos;执行b&apos;);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>promise里面的匿名函数有两个参数<a href=""><strong>resolve</strong></a>和<a href=""><strong>reject</strong></a>,resolve表示表示执行下一步操作,reject当然就是中断操作~;</li><li>ajax().then…. 意思是当执行成功后会调用Promise实例的<a href=""><strong>then</strong></a>方法</li></ol><ul><li>如果后面也需要执行c,d,e…呢,代码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function()&#123;</div><div class="line">    console.log(&apos;执行a&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000);</div><div class="line">    &#125;)</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  ajax()</div><div class="line">    .then(function()&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">       console.log(&apos;执行b&apos;)</div><div class="line">        resolve()</div><div class="line">      &#125;, 2000);</div><div class="line">    &#125;);</div><div class="line">  &#125;)</div><div class="line">    .then(function()&#123;</div><div class="line">    console.log(&apos;执行c&apos;)</div><div class="line">    &#125;)</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>试想一下,如果执行到某一步抛异常了该怎么处理? 代码如下:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function(num)&#123;</div><div class="line">    console.log(&apos;执行&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      if(num&gt;5)&#123;</div><div class="line">        resolve()</div><div class="line">      &#125;else&#123;</div><div class="line">        throw new Error(&apos;出错了&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ajax(6).then(function()&#123;</div><div class="line">    console.log(&apos;log&apos;,6);</div><div class="line">  &#125;).catch(function(err)&#123;</div><div class="line">    console.log(&apos;catch&apos;,err);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  ajax(3).then(function()&#123;</div><div class="line">    console.log(&apos;log&apos;,3);</div><div class="line">  &#125;).catch(function(err)&#123;</div><div class="line">    console.log(&apos;catch&apos;,err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Promise还有个更高级的用法<a href=""><strong>Promise.all()</strong></a>,它返回也是一个promise实例,它会把多个promise实例当成一个实例,等待所有promise实例都加载执行完后才执行一个新的Promise对象,所以它就可以调用then方法.业务场景:<a href=""><strong>加载网络图片</strong></a>.代码就不贴了毕竟不是这篇文章的主要讨论内容.</p></blockquote><h4 id="2-3-generator特性实现异步请求"><a href="#2-3-generator特性实现异步请求" class="headerlink" title="2.3 generator特性实现异步请求"></a>2.3 generator特性实现异步请求</h4><p>generator让人第一感觉就是用同步的写法做异步处理为行为,我们将前面说的方式用generator改写对比看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">co(function* () &#123;</div><div class="line">const c1 = yield ajax(5)</div><div class="line">const c2 = yield ajax(6)</div><div class="line">const c3 = yield ajax(3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里得我们用到了co库,它能做到自驱动流程,省去每次都得手动调用next,这一点下文会详细讲到co库</p><h3 id="3-generator结合co库实现实现异步请求-自动流程"><a href="#3-generator结合co库实现实现异步请求-自动流程" class="headerlink" title="3.generator结合co库实现实现异步请求,自动流程"></a>3.generator结合co库实现实现异步请求,自动流程</h3><p>co库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行,我们将上面的代码稍微改一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">const co = require(&apos;co&apos;)</div><div class="line"></div><div class="line">let c = function* () &#123;</div><div class="line">const c1 = yield ajax(5)</div><div class="line">const c2 = yield ajax(6)</div><div class="line">const c3 = yield ajax(3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const cc = co(c)</div><div class="line"></div><div class="line">cc.then(data=&gt;&#123;</div><div class="line">....</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>co库返回的是一个Promise对象,所以then的操作大家一看就知道怎么回事了,那么co库究竟做了什么操作呢? see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function run(generator) &#123;</div><div class="line">    const g = generator()</div><div class="line">    function next(err, data) &#123;</div><div class="line">        const result = g.next(data)  </div><div class="line">          if (result.done) &#123;</div><div class="line">             return</div><div class="line">        &#125;</div><div class="line">        result.value(next)  </div><div class="line">      &#125;</div><div class="line">    next()</div><div class="line">&#125;</div><div class="line">//thunkify是一个开源库,其实就是一个经过封装处理的thunk函数</div><div class="line">const readFileThunk = thunkify(fs.readFile)</div><div class="line">const gen = function* () &#123;</div><div class="line">    const r1 = yield readFileThunk(&apos;data1.json&apos;)</div><div class="line">    console.log(r1.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 启动执行</div><div class="line">run(gen)</div></pre></td></tr></table></figure><p>看到这段代码理解起来有点难度,next(err, data)是什么意思?g.next(data)又是什么,头都大了.我们来拆分之后你就懂了.首先我们要引进thunk这个函数,它的作用在于将执行参数与回调参数分为两个函数去调用,举个读取文件的🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;data.json&apos;, &apos;utf-8&apos;, (err, data) =&gt; &#123;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>用thunk函数改写后,see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let thunk = (file,meta)=&gt;&#123;</div><div class="line">return function (callback) &#123;</div><div class="line">        fs.readFile(fileName, meta, callback)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const fileRead = thunk(&apos;data.json&apos;,&apos;utf-8&apos;)</div><div class="line">fileRead((err,data)=&gt;&#123;</div><div class="line">...</div><div class="line">)&#125;</div></pre></td></tr></table></figure><p>ok,结合上面代码完整代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let thunk = (file,meta)=&gt;&#123;</div><div class="line">return function (callback) &#123;</div><div class="line">        fs.readFile(fileName, meta, callback)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function run(generator) &#123;</div><div class="line">    const g = generator()</div><div class="line">    function next(err, data) &#123;</div><div class="line">        const result = g.next(data)  </div><div class="line">          if (result.done) &#123;</div><div class="line">             return</div><div class="line">        &#125;</div><div class="line">        result.value(next)  </div><div class="line">      &#125;</div><div class="line">    next()</div><div class="line">&#125;</div><div class="line"></div><div class="line">const gen = function* () &#123;</div><div class="line">    const r1 = yield thunk(&apos;data.json&apos;,&apos;utf-8&apos;)</div><div class="line">    console.log(r1.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 启动执行</div><div class="line">run(gen)</div></pre></td></tr></table></figure><blockquote><p>g.next返回的是一个thunk函数,从代码可以清楚看到,result.value 返回也是thunk函数,传入的next就是它的回调函数</p></blockquote><h3 id="4-generator其他应用"><a href="#4-generator其他应用" class="headerlink" title="4.generator其他应用"></a>4.generator其他应用</h3><h4 id="4-1-抽奖"><a href="#4-1-抽奖" class="headerlink" title="4.1 抽奖"></a>4.1 抽奖</h4><p>举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let draw = function(count)&#123;</div><div class="line">    //具体抽奖逻辑</div><div class="line">    console.info(`剩余$&#123;count&#125;次`)</div><div class="line">  &#125;</div><div class="line">  let residue = function* ()&#123;</div><div class="line">      while(count&gt;0)&#123;</div><div class="line">        count --;</div><div class="line">        yield draw(count);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  let star = residue(3);</div><div class="line">  let btn = document.createElement(&apos;button&apos;);</div><div class="line">  btn.id = &quot;start&quot;;</div><div class="line">  btn.textContent = &quot;抽奖&quot;;</div><div class="line">  doucment.body.appendChild(btn);</div><div class="line">  document.getElementById(&apos;start&apos;).addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">    start.next();</div><div class="line">  &#125;,false)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从代码可以看到我们并没有创建count作为全局变量,为什么这么处理大家不妨想想,我们在draw这个函数就只是单单抽奖的逻辑,抽奖次数我们直接在初始化generator的时候给它传参,代码看起来非常干净(可耻的炫耀一下)</p><h4 id="4-2-长轮洵"><a href="#4-2-长轮洵" class="headerlink" title="4.2 长轮洵"></a>4.2 长轮洵</h4><p>当服务端某个数据定期会发生变化,前端需要做的工作就是会在它发生变化的时候实时取得数据并展现出来,同样举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"></div><div class="line">  let ajax = function* ()&#123;</div><div class="line">    yield new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function() &#123;</div><div class="line">        resolve(&#123;code:0&#125;)</div><div class="line">      &#125;, 200);</div><div class="line">      </div><div class="line">    &#125;)</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">  let fetch = function()&#123;</div><div class="line">    let g = ajax();</div><div class="line">    let step = g.next();</div><div class="line">    step.value.then((d)=&gt;&#123;</div><div class="line">      if(d.code != 0)&#123;</div><div class="line">          setTimeout(function() &#123;</div><div class="line">            console.log(&apos;wait&apos;)</div><div class="line">            fetch()</div><div class="line">          &#125;, 1000);</div><div class="line">      &#125;else &#123;</div><div class="line">        console.log(d);  //&#123;code:0&#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们将generator和promise进行结合实现异步处理,g.next()会对generator进行一次迭代向服务端查询,step.value取得promise实例,通过then函数对拿到的数据做处理就行了</p><p>–</p><blockquote><p>后话:generator和co结合应用在了koa1,koa2则是用了es7 的提案<a href=""><strong>async/await</strong></a>来做异步开发,由于koa2正安排进我的学习计划中,那就等后面学到哪更到哪吧,第一篇koa2的文章已经更新了<a href="http://lynhao.cn/2017/07/13/进击Koa2系列-一/" target="_blank" rel="external"><strong>戳这里</strong></a>,敬请留意后续更新~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;es6 中引入了Generator Function（生成器函数）这个新特性,这篇文章会从以下4个点介绍,文章篇幅会有点长,请备好电源🤖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解generator✅&lt;/li&gt;
&lt;li&gt;如何用generator特性实现异步请求✅&lt;/li&gt;
&lt;li&gt;generator结合co库实现实现异步请求,自动流程✅&lt;/li&gt;
&lt;li&gt;generator其他应用✅&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>进击Koa2系列[一]</title>
    <link href="http://yoursite.com/2017/07/13/%E8%BF%9B%E5%87%BBKoa2%E7%B3%BB%E5%88%97-%E4%B8%80/"/>
    <id>http://yoursite.com/2017/07/13/进击Koa2系列-一/</id>
    <published>2017-07-13T02:41:52.000Z</published>
    <updated>2018-06-01T01:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="忏悔"><a href="#忏悔" class="headerlink" title="忏悔"></a>忏悔</h3><p>之所以起这个名字,原因是因为没好好坚持学node,14年node还是0.0.x版本我就开始用了,不过没坚持下来,现在node生态发展迅猛已经迭代到7.x版本了,框架已经从Express迭代到koa再到如今的koa2,额,好吧,又是一门全新的知识体系,只好硬着头皮学咯.这个系列将会把我学习的整个过程记录下来,敬请关注</p><h3 id="koa2环境搭建"><a href="#koa2环境搭建" class="headerlink" title="koa2环境搭建"></a>koa2环境搭建</h3><ul><li><p>操作系统: 不限</p></li><li><p>编译环境: nodejs      </p></li></ul><blockquote><p>因为koa2团队是基于es7这个未来标准开发的,所以推荐使用7.6版本以上,可以省去很多麻烦.</p></blockquote><h3 id="搭建第一个项目"><a href="#搭建第一个项目" class="headerlink" title="搭建第一个项目"></a>搭建第一个项目</h3><p>这里我们用<a href=""><strong>Hello World</strong></a>做演示</p><h5 id="安装koa2"><a href="#安装koa2" class="headerlink" title="安装koa2"></a>安装koa2</h5><h6 id="创建目录-初始化"><a href="#创建目录-初始化" class="headerlink" title="创建目录,初始化"></a>创建目录,初始化</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir Koa2</div><div class="line">npm init</div></pre></td></tr></table></figure><h6 id="安装koa2-1"><a href="#安装koa2-1" class="headerlink" title="安装koa2"></a>安装koa2</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install koa</div></pre></td></tr></table></figure><h6 id="创建index-js-编写代码"><a href="#创建index-js-编写代码" class="headerlink" title="创建index.js 编写代码"></a>创建index.js 编写代码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch index.js</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const app = new Koa()</div><div class="line"></div><div class="line">app.use( async ( ctx ) =&gt; &#123;</div><div class="line">  ctx.body = &apos;hello koa2&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(3000)</div><div class="line">console.log(&apos;[demo] start-quick is starting at port 3000&apos;)</div></pre></td></tr></table></figure><h6 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node index.js</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2011.08.06.png" alt="代码片段"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;忏悔&quot;&gt;&lt;a href=&quot;#忏悔&quot; class=&quot;headerlink&quot; title=&quot;忏悔&quot;&gt;&lt;/a&gt;忏悔&lt;/h3&gt;&lt;p&gt;之所以起这个名字,原因是因为没好好坚持学node,14年node还是0.0.x版本我就开始用了,不过没坚持下来,现在node生态发展迅猛已经
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="koa2" scheme="http://yoursite.com/tags/koa2/"/>
    
  </entry>
  
  <entry>
    <title>JS实现功能算法--持续更新👀</title>
    <link href="http://yoursite.com/2017/07/05/JS%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%AE%97%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%F0%9F%91%80/"/>
    <id>http://yoursite.com/2017/07/05/JS实现功能算法-持续更新👀/</id>
    <published>2017-07-05T02:52:11.000Z</published>
    <updated>2018-06-01T01:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将会记录一些日常开发用到的算法知识实现特定的业务需求,持续不定期更新,谢谢支持☺️</p></blockquote><a id="more"></a><h3 id="优化递归"><a href="#优化递归" class="headerlink" title="优化递归"></a>优化递归</h3><blockquote><p>一般代码,空间复杂度O(n)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">  console.trace()</div><div class="line">  if(n === 0) &#123;</div><div class="line">    return 1</div><div class="line">  &#125;</div><div class="line">  return n * factorial(n-1)</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>优化后代码(尾递归),避免执行栈过多溢出,空间复杂度O(1)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line">function factorial(n, total=1) &#123;</div><div class="line">  if(n === 1) &#123;</div><div class="line">    return total</div><div class="line">  &#125;</div><div class="line">  return factorial(n-1, n * total)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2018年05月31日10:28:41</strong></a></li></ul><h3 id="实现组合排列算法"><a href="#实现组合排列算法" class="headerlink" title="实现组合排列算法"></a>实现组合排列算法</h3><blockquote><p>我这里的业务场景是在计算彩票的多重组合结果,可直接运行调试,示例代码如下</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static combine(arr,size)&#123;</div><div class="line">   <span class="built_in">let</span> allResult = [];</div><div class="line">   (<span class="keyword">function</span> f(arr,size,result)&#123;</div><div class="line">     <span class="built_in">let</span> arrLen = arr.length;</div><div class="line">     <span class="keyword">if</span>(size&gt;arrLen)&#123;</div><div class="line">       <span class="built_in">return</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(size === arrLen)&#123;</div><div class="line">       allResult.push([].concat(result,arr))</div><div class="line">     </div><div class="line">     &#125;<span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span>(<span class="built_in">let</span> i=0;i&lt;arrLen;i++)&#123;</div><div class="line">         <span class="built_in">let</span> newResult = [].concat(result);</div><div class="line">         newResult.push(arr[i]);</div><div class="line">         <span class="keyword">if</span>(size === 1)&#123;</div><div class="line">           allResult.push(newResult)</div><div class="line">         &#125;<span class="keyword">else</span> &#123;</div><div class="line">           <span class="built_in">let</span> newArr = [].concat(arr);</div><div class="line">           newArr.splice(0,i+1);</div><div class="line">           f(newArr,size-1,newResult)</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;)(arr,size,[])</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2017年07月05日10:58:11</strong></a></li></ul><hr><p>持续更新中,敬请期待…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章将会记录一些日常开发用到的算法知识实现特定的业务需求,持续不定期更新,谢谢支持☺️&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue之疑惑(持续更新...)</title>
    <link href="http://yoursite.com/2017/04/26/Vue%E4%B9%8B%E7%96%91%E6%83%91-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2017/04/26/Vue之疑惑-持续更新/</id>
    <published>2017-04-26T15:20:27.000Z</published>
    <updated>2018-06-01T01:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将会记录一些我在日常开发中遇到的各种奇葩问题,在此记录,供大家借鉴减少不必要的时间浪费,此文将会持续commit,敬请关注</p></blockquote><a id="more"></a><h2 id="疑惑一-bitbar-webpack-progress-plugin"><a href="#疑惑一-bitbar-webpack-progress-plugin" class="headerlink" title="疑惑一(bitbar-webpack-progress-plugin)"></a>疑惑一(bitbar-webpack-progress-plugin)</h2><p>随着项目的壮大,各种依赖插件也随之多了起来,最近遇到这么一个问题,在install一个<a href=""><strong>bitbar-webpack-progress-plugin</strong></a>这个插件后运行项目,控制台报错,我纳闷查了一下,觉得可能是es6搞得鬼,随在index.js文件加了<a href=""><strong>“use strict”</strong></a>,写js的朋友一定不陌生我就不再过多解释,下面是一些相关截图<br><img src="http://picturegit-1251927503.file.myqcloud.com/list.png" alt="stack"></p><p><img src="http://picturegit-1251927503.file.myqcloud.com/error1.png" alt="stack"></p><blockquote><p>解决方案:  如上所述</p></blockquote><ul><li>date <a href=""><strong>2017-04-26 23:34:42</strong></a></li></ul><h2 id="疑惑二-事件绑定触发"><a href="#疑惑二-事件绑定触发" class="headerlink" title="疑惑二 事件绑定触发"></a>疑惑二 事件绑定触发</h2><p>今天在项目中碰到一个问题,在进行单页面跳转时出现了不符合预期的行为:单页面跳转后hash值变成空<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;a href=<span class="string">"#"</span> @click=<span class="string">"sbSubmit"</span> class=<span class="string">"button button-big button-fill button-blue"</span>&gt;下一步&lt;/a&gt;</div><div class="line"></div><div class="line">sbCheck:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">...</div><div class="line"><span class="keyword">if</span>(result)&#123;</div><div class="line">       //检验成功确认页面</div><div class="line">     this.<span class="variable">$refs</span>.fb.toPage(<span class="string">'fjssb_confirm'</span>)</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>进过检查是因为默认事件绑定的原因,触发了路由.原生中我是是这样处理的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">on: &#123;</div><div class="line">  keyup: <span class="keyword">function</span> (event) &#123;</div><div class="line">    // 如果触发事件的元素不是事件绑定的元素</div><div class="line">    // 则返回</div><div class="line">    <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="built_in">return</span></div><div class="line">    // 如果按下去的不是enter键或者</div><div class="line">    // 没有同时按下<span class="built_in">shift</span>键</div><div class="line">    // 则返回</div><div class="line">    <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== 13) <span class="built_in">return</span></div><div class="line">    // 阻止 事件冒泡</div><div class="line">    event.stopPropagation()</div><div class="line">    // 阻止该元素默认的keyup事件</div><div class="line">    event.preventDefault()</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>刚好,vue中提供了修饰符来解决这种情景</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/vueModifier.png" alt="stack"></p><blockquote><p>解决方案:</p></blockquote><p>加上<a href=""><strong>prevent</strong></a>修饰符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@click.prevent=<span class="string">"sbSubmit"</span></div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2017-04-28 17:22:57</strong></a></li></ul><h2 id="疑惑三-错误在vm-el挂载之前渲染页面"><a href="#疑惑三-错误在vm-el挂载之前渲染页面" class="headerlink" title="疑惑三 错误在vm.$el挂载之前渲染页面"></a>疑惑三 错误在vm.$el挂载之前渲染页面</h2><blockquote><p>写之前有个小插曲,刚刚在启动hexo时,碰到了node依赖版本出错问题,顺藤摸瓜,大脑第一反应是node版本的问题,随通过命名行查看,原来上星期为了测试vue2.3新特性把版本切换到了7.x版本,换回5.x后运行,deal~</p></blockquote><p><img src="http://picturegit-1251927503.file.myqcloud.com/node-n.png" alt="stack"></p><p>好了,回归正题,就标题所示,就我平时对生命周期谨慎的态度,没想到刚刚就栽了跟头.需求是这样的,我需要从后台发送请求,再从返回的数据渲染页面,之后通过form表单的action跳转到对应的支付界面.代码是这样处理的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">html</div><div class="line">  &lt;div class=<span class="string">"content"</span>&gt;</div><div class="line">      &lt;div class=<span class="string">"content-block"</span>&gt;</div><div class="line">        &lt;div id=<span class="string">"payForm"</span>&gt;&#123;&#123;data2&#125;&#125;&lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">js</div><div class="line"> ...</div><div class="line"> <span class="built_in">let</span> a = document.getElementById(<span class="string">"payForm"</span>).innerHTML = this.data2</div><div class="line"> document.all.pay_form.submit()</div></pre></td></tr></table></figure><p>我在methods定义了一个load方法,按照平时的做法直接在created出调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">created</span></span>()&#123;</div><div class="line"> ...</div><div class="line"> this.load()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后控制台直接给我抛出来了<a href=""><strong>Cannot set property ‘innerHTML’ of null</strong></a>.分析了一会就明白了,出现这种状况是因为在浏览器在解析js到<a href=""><strong>id=”payForm”</strong></a>,而此时页面可能还没渲染出来,所以就报错.其实在vue2.0生命周期已经详细说明了,在执行created时el实例其实还没被挂载.所以正确的处理方式应该是在mounted钩子行数中去处理,它会确保el实例已经被挂载,当然还有一个坑,官网也说到了,代码如下处理</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/mounted.png" alt="stack"></p><p>Vue 2.x生命周期</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/vuelife.png" alt="stack"></p><blockquote><p>解决方案:  如上所述</p></blockquote><ul><li>date <a href=""><strong>2017-05-09 15:17:54</strong></a></li></ul><h3 id="疑惑四-解决file-input-第二次选择同一张图片后无法触发change事件"><a href="#疑惑四-解决file-input-第二次选择同一张图片后无法触发change事件" class="headerlink" title="疑惑四 解决file input 第二次选择同一张图片后无法触发change事件"></a>疑惑四 解决file input 第二次选择同一张图片后无法触发change事件</h3><blockquote><p>这一块并不局限vue框架属于前端的东西,因为项目碰到遂记录在此处</p></blockquote><ol><li>解决方案1: 在你的input所属的form表单reset(),以jq操作dom为示例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;#avatorForm&quot;)[0].reset();</div></pre></td></tr></table></figure><ol><li>解决方案2: 设置你的input file value值为空,以jq操作dom为示例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.inputImage&apos;).val(&apos;&apos;);</div></pre></td></tr></table></figure><ul><li>date: <a href=""><strong>2017年07月05日10:42:58</strong></a></li></ul><h2 id="疑惑五-import路径"><a href="#疑惑五-import路径" class="headerlink" title="疑惑五 import路径"></a>疑惑五 import路径</h2><p>不知道大家第一次搭脚手架后看index.js这个文件有没有这个疑问,为什么import路径是<a href=""><strong>@/components/Hello</strong></a>就可以找到hello.vue</p><p>打开webpack.base.conf.js文件解惑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">   extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</div><div class="line">   alias: &#123;</div><div class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</div><div class="line">   &#125;</div><div class="line"> &#125;,</div></pre></td></tr></table></figure><p>@的意思是run的时候会通过@找到src根目录下的文件, resolve是一个执行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function resolve (dir) &#123;</div><div class="line">  return path.join(__dirname, &apos;..&apos;, dir)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>动手实践,把<a href=""><strong>@</strong></a>改为任意字符,之后再index.js的import语句对应修改,其实最终的地址是<a href=""><strong>src/components/Hello</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import Router from &apos;vue-router&apos;</div><div class="line">import Hello from &apos;任意字符/components/Hello&apos;</div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2017年07月30日23:14:49</strong></a></li></ul><h2 id="疑惑六-八进制在strict-mode-报错"><a href="#疑惑六-八进制在strict-mode-报错" class="headerlink" title="疑惑六  八进制在strict mode 报错"></a>疑惑六  八进制在strict mode 报错</h2><p>这个问题不局限于vue,它是js的问题,因为在做项目碰到这个坑, 遂记此</p><p>今天下午大概三点吧,控制台抛出下面的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Octal literals are not allowed <span class="keyword">in</span> strict mode.</div><div class="line">    at exports.runInThisContext (vm.js:69:16)</div><div class="line">    at Module._compile (module.js:432:25)</div><div class="line">    at Object.Module._extensions..js (module.js:467:10)</div><div class="line">    at Module.load (module.js:349:32)</div><div class="line">    at Function.Module._load (module.js:305:12)</div><div class="line">    at Module.require (module.js:357:17)</div><div class="line">    at require (module.js:373:17)</div></pre></td></tr></table></figure><p>因为业务涉及使用到了<a href=""><strong>公式引擎</strong></a>,所以有一阵子我一直埋头在代码和源码中试图找出破绽(尽管引擎确实有不足之处),知道下班还是没能解决</p><p>现在是晚上10点左右,问题得到了解决,是八进制转换问题,因为我的变量有一个值是<a href=""><strong>05</strong></a>,之后我去掉首部0之后错误就消失,至于为什么strict模式下不支持八进制,知道的朋友麻烦下方留言告知哈~</p><ul><li>date: <a href=""><strong>2017年08月08日22:46:21</strong></a></li></ul><hr><p>持续更新中,敬请期待…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章将会记录一些我在日常开发中遇到的各种奇葩问题,在此记录,供大家借鉴减少不必要的时间浪费,此文将会持续commit,敬请关注&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>MacOsx配置Oracle驱动jar一些坑</title>
    <link href="http://yoursite.com/2017/04/20/MacOsx%E9%85%8D%E7%BD%AEOracle%E9%A9%B1%E5%8A%A8jar%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2017/04/20/MacOsx配置Oracle驱动jar一些坑/</id>
    <published>2017-04-20T08:45:02.000Z</published>
    <updated>2018-06-01T01:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="今天在部署后端项目时遇到一个坑-在svn上checkout代码之后提示少了oracle6的jar包-google了一下看到有人说中央库没有提供jar包-因为ojdbc-jar是收费的-查了一下有点出入-只查到12-1-0-2-0这个版本所以无从考证-所以我打算跟以往引进jar包的方式手动加入"><a href="#今天在部署后端项目时遇到一个坑-在svn上checkout代码之后提示少了oracle6的jar包-google了一下看到有人说中央库没有提供jar包-因为ojdbc-jar是收费的-查了一下有点出入-只查到12-1-0-2-0这个版本所以无从考证-所以我打算跟以往引进jar包的方式手动加入" class="headerlink" title="今天在部署后端项目时遇到一个坑,在svn上checkout代码之后提示少了oracle6的jar包,google了一下看到有人说中央库没有提供jar包,因为ojdbc.jar是收费的,查了一下有点出入,只查到12.1.0.2.0这个版本所以无从考证,所以我打算跟以往引进jar包的方式手动加入"></a>今天在部署后端项目时遇到一个坑,在svn上checkout代码之后提示少了oracle6的jar包,google了一下看到有人说中央库没有提供jar包,因为ojdbc.jar是收费的,查了一下有点出入,只查到12.1.0.2.0这个版本所以无从考证,所以我打算跟以往引进jar包的方式手动加入</h5><a id="more"></a><p><img src="http://picturegit-1251927503.file.myqcloud.com/maven.png" alt="stack"></p><p>在终端(wins用cmd)输入如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mvn install:install-file -Dfile=你的存放ojdbc6.jar文件的位置 -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=版本号 -Dpackaging=jar -DgeneratePom=<span class="literal">true</span></div></pre></td></tr></table></figure></p><blockquote><p>sudo 是mac上一个root命令,wins用户直接忽略</p></blockquote><h5 id="如果终端出现BUILD-SUCCESS这个字眼-说明被成功的安装进来-不过我看到它被重定向到一个E-文件-我有点好奇打开-发现安装的ojdbc6-jar被编译到了这个目录下-而我的本地仓库却没变"><a href="#如果终端出现BUILD-SUCCESS这个字眼-说明被成功的安装进来-不过我看到它被重定向到一个E-文件-我有点好奇打开-发现安装的ojdbc6-jar被编译到了这个目录下-而我的本地仓库却没变" class="headerlink" title="如果终端出现BUILD SUCCESS这个字眼,说明被成功的安装进来,不过我看到它被重定向到一个E:\文件,我有点好奇打开,发现安装的ojdbc6.jar被编译到了这个目录下,而我的本地仓库却没变"></a>如果终端出现<a href=""><strong>BUILD SUCCESS</strong></a>这个字眼,说明被成功的安装进来,不过我看到它被重定向到一个E:\文件,我有点好奇打开,发现安装的ojdbc6.jar被编译到了这个目录下,而我的本地仓库却没变</h5><p><img src="http://picturegit-1251927503.file.myqcloud.com/code.png" alt="stack"></p><h5 id="结果跟我预感一样-pom中报了这么一个错误Missing-artifact-com-oracle-ojdbc6-jar-11-2-0-之后才发现ojdbc6-jar的导入方式跟其他有所不同-我们需要准备ojdbc-jar这个jar包-官网下载地址如下"><a href="#结果跟我预感一样-pom中报了这么一个错误Missing-artifact-com-oracle-ojdbc6-jar-11-2-0-之后才发现ojdbc6-jar的导入方式跟其他有所不同-我们需要准备ojdbc-jar这个jar包-官网下载地址如下" class="headerlink" title="结果跟我预感一样,pom中报了这么一个错误Missing artifact com.oracle:ojdbc6:jar:11.2.0?? 之后才发现ojdbc6.jar的导入方式跟其他有所不同,我们需要准备ojdbc.jar这个jar包,官网下载地址如下:"></a>结果跟我预感一样,pom中报了这么一个错误<a href=""><strong>Missing artifact com.oracle:ojdbc6:jar:11.2.0??</strong></a> 之后才发现ojdbc6.jar的导入方式跟其他有所不同,我们需要准备ojdbc.jar这个jar包,官网下载地址如下:</h5><blockquote><p><a href="http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-112010-090769.html" target="_blank" rel="external">http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-112010-090769.html</a></p></blockquote><h5 id="照理说这回应该可以了-在我update之后结果还是跟上面一样的错误-郁闷"><a href="#照理说这回应该可以了-在我update之后结果还是跟上面一样的错误-郁闷" class="headerlink" title="照理说这回应该可以了,在我update之后结果还是跟上面一样的错误(郁闷)"></a>照理说这回应该可以了,在我update之后结果还是跟上面一样的错误(郁闷)</h5><h5 id="最后我采用了在线安装的方式-如下"><a href="#最后我采用了在线安装的方式-如下" class="headerlink" title="最后我采用了在线安装的方式,如下"></a>最后我采用了在线安装的方式,如下</h5><blockquote><p>Run As -&gt; Maven Build</p></blockquote><p><img src="http://picturegit-1251927503.file.myqcloud.com/install.png" alt="stack"></p><ul><li>这里不用跟前面一样加<a href=""><strong>mvn</strong></a>去解析</li></ul><h5 id="最后在pom-xml中加入几个配置"><a href="#最后在pom-xml中加入几个配置" class="headerlink" title="最后在pom.xml中加入几个配置"></a>最后在pom.xml中加入几个配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;com.oracle&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;11.2.0.1.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h3 id="Deal"><a href="#Deal" class="headerlink" title="Deal~"></a>Deal~</h3><hr><blockquote><p>至于为什么之前那种方式为什么会报错,我感觉应该是我本地maven的环境问题,了解的小伙伴请下面留言告知哈~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;今天在部署后端项目时遇到一个坑-在svn上checkout代码之后提示少了oracle6的jar包-google了一下看到有人说中央库没有提供jar包-因为ojdbc-jar是收费的-查了一下有点出入-只查到12-1-0-2-0这个版本所以无从考证-所以我打算跟以往引进jar包的方式手动加入&quot;&gt;&lt;a href=&quot;#今天在部署后端项目时遇到一个坑-在svn上checkout代码之后提示少了oracle6的jar包-google了一下看到有人说中央库没有提供jar包-因为ojdbc-jar是收费的-查了一下有点出入-只查到12-1-0-2-0这个版本所以无从考证-所以我打算跟以往引进jar包的方式手动加入&quot; class=&quot;headerlink&quot; title=&quot;今天在部署后端项目时遇到一个坑,在svn上checkout代码之后提示少了oracle6的jar包,google了一下看到有人说中央库没有提供jar包,因为ojdbc.jar是收费的,查了一下有点出入,只查到12.1.0.2.0这个版本所以无从考证,所以我打算跟以往引进jar包的方式手动加入&quot;&gt;&lt;/a&gt;今天在部署后端项目时遇到一个坑,在svn上checkout代码之后提示少了oracle6的jar包,google了一下看到有人说中央库没有提供jar包,因为ojdbc.jar是收费的,查了一下有点出入,只查到12.1.0.2.0这个版本所以无从考证,所以我打算跟以往引进jar包的方式手动加入&lt;/h5&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Js栈</title>
    <link href="http://yoursite.com/2017/03/01/%E6%B5%85%E8%B0%88Js%E6%A0%88/"/>
    <id>http://yoursite.com/2017/03/01/浅谈Js栈/</id>
    <published>2017-03-01T10:37:24.000Z</published>
    <updated>2018-06-01T01:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="栈和队列是我们常用数据结构-在数组中我们可以对任意位置进行操作-这就用到了栈-首先-栈是一种遵守LIFO原则的有序集合-即后进先出"><a href="#栈和队列是我们常用数据结构-在数组中我们可以对任意位置进行操作-这就用到了栈-首先-栈是一种遵守LIFO原则的有序集合-即后进先出" class="headerlink" title="栈和队列是我们常用数据结构,在数组中我们可以对任意位置进行操作,这就用到了栈.首先,栈是一种遵守LIFO原则的有序集合,即后进先出."></a>栈和队列是我们常用数据结构,在数组中我们可以对任意位置进行操作,这就用到了<a href=""><strong>栈</strong></a>.首先,栈是一种遵守<a href=""><strong>LIFO</strong></a>原则的有序集合,即后进先出.</h5><a id="more"></a><blockquote><p>找了这么一张图比较容易看懂</p></blockquote><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/stack.jpg?raw=true" alt="stack"></p><h3 id="创建栈"><a href="#创建栈" class="headerlink" title="创建栈"></a>创建栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">stack</span></span>()&#123;</div><div class="line">  //初始化一个全局变量用于保存栈中的元素</div><div class="line">  var temp = [];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="这里会用到下面几个方法"><a href="#这里会用到下面几个方法" class="headerlink" title="这里会用到下面几个方法"></a>这里会用到下面几个方法</h4><ul><li>push()</li><li>pop()</li><li>peak()</li><li>isEmpty()</li><li>clear()</li><li>size()</li><li>print()</li></ul><blockquote><p><a href=""><strong>peak</strong></a>是用于返回栈顶的元素,但不会移除<br><a href=""><strong>isEmpty</strong></a>是用于判断当前栈中是否有元素,没有的话返回true,否者false </p></blockquote><h4 id="分别实现上面的栈方法"><a href="#分别实现上面的栈方法" class="headerlink" title="分别实现上面的栈方法"></a>分别实现上面的栈方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Stack</span></span>()&#123;</div><div class="line">var temp = [];</div><div class="line"></div><div class="line">this.push = <span class="keyword">function</span>(element)&#123;</div><div class="line">temp.push(element);</div><div class="line">&#125;</div><div class="line">this.pop = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"><span class="built_in">return</span> temp.pop();</div><div class="line">&#125;</div><div class="line">this.peak = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"><span class="built_in">return</span> temp[temp.length-1];</div><div class="line">&#125;</div><div class="line">this.isEmpty = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"><span class="built_in">return</span> temp.length == 0;</div><div class="line">&#125;</div><div class="line">this.clear = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">temp = [];</div><div class="line">&#125;</div><div class="line">this.size = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"><span class="built_in">return</span> temp.length;</div><div class="line">&#125;</div><div class="line">this.print = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">console.log(temp.toString());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Ok-下面通过栈的处理来实现进制之间的转换"><a href="#Ok-下面通过栈的处理来实现进制之间的转换" class="headerlink" title="Ok,下面通过栈的处理来实现进制之间的转换"></a>Ok,下面通过栈的处理来实现进制之间的转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> divideBy2(decNum)&#123;</div><div class="line">var remStack = new Stack(); //实例一个stack对象</div><div class="line">var rem;   //余数</div><div class="line">var binaryString = <span class="string">''</span>; //转换后的二进制</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(decNum&gt;0)&#123;</div><div class="line">rem = Math.floor(decNum % 2);   //拿到余数</div><div class="line">remStack.push(rem);//进栈</div><div class="line">decNum = Math.floor(decNum / 2);</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(!remStack.isEmpty())&#123;</div><div class="line">binaryString += remStack.pop().toString;  //将拿到的二进制进栈</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> binaryString;</div></pre></td></tr></table></figure><h3 id="优化-让进制间自由转换"><a href="#优化-让进制间自由转换" class="headerlink" title="优化,让进制间自由转换"></a>优化,让进制间自由转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> baseConvertr(decNum, base)&#123;</div><div class="line">var remStack = new Stack(); //实例一个stack对象</div><div class="line">var rem;   //余数</div><div class="line">var baseString = <span class="string">''</span>; //转换后的base进制</div><div class="line">digits = <span class="string">'0123456789ABCDEF'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(decNum&gt;0)&#123;</div><div class="line">rem = Math.floor(decNum % 2);   //拿到余数</div><div class="line">remStack.push(rem);//进栈</div><div class="line">decNum = Math.floor(decNum / 2);</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(!remStack.isEmpty())&#123;</div><div class="line">baseString += digits[remStack.pop()];  //将拿到的base进制进栈</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span> baseString;</div></pre></td></tr></table></figure><blockquote><p><a href=""><strong>‘0123456789ABCDEF’</strong></a> 这样处理是因为余数从0-9,如果是10-&gt;16进制,需要加上ABCDEF分别对应10,11,12,13,14,15</p></blockquote><hr><p>ok,栈的内容就先写到这里,有问题下面留言~</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;栈和队列是我们常用数据结构-在数组中我们可以对任意位置进行操作-这就用到了栈-首先-栈是一种遵守LIFO原则的有序集合-即后进先出&quot;&gt;&lt;a href=&quot;#栈和队列是我们常用数据结构-在数组中我们可以对任意位置进行操作-这就用到了栈-首先-栈是一种遵守LIFO原则的有序集合-即后进先出&quot; class=&quot;headerlink&quot; title=&quot;栈和队列是我们常用数据结构,在数组中我们可以对任意位置进行操作,这就用到了栈.首先,栈是一种遵守LIFO原则的有序集合,即后进先出.&quot;&gt;&lt;/a&gt;栈和队列是我们常用数据结构,在数组中我们可以对任意位置进行操作,这就用到了&lt;a href=&quot;&quot;&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/a&gt;.首先,栈是一种遵守&lt;a href=&quot;&quot;&gt;&lt;strong&gt;LIFO&lt;/strong&gt;&lt;/a&gt;原则的有序集合,即后进先出.&lt;/h5&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp搭建AngularJs【下】</title>
    <link href="http://yoursite.com/2017/02/17/%E4%BD%BF%E7%94%A8gulp%E6%90%AD%E5%BB%BAangularjs%E3%80%90%E4%B8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2017/02/17/使用gulp搭建angularjs【下】/</id>
    <published>2017-02-17T09:14:37.000Z</published>
    <updated>2018-06-01T01:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解"><a href="#接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解" class="headerlink" title="接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解"></a>接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解</h4><a id="more"></a><ul><li><p><a href=""><strong>src(globs[, options])</strong></a></p><blockquote><p>这个方法用于读取文件</p></blockquote><ol><li>globs       类型：String 或 Array</li><li>options     类型：Object</li></ol></li><li><p><a href=""><strong>dest(path[, options])</strong></a></p><blockquote><p>这个方法很好理解,它经常与pipe()一起使用，通过.pipe()将其拷贝到指定目录下，如果某文件夹不存在，将会自动创建它</p></blockquote><ol><li>path        类型：String or Function</li><li>options     类型：Object</li></ol></li><li><p><a href=""><strong>task(name[, deps], fn)</strong></a></p><blockquote><p>这个方法用于开启一个任务</p></blockquote><ol><li>name       类型：String</li><li>deps         类型：Array</li><li>fn            类型: Function 回调函数</li></ol></li><li><p><a href=""><strong>watch(glob [, opts], tasks)</strong></a></p><blockquote><p>这个方法用于检测文件，当文件修改时返回一个change 事件</p></blockquote><ol><li>globs       类型：String 或 Array</li><li>opts         类型：Object</li><li>tasks        类型：Array</li></ol></li></ul><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><h5 id="在根目录下创建gulpfile-js文件"><a href="#在根目录下创建gulpfile-js文件" class="headerlink" title="在根目录下创建gulpfile.js文件"></a>在根目录下创建<a href=""><strong>gulpfile.js</strong></a>文件</h5><blockquote><p>引入之前安装的插件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var gulp = require(<span class="string">'gulp'</span>);</div><div class="line">var $ = require(<span class="string">'gulp-load-plugins'</span>)();</div><div class="line">var open = require(<span class="string">'open'</span>);</div></pre></td></tr></table></figure><blockquote><p>定义一个全局变量</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var app = &#123;</div><div class="line">srcPath: <span class="string">'src/'</span>,   //源码目录</div><div class="line">devPath: <span class="string">'build/'</span>,//开发环境目录，代码整合后会写到这里</div><div class="line">prdPath: <span class="string">'dist/'</span>//生产环境，代码压缩后会写到这里</div><div class="line"> &#125;;</div></pre></td></tr></table></figure><blockquote><p>定义任务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'lib'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line"> gulp.src(<span class="string">'www/**/*.js'</span>)    //**是指深度遍历，*是通配符</div><div class="line"> .pipe(gulp.dest(app.devPath + <span class="string">'vendor'</span>)) //通过流（pipe)将读取后的文件拷贝到开发环境中</div><div class="line"> .pipe(gulp.dest(app.prdPath + <span class="string">'vendor'</span>)) //将读取后的文件拷贝到生产环境中</div><div class="line"> .pipe($.connect.reload());</div><div class="line"> &#125;);</div></pre></td></tr></table></figure><h3 id="实现本地服务器"><a href="#实现本地服务器" class="headerlink" title="实现本地服务器"></a>实现本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'serve'</span>, [<span class="string">'build'</span>], <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$.connect.server(&#123;</div><div class="line">root: [app.devPath],    //默认从开发目录读取</div><div class="line">livereload: <span class="literal">true</span>,   //设置是否刷新浏览器</div><div class="line">port: 1234//端口</div><div class="line">&#125;);</div><div class="line">open(<span class="string">'http://localhost:1234'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>但这里还有一个问题，当我们修改文件后需要手动重新编译，这时候<a href=""><strong>watch</strong></a>就发挥作用了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.watch(<span class="string">'www/**/*'</span>, [<span class="string">'lib'</span>]);</div><div class="line">gulp.watch(app.srcPath + <span class="string">'/**/*.html'</span>, [<span class="string">'html'</span>]);</div><div class="line">gulp.watch(app.srcPath + <span class="string">'data/**/*.json'</span>, [<span class="string">'json'</span>]);</div><div class="line">gulp.watch(app.srcPath + <span class="string">'style/**/*.less'</span>, [<span class="string">'less'</span>]);</div><div class="line">gulp.watch(app.srcPath + <span class="string">'script/**/*.js'</span>, [<span class="string">'js'</span>]);</div><div class="line">gulp.watch(app.srcPath + <span class="string">'image/**/*'</span>, [<span class="string">'image'</span>]);</div></pre></td></tr></table></figure><p>这下子就达到自动构建的目的~但。。。是，好像还不够，浏览器不会自动刷新啊，这一点很不友好~</p><blockquote><p>我们这样处理–</p><ul><li>在每个task后面调用$.connect.reload()去通知浏览器自动刷新</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'lib'</span>,<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">gulp.src(<span class="string">'www/**/*.js'</span>)</div><div class="line">.pipe(gulp.dest(app.devPath + <span class="string">'vendor'</span>))</div><div class="line">.pipe(gulp.dest(app.prdPath + <span class="string">'vendor'</span>))</div><div class="line">.pipe($.connect.reload());</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>像reload和livereload 在低版本的ie浏览器就不支持了,但这年头谁还用ie啊 [/调皮脸]</p></blockquote><p>当然，如果你觉得每次都得输入<a href=""><strong>gulp.serve</strong></a>太麻烦想偷个懒，我们可以这样设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'serve'</span>]);</div></pre></td></tr></table></figure><p>现在直接在terminal输入<a href=""><strong>gulp</strong></a>就可以运行啦~</p><p>需要完整代码请<a href="https://github.com/lynhao/webapp_angularjs" target="_blank" rel="external">戳这里</a></p><hr><p>就先吹水到这里，有问题下面留言~</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解&quot;&gt;&lt;a href=&quot;#接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解&quot; class=&quot;headerlink&quot; title=&quot;接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解&quot;&gt;&lt;/a&gt;接着上一篇文章，接下来我们写一写配置文件，下面我们会用到gulp几个方法。先了解了解&lt;/h4&gt;
    
    </summary>
    
    
      <category term="AngularJs" scheme="http://yoursite.com/tags/AngularJs/"/>
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp工具搭建AngularJs【上】</title>
    <link href="http://yoursite.com/2017/02/17/%E4%BD%BF%E7%94%A8gulp%E6%90%AD%E5%BB%BAangularjs%E3%80%90%E4%B8%8A%E3%80%91/"/>
    <id>http://yoursite.com/2017/02/17/使用gulp搭建angularjs【上】/</id>
    <published>2017-02-17T03:01:32.000Z</published>
    <updated>2018-06-01T01:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目-下一篇我们将讲解如何设置配置文件"><a href="#这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目-下一篇我们将讲解如何设置配置文件" class="headerlink" title="这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目,下一篇我们将讲解如何设置配置文件"></a>这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的<a href="#AngularJs"><strong>AngularJs</strong></a>项目,下一篇我们将讲解如何设置配置文件</h3><a id="more"></a><blockquote><p>如要查看历史文章请移步我的微信公众号查看：搜索林浩</p></blockquote><h3 id="全局安装-gulp"><a href="#全局安装-gulp" class="headerlink" title="全局安装 gulp"></a>全局安装 gulp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global gulp</div></pre></td></tr></table></figure><h3 id="安装bower环境"><a href="#安装bower环境" class="headerlink" title="安装bower环境"></a>安装bower环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g bower</div></pre></td></tr></table></figure><h3 id="创建空目录"><a href="#创建空目录" class="headerlink" title="创建空目录"></a>创建空目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir angular_web</div></pre></td></tr></table></figure><h3 id="在当前目录下安装配置文件"><a href="#在当前目录下安装配置文件" class="headerlink" title="在当前目录下安装配置文件"></a>在当前目录下安装配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> angular_web</div><div class="line">bower init</div></pre></td></tr></table></figure><p><strong>注意，如果你在osx环境下可能会遇到这种情况</strong><br><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/errorCut/sudo_error.png?raw=true" alt="error cut"><br>这里是因为bower不支持sudo，正确命令行如下</p><blockquote><p>下面涉及到的同理就不再重述</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo bower init --allow-root 或者 bower init --allow-root</div></pre></td></tr></table></figure><p>之后命令行会输出一些配置信息让你填写<br><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/bower_1.png?raw=true" alt="bower_1"><br>这里我们暂时先回车跳过不填写，后面可以在生成的<a href="#bower.json"><strong>bower.json</strong></a>文件中修改</p><h3 id="安装AngularJs"><a href="#安装AngularJs" class="headerlink" title="安装AngularJs"></a>安装AngularJs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install --save angular<span class="comment">#1.5.8</span></div></pre></td></tr></table></figure><p>这里我本地是1.5.8,目前1.6是最新的版本,之后它会向github仓库请求拉取资源,打开文件我们会发现它生成了<a href="#www"><strong>www</strong></a>这个目录</p><blockquote><p>这里你可能安装完之后的目录是bower_components，这个可能跟你的npm版本有关系，知道的童鞋麻烦下面留言告知</p></blockquote><h3 id="安装nodejs模块"><a href="#安装nodejs模块" class="headerlink" title="安装nodejs模块"></a>安装nodejs模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure><p>同样跟上一个步骤一样，一直回车，之后会生成一个<a href="#package.json"><strong>package.json</strong></a>文件</p><h3 id="开始安装模块"><a href="#开始安装模块" class="headerlink" title="开始安装模块"></a>开始安装模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i --save-dev gulp</div></pre></td></tr></table></figure><blockquote><p>它会写到我们刚刚创建的package.json文件中,查看文件</p></blockquote><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/bower_gulp.png?raw=true" alt="bower_gulp"></p><h6 id="这里我们会假设需要下面这些模块，实际你可以跟你的项目需求安装，命令行跟上面类似都是npm-i-–save-dev-模块名"><a href="#这里我们会假设需要下面这些模块，实际你可以跟你的项目需求安装，命令行跟上面类似都是npm-i-–save-dev-模块名" class="headerlink" title="这里我们会假设需要下面这些模块，实际你可以跟你的项目需求安装，命令行跟上面类似都是npm i –save-dev 模块名"></a>这里我们会假设需要下面这些模块，实际你可以跟你的项目需求安装，命令行跟上面类似都是<a href="#save"><strong>npm i –save-dev 模块名</strong></a></h6><ul><li>gulp-clean </li><li>gulp-concat </li><li>gulp-cssmin </li><li>gulp-imagemin </li><li>gulp-less</li><li>gulp-load-plugins</li><li>gulp-plumber</li><li>gulp-uglify</li><li>open</li></ul><blockquote><p>最后看看最终的目录结构</p></blockquote><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/directory1.png?raw=true" alt="directory1"></p><hr><h3 id="下一篇我们将进行配置文件编写，最终搭建一个本地服务完整的Angularjs项目，有问题请留言"><a href="#下一篇我们将进行配置文件编写，最终搭建一个本地服务完整的Angularjs项目，有问题请留言" class="headerlink" title="下一篇我们将进行配置文件编写，最终搭建一个本地服务完整的Angularjs项目，有问题请留言"></a>下一篇我们将进行配置文件编写，最终搭建一个本地服务完整的Angularjs项目，有问题请留言</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目-下一篇我们将讲解如何设置配置文件&quot;&gt;&lt;a href=&quot;#这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目-下一篇我们将讲解如何设置配置文件&quot; class=&quot;headerlink&quot; title=&quot;这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的AngularJs项目,下一篇我们将讲解如何设置配置文件&quot;&gt;&lt;/a&gt;这一篇文章我们来讲讲gulp，以及如何利用gulp去搭建一个完整的&lt;a href=&quot;#AngularJs&quot;&gt;&lt;strong&gt;AngularJs&lt;/strong&gt;&lt;/a&gt;项目,下一篇我们将讲解如何设置配置文件&lt;/h3&gt;
    
    </summary>
    
    
      <category term="AngularJs" scheme="http://yoursite.com/tags/AngularJs/"/>
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
</feed>
