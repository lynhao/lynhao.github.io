<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinHaW</title>
  
  <subtitle>LinHaW 的 博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-10T10:42:58.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Note For SVG</title>
    <link href="http://yoursite.com/2018/09/08/Note-For-SVG/"/>
    <id>http://yoursite.com/2018/09/08/Note-For-SVG/</id>
    <published>2018-09-08T09:41:25.000Z</published>
    <updated>2018-09-10T10:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题外话,移动端qq音乐和移动端得网易云音乐他们的播放器都用到了svg,所以自己实现了一下</p></blockquote><ul><li>qq音乐</li></ul><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/qqplay.gif" alt="QQ音乐"></p><ul><li>自定义</li></ul><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/svgplay.gif" alt="自定义"></p><p><a href="http://jsbin.com/tarudif/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><h3 id="世界-视野-视窗"><a href="#世界-视野-视窗" class="headerlink" title="世界,视野,视窗"></a>世界,视野,视窗</h3><ul><li>世界: 在svg中, 规定了世界的定义是无穷大的,也就是你在浏览器中看到的知识其中一部分;</li><li>视野: 它是一个观察世界的矩形区域,在svg中用viewbox来定义,它包含四个参数, x(x轴),y(跟数学中y轴向反),width,height)</li><li>视窗: 它规定视野中的width和height</li></ul><h3 id="四个坐标系"><a href="#四个坐标系" class="headerlink" title="四个坐标系"></a>四个坐标系</h3><p>svg中使用的坐标系是笛卡尔直角坐标系,它包括了一个原点(O)以及两条相互垂直的数轴(x,y),在数学上,x跟y的角度的矢量方向是逆时针的,而在svg中,它俩是顺时针方向,一句话概括,他俩之间的角度即时x轴正方向到y轴正方向的直角旋转角度规定为正方向(顺时针).</p><ol><li><p>用户坐标系(user coordinate)</p><p>我们称它为世界坐标系,我们设置viewbox,也就是来观察用户坐标系的某个区域,它是最原始的坐标系</p></li><li><p>自身坐标系 (current coordinate)</p><p>每个图形元素或分组独立与生俱来</p></li><li><p>前驱坐标系 (previous coordinate)</p><p>父容器的坐标系</p></li><li><p>参考坐标系 (reference coordinate)</p><p>使用其他坐标系来考究自身的情况时使用</p></li></ol><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>svg中可以使用<u>g</u>标签进行分组,然后统一进行坐标变换</p><ul><li>线性变换</li><li>transform属性</li></ul><h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><p>在svg中,基本图形有一下几种(初次接触我就感觉很亲切,因为很多都是css中clip-path的属性)</p><ul><li>rect(矩形) </li></ul><p>它接受[x, y, rx, ry, width, height],值得注意的是,一个矩形如果想变成一个椭圆,只需要改变x轴和y轴跟矩形的角度,rx和ry就是做这件事,分别定义一个椭圆的x轴半径和y轴半径</p><ul><li>circle(圆形)</li></ul><p>它接受[cx, cy, r]3个参数</p><ul><li>ellipse(椭圆形)</li></ul><p>它接受[cx, cy, rx, ry]4个参数</p><ul><li>line(线段)</li></ul><p>它接受[x1, x2, y1, y2]4个参数, 分别代表两个点的坐标</p><ul><li>polyline(折线)</li></ul><p>使用points指定各个坐标点位置</p><ul><li>polygon(多边形)</li></ul><p>同折线一样,只不过多边形会闭合</p><blockquote><p>另外,如果你想绘制更复杂的图形如曲线,需要用到<u>path</u>标签</p></blockquote><p><a href="http://jsbin.com/kixufiw/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><h3 id="颜色渐变-笔刷"><a href="#颜色渐变-笔刷" class="headerlink" title="颜色渐变,笔刷"></a>颜色渐变,笔刷</h3><p>颜色可以使用rgb或者hsl进行设置</p><ul><li>rgb三个值取值范围都在[0, 255]</li><li>hsl分别表示颜色[0,359],饱和度[0%,100%],亮度[0%,100%]</li></ul><p>渐变分为[线性渐变]和[径向渐变]两种</p><ol><li>线性渐变(linearGradient)</li></ol><p><a href="http://jsbin.com/tejopuh/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><p>渐变的颜色通过stop标签定义,x1,y1,x2,y2表示的是图形的最左上端和最右下端,默认是根据自身坐标系作为参照,gradientUnits=ObjectBoundingBox,而UserSpaceOnUse是根据用户坐标系</p><ol><li>径向渐变(radialGradient)</li></ol><p><a href="http://jsbin.com/qikehiy/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><p>同样渐变的颜色通过stop标签定义, 其中fx和fy是用来指定焦点的位置</p><h4 id="笔刷-pattern"><a href="#笔刷-pattern" class="headerlink" title="笔刷(pattern)"></a>笔刷(pattern)</h4><p><a href="http://jsbin.com/yarelof/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><p>使用pattern标签,我们可以为它的x,y,width,height指定单位是objectBoundingBox还是userSpaceOnUse,当我们指定patternUnits=”objectBoundingBox”是,它的x,y,width,height是根据容器的百分比计算的</p><p><a href="http://jsbin.com/nivusab/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><p> 同样我们也可以给他们的内容指定单位patternContentUnits,计算方式跟patternUnits一样</p><p> <a href="http://jsbin.com/lisiqih/edit?html,output" target="_blank" rel="external">点击在线查看实例代码</a></p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>path可以画出任何你想要的图形,它有如下命令,稍显复杂</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>M/m (x,y)+</td><td>移动当前位置</td></tr><tr><td>L/l (x,y)+</td><td>从当前位置绘制线段到指定位置</td></tr><tr><td>H/h (x)+</td><td>从当前位置绘制 平线到达指定的 x 坐标</td></tr><tr><td>V/v (x)+</td><td>从当前位置绘制竖直线到达指定的 y 坐标</td></tr><tr><td>Z/z</td><td>闭合当前路径</td></tr><tr><td>C/c (x1,y1,x2,y2,x,y)+</td><td>从当前位置绘制三次 塞尔曲线到指定位置</td></tr><tr><td>S/s (x2,y2,x,y)+</td><td>从当前位置光滑绘制三次 塞尔曲线到指定位置</td></tr><tr><td>Q/q (x1,y1,x,y)+</td><td>从当前位置绘制二次 塞尔曲线到指定位置</td></tr><tr><td>T/t (x,y)+</td><td>从当前位置光滑绘制二次 塞尔曲线到指定位置</td></tr><tr><td>A/a (rx,ry,xr,laf,sf,x,y)</td><td>从当前位置绘制弧线到指定位置</td></tr></tbody></table><blockquote><ul><li>命令区分大小写, 大写表示坐标参数为绝对位置,也就是绘制会以用户坐标系为参考,小写表示参数为相对位置,也就是会以自身坐标系为参考</li><li>最后的参数表示最终要到达的位置</li><li>上一个命令结束的位置就是下一个命令开始的位置 </li><li>命令可以重复参数表示重复执行同一条命令</li></ul></blockquote><h4 id="直线命令"><a href="#直线命令" class="headerlink" title="直线命令"></a>直线命令</h4><p>直线命名有 M, L, H, V, m, l, h, v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M 10 10 L 300 500&quot;/&gt;</div></pre></td></tr></table></figure><p><a href="http://jsbin.com/nodacek/edit?output" target="_blank" rel="external">点击在线代码操作</a></p><p>弧线命令</p><p>使用A命令绘制弧线,它的参数比较复杂</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>rx (radius-x)</td><td>弧线所在椭圆的 x 半轴长</td></tr><tr><td>ry (radius-y)</td><td>弧线所在椭圆的 y 半轴长</td></tr><tr><td>xr (xAxis-rotation)</td><td>弧线所在椭圆的长轴角度</td></tr><tr><td>laf (large-arc-flag)</td><td>是否选择弧长较长的那一段弧,0为短弧,1为长弧</td></tr><tr><td>sf (sweep-flag)</td><td>是否选择逆时针方向的那一段弧,0为逆时针,1为顺时针</td></tr><tr><td>x, y</td><td>弧的终点位置</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M 10 10 L 300 500 A 300 200 0 1 0 300 300&quot;/&gt;</div></pre></td></tr></table></figure><p><a href="http://jsbin.com/diloxih/edit?output" target="_blank" rel="external">点击在线代码操作</a></p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><ul><li>二次贝塞尔曲线</li></ul><p>它包含一个起始点,控制点和结束点,因为是二次贝塞尔曲线, 所以它的命令是 M x0 y0 Q x1 y1 x y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M215 283 Q 361 177 507 281&quot;/&gt;</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/bezier/quad.gif" alt=""></p><ul><li>三次贝塞尔曲线</li></ul><p>跟二次唯一不同点,它多了一个控制点,命令是 M x0 y0 C x1 y1 x2 y2 x y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M258 353 C 330 225 531 228 579 350&quot;/&gt;</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/bezier/three.gif" alt=""></p><ul><li>光滑曲线</li></ul><p>T: Q的光滑版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M200,300 Q400,50 600,300 T1000,300&quot;/&gt;</div></pre></td></tr></table></figure><p><img src="https://www.w3.org/TR/SVG11/images/paths/quad01.svg" alt=""></p><p>我们发现在这条二次贝塞尔曲线中, 我们在T中只指定一个结束点的坐标而没有设置控制点坐标.假设第二段贝塞尔曲线存在一个控制点(朝下)C1, C1的垂直方向跟第一条贝塞尔曲线的结束点重合,他俩关于这个重合的点发生了镜像关系,所以我们通过第一条贝塞尔曲线的控制点就可以控制两条贝塞尔曲线</p><p>S: C的光滑版本</p><p><img src="https://www.w3.org/TR/SVG11/images/paths/cubic02.svg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;path d=&quot;M600,800 C625,700 725,700 750,800 S875,900 900,800&quot; /&gt;</div></pre></td></tr></table></figure><p>如图右下角最后一个张图就是三次光滑贝塞尔曲线, 同样值定义了第二个控制点坐标和结束位置坐标,跟前面二次光滑贝塞尔曲线一样的原理,都是通过镜像的方式去确定控制点位置和起始点位置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题外话,移动端qq音乐和移动端得网易云音乐他们的播放器都用到了svg,所以自己实现了一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;qq音乐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://picturegit-12519
      
    
    </summary>
    
    
      <category term="svg" scheme="http://yoursite.com/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>CSS工程化方案</title>
    <link href="http://yoursite.com/2018/08/21/CSS%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2018/08/21/CSS工程化方案/</id>
    <published>2018-08-21T07:40:02.000Z</published>
    <updated>2018-08-21T09:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是css工程化,这个应该是目前前端的一个热点方向,如果在日趋复杂的项目更合理的维护和迭代,这个问题个人尤为重要,下面将展开目前我所认知的常规方案</p></blockquote><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><p>什么是<u>postcss</u>,有人说它是后处理器,个人觉得其实它跟前处理器(预处理器)背后所做的现在已经没差。官网的解释是:<u>PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能</u><br>简单来说,postcss它只具备解析能力,至于转换能力就需要依赖插件(200+)</p><p>处理过程: </p><blockquote><p>Css –&gt; PostCss(模块化,加前缀,兼容性,css语法检查) –&gt; Css</p></blockquote><h3 id="postcss-import"><a href="#postcss-import" class="headerlink" title="postcss-import"></a>postcss-import</h3><p>用于css文件的合并</p><ul><li>02-plugins-main.css</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@import <span class="string">"./02-plugins-module.css"</span>;</div><div class="line"></div><div class="line">.box&#123;</div><div class="line">    box-shadow: 0 0 3px rgba(255,255,255, .3);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>02-plugins-module.css</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* css-reset */</div><div class="line">*&#123;</div><div class="line">    padding:0;</div><div class="line">    margin:0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">body&#123;</div><div class="line">    margin: 10px 20px 10px 20px;</div><div class="line">    font-size:14px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">body&#123;</div><div class="line">    background-color:<span class="comment">#ffffff;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const atImport = require(<span class="string">'postcss-import'</span>)</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">      atImport</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>执行合并操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/postcss src/02-plugins-main.css -o build/02-plugins-main.css</div></pre></td></tr></table></figure><h3 id="autoprefixier"><a href="#autoprefixier" class="headerlink" title="autoprefixier"></a>autoprefixier</h3><p>用于适配不同浏览器,自动加前缀 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const autoprefixer = require(&apos;autoprefixer&apos;)</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">       autoprefixer(&#123;</div><div class="line">            browsers:[&apos;last 2 verisons&apos;]  //指定最近两个版本</div><div class="line">       &#125;)</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>执行加前缀操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/postcss src/02-plugins-main.css -o build/02-plugins-main.css</div></pre></td></tr></table></figure><h3 id="cssnano"><a href="#cssnano" class="headerlink" title="cssnano"></a>cssnano</h3><p>用于资源压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const cssnano = require(<span class="string">'cssnano'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">      cssnano</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>执行代码压缩操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/postcss src/02-plugins-main.css -o build/02-plugins-main.css</div></pre></td></tr></table></figure><h3 id="cssnext"><a href="#cssnext" class="headerlink" title="cssnext"></a>cssnext</h3><p>用于解析css新特性(已定稿,但浏览器未实现)</p><ul><li>03.cssnext.css</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">:root &#123;</div><div class="line">    --mainColor: red;</div><div class="line">    --danger-theme: &#123;</div><div class="line">        color: white;</div><div class="line">        background-color: red;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">a &#123;</div><div class="line">    color: var(--mainColor);</div><div class="line">&#125;</div><div class="line"></div><div class="line">.danger &#123;</div><div class="line">    @apply --danger-theme;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const cssnext = require(&apos;postcss-cssnext&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">       cssnext,</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>执行解析操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/postcss src/03.cssnext.css -o build/03.cssnext.css</div></pre></td></tr></table></figure><p>结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.danger &#123;</div><div class="line">  color: white;</div><div class="line">  background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="precss"><a href="#precss" class="headerlink" title="precss"></a>precss</h3><p>它类似于sass,能够解析变量,条件if,循环,mixin,import,属性引用</p><ul><li>04-precss.css</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">$blue</span>: <span class="comment">#056ef0;</span></div><div class="line"><span class="variable">$column</span>: 200px;</div><div class="line"></div><div class="line">.menu &#123;</div><div class="line">width: calc(4 * <span class="variable">$column</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">.menu_link &#123;</div><div class="line">background: <span class="variable">$blue</span>;</div><div class="line">width: <span class="variable">$column</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.notice--clear &#123;</div><div class="line">@<span class="keyword">if</span> 3 &lt; 5 &#123;</div><div class="line">background: green;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">else</span> &#123;</div><div class="line">background: blue;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 3 &#123;</div><div class="line">.b-<span class="variable">$i</span> &#123; width: $(i)px; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const precss = require(<span class="string">'precss'</span>);</div><div class="line">module.exports = &#123;</div><div class="line">    plugins: [</div><div class="line">        precss</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>执行解析操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/postcss src/04.precss.css -o build/04.precss.css</div></pre></td></tr></table></figure><p>结果: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">.menu &#123;</div><div class="line">width: calc(4 * 200px);</div><div class="line">&#125;</div><div class="line">.menu_link &#123;</div><div class="line">background: <span class="comment">#056ef0;</span></div><div class="line">width: 200px;</div><div class="line">&#125;</div><div class="line">.notice--clear &#123;</div><div class="line">background: green</div><div class="line">&#125;</div><div class="line">.b-1 &#123; width: 1px; &#125;</div><div class="line">.b-2 &#123; width: 2px; &#125;</div><div class="line">.b-3 &#123; width: 3px; &#125;</div></pre></td></tr></table></figure><blockquote><p>此外,PostCss它还可以跟其他构建工具集成使用,除了自己的PostCss-Cli,还可以跟Gulp,Webpack,Grunt,Rollup等等</p></blockquote><h3 id="gulp-postcss"><a href="#gulp-postcss" class="headerlink" title="gulp-postcss"></a>gulp-postcss</h3><ul><li>创建配置文件gulpfile.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const gulp = require(<span class="string">'gulp'</span>);</div><div class="line">const autoprefixer = require(<span class="string">'autoprefixer'</span>);</div><div class="line">const cssnano = require(<span class="string">'cssnano'</span>);</div><div class="line">const atImport = require(<span class="string">'postcss-import'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'postcss'</span>, <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    var postcss    = require(<span class="string">'gulp-postcss'</span>);</div><div class="line"></div><div class="line">    <span class="built_in">return</span> gulp.src(<span class="string">'src/02-plugins-main.css'</span>)</div><div class="line">        .pipe(postcss([</div><div class="line">            atImport,</div><div class="line">            autoprefixer(&#123;</div><div class="line">                browsers:[<span class="string">'last 2 versions'</span>]</div><div class="line">            &#125;),</div><div class="line">            cssnano</div><div class="line">        ]))</div><div class="line">        .pipe(gulp.dest(<span class="string">'build/'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>执行解析操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp postcss</div></pre></td></tr></table></figure><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>在webpack中,js是整个应用的核心入口,也就是说css最终会被转为js,并且插入到dom中去</p><ul><li>创建webpack.module.js,并暴露出去</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    say: <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        console.log(<span class="string">'hello from module'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>创建webpack.main.js,引入webpack.module.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var module = require(<span class="string">'./webpack-module.js'</span>);</div><div class="line"></div><div class="line">module.say();</div></pre></td></tr></table></figure><ul><li>执行操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/webpack src/webpack.main.js build/webpack.main.js</div></pre></td></tr></table></figure><ul><li>创建一个html文件,引入压缩后的js文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;script src=<span class="string">"build/webpack-main.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure><blockquote><p> 直接require一个js文件没问题,如果我们在js直接require一个css文件的话,它是会报错,因为我们需要给它指定对应loader去处理css</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">test</span>: /.\css$/,</div><div class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先css-loader负责会把css文件转为js文件交给webpack处理,再style.loader把变成js的css文件注入到页面中</p><blockquote><p>由于直接require一个css文件后,它的所以选择器的属性都暴露在全局中,会引起干扰,我们需要给他一个命名空间或者私有空间,让他们不会有冲突。</p></blockquote><p><u>cssModule</u>就是来处理这种问题,可以在css-loader中配置它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [&#123;</div><div class="line">      <span class="built_in">test</span>: /.\css$/,</div><div class="line">      use: [<span class="string">'style.loader'</span>, &#123;</div><div class="line">        loader: <span class="string">'css-loader'</span>,</div><div class="line">        options: &#123;</div><div class="line">          modules: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">      &#125;]</div><div class="line">      </div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个时候,css中的所有选择器名字都变了不能直接使用,但是require一个css文件, 使用cssModule用它会返回一个class列表, 通过style.[类名]去访问对应样式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;什么是css工程化,这个应该是目前前端的一个热点方向,如果在日趋复杂的项目更合理的维护和迭代,这个问题个人尤为重要,下面将展开目前我所认知的常规方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;PostCss&quot;&gt;&lt;a href=&quot;#Post
      
    
    </summary>
    
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>Vue之Tab组件开发</title>
    <link href="http://yoursite.com/2018/08/16/Vue%E4%B9%8BTab%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/08/16/Vue之Tab组件开发/</id>
    <published>2018-08-16T13:12:52.000Z</published>
    <updated>2018-08-16T14:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>Tab不管在移动端或者在PC端都非常常见,今天尝试了一下,发现并没有想象那么简单,可能是框架复杂性,但一件事想做好它永远都不简单。</p><p>我们想要页面渲染出类似的DOM结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line"> &lt;ul&gt;</div><div class="line">  &lt;li&gt;title1&lt;/li&gt;</div><div class="line">  &lt;li&gt;title1&lt;/li&gt;</div><div class="line"> &lt;/ul&gt;</div><div class="line"> &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>我们的需求很简单, 可以根据tab选项卡显示不同的tab页内容。那么在Vue中我们应该如何实现这种结构呢?</p><p>我们把上面的代码设计成下面这种形式去实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;tabs value=&quot;1&quot;&gt;</div><div class="line">   &lt;tab label=&quot;tab1&quot; index=&quot;1&quot;&gt;</div><div class="line">   &lt;span&gt;content1&lt;/span&gt;</div><div class="line">   &lt;/tab&gt;</div><div class="line">    &lt;tab label=&quot;tab2&quot; index=&quot;2&quot;&gt;</div><div class="line">   &lt;span&gt;content2&lt;/span&gt;</div><div class="line">   &lt;/tab&gt;</div><div class="line">    &lt;tab label=&quot;tab3&quot; index=&quot;3&quot;&gt;</div><div class="line">   &lt;span&gt;content3&lt;/span&gt;</div><div class="line">   &lt;/tab&gt;</div><div class="line">&lt;/tabs&gt;</div></pre></td></tr></table></figure><blockquote><p>tabs中<u>value</u>用于指定默认选中的Tab页面, tab中的<u>label</u>用于设置标题,<u>index</u>用于跟<u>value</u>中对应是否选中</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>从上边的代码片段,我们分析出需要创建三个组件,父级为tabs.vue,子级为tab.vue和tab-container.vue</p><ul><li>tabs.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  export default &#123;</div><div class="line">    name: &apos;Tabs&apos;,</div><div class="line">    props: &#123;</div><div class="line">      value: &#123;</div><div class="line">        type: [String, Number],</div><div class="line">        required: true</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    render () &#123;</div><div class="line">      return (</div><div class="line">        &lt;div class=&quot;tabs&quot;&gt;</div><div class="line">          &lt;ul class=&quot;tabs-header&quot;&gt;</div><div class="line">            &#123;this.$slots.options&#125;</div><div class="line">          &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><blockquote><p>代码使用了jsx的写法,因为vue中的js是用babel处理的,我们可以用<u>babel-plugin-transform-vue-jsx</u>这个插件支持</p></blockquote><p>我们将使用slot插槽去包含子组件tab.vue</p><ul><li>tab.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  export default &#123;</div><div class="line">    name: &apos;Tab&apos;,</div><div class="line">    props: &#123;</div><div class="line">      index: &#123;</div><div class="line">        type: [Number, String],</div><div class="line">        required: true</div><div class="line">      &#125;,</div><div class="line">      label: &#123;</div><div class="line">        type: String,</div><div class="line">        default: &apos;tab&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">      active () &#123;</div><div class="line">        return false</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    render () &#123;</div><div class="line">      const tab = this.$slots.label || &lt;span&gt;&#123;this.label&#125;&lt;/span&gt;</div><div class="line">      const classNames = &#123;</div><div class="line">        tab: true,</div><div class="line">        active: this.active</div><div class="line">      &#125;</div><div class="line">      return (</div><div class="line">        &lt;li class=&#123;classNames&#125; &gt;</div><div class="line">          &#123;tab&#125;</div><div class="line">        &lt;/li&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>tab同样也是使用jsx的写法,active我们使用计算属性去判断是否选中,代码给了一个默认值false,它作用就是跟父组件中的<u>value</u>比较,相同则选中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  active () &#123;</div><div class="line">    return this.data.value === this.index</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>DOM雏形在这里大概出来,我们还需要把它们以组件的形式挂载到Vue实例中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import Tabs from &apos;./tabs.vue&apos;</div><div class="line">import Tab from &apos;./tab.vue&apos;</div><div class="line"></div><div class="line">export default (Vue) =&gt; &#123;</div><div class="line">  Vue.component(Tabs.name, Tabs)</div><div class="line">  Vue.component(Tab.name, Tab)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>main.js(页面入口)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import Tabs from &apos;./component/tabs/index.js&apos;</div><div class="line"></div><div class="line">Vue.use(Tabs)</div></pre></td></tr></table></figure><p>文档说了,如果插件是返回一个函数,它会被作为install的用法,将Vue参赛传入,并且被多次调用的时候该插件只会安装一次</p><h4 id="provide高级属性应用"><a href="#provide高级属性应用" class="headerlink" title="provide高级属性应用"></a>provide高级属性应用</h4><p>还记得前面我们通过<u>this.$parent</u>去获取父组件上的属性吗,如果需求变了需要再嵌套一层div,那<u>this.$parent</u>就指向了div,那就不妥了,有什么办法呢?<u>provide</u>,它可以实现我们的需求。</p><ul><li>tabs.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">provide () &#123;</div><div class="line">  return &#123;</div><div class="line">     value: this.value</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里要注意了,如果是provide:{}直接以对象的话, 是拿不到<u>this</u>,因为这个时候Vue还没被初始化成功。</p><ul><li>tab.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">inject: [&apos;value&apos;],</div><div class="line">computed: &#123;</div><div class="line">  active () &#123;</div><div class="line">    return this.value === this.index</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>问题看似得到解决,其实不然,因为provide它并不能react,也就是我们如果需要value能够实现数据响应,这种方式是做不到。我们都知道Vue是如何实现双向数据绑定,同样,我们这里也可以这样处理。</p><ul><li>tabs.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">provide () &#123;</div><div class="line">  const data = &#123;&#125;</div><div class="line">  Object.defineProperty(data, &apos;value&apos;, &#123;</div><div class="line">    get: () =&gt; &#123;</div><div class="line">      return this.value</div><div class="line">    &#125;,</div><div class="line">    enumerable: true</div><div class="line">  &#125;)</div><div class="line">  return &#123;</div><div class="line">    data</div><div class="line">  &#125;</div></pre></td></tr></table></figure><ul><li>tab.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">inject: [&apos;data&apos;],</div><div class="line">computed: &#123;</div><div class="line">  active () &#123;</div><div class="line">    return this.data.value === this.index</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>最后我们需要不同tab显示不同的内容页</p><p>tab-container.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  export default &#123;</div><div class="line">    props: &#123;</div><div class="line">      panes: &#123;</div><div class="line">        type: Array,</div><div class="line">        required: true</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    render () &#123;</div><div class="line">      const contents = this.panes.map(pane =&gt; &#123;</div><div class="line">        return pane.active ? pane.$slots.default : null</div><div class="line">      &#125;)</div><div class="line">      return (</div><div class="line">        &lt;div class=&quot;tab-content&quot;&gt;</div><div class="line">          &#123;contents&#125;</div><div class="line">        &lt;/div&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p><u>this.panes</u>数据从哪来,别急</p><p>-tabs.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">data () &#123;</div><div class="line">  return &#123;</div><div class="line">    panes: []</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line">render () &#123;</div><div class="line">  return (</div><div class="line">    &lt;div class=&quot;tabs&quot;&gt;</div><div class="line">      &lt;ul class=&quot;tabs-header&quot;&gt;</div><div class="line">        &#123;this.$slots.options&#125;</div><div class="line">      &lt;/ul&gt;</div><div class="line">      &lt;tab-container panes=&#123;this.panes&#125;&gt;&lt;/tab-container&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;,</div></pre></td></tr></table></figure><ul><li>tab.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mounted () &#123;</div><div class="line">  this.$parent.panes.push(this)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里得<u>this</u>其实就是tab,也就是<li></li>的集合,tab-container再通过判断选中的li去显示对应的内容页。</p><h4 id="想一想"><a href="#想一想" class="headerlink" title="想一想"></a>想一想</h4><p>可能有些小伙伴看到这里会有些疑问,为什么在父级中不直接把tab-container的节点直接写到render中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">render () &#123;</div><div class="line"> const contents = this.panes.map(pane =&gt; &#123;</div><div class="line">    return pane.active ? pane.$slots.default : null</div><div class="line">  &#125;)</div><div class="line">return (</div><div class="line">    &lt;div class=&quot;tabs&quot;&gt;</div><div class="line">      &lt;ul class=&quot;tabs-header&quot;&gt;</div><div class="line">        &#123;this.$slots.options&#125;</div><div class="line">      &lt;/ul&gt;</div><div class="line">       &lt;div class=&quot;tab-content&quot;&gt;</div><div class="line">      &#123;contents&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们整个组件都是用了slot插槽,因为它的灵活性和可扩展性,但它并不支持react,所以如果我们需要再内容页做一些数据绑定的操作,你会发现很奇怪的现象。我们通过把内容页抽到一个组件,通过props实现了数据的react。</p><blockquote><p>看这里,<u>babel-plugin-transform-vue-jsx</u>3.7.0这个版本你会发现数据同样没有react,点击其他选项卡之后数据才更新,笔者目前还不知道具体什么原因导致的,但降级到3.5.0,这个功能就完美实现了,如果小伙伴得知,可以在下面留言告知~</p></blockquote><p>最后,具体的源码实现我已经上传到<a href="https://github.com/lynhao/wpDemo/tree/senior" target="_blank" rel="external">github</a>,欢迎<u>Fork</u>和<u>Star</u>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;Tab不管在移动端或者在PC端都非常常见,今天尝试了一下,发现并没有想象那么简单,可能是框架复杂性,但一件事想做好它永远都不
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Q&amp;A</title>
    <link href="http://yoursite.com/2018/08/14/Q-A/"/>
    <id>http://yoursite.com/2018/08/14/Q-A/</id>
    <published>2018-08-14T06:29:17.000Z</published>
    <updated>2018-08-14T06:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Q1: <a href="https://www.jianshu.com/p/7e63f5a32636" target="_blank" rel="external">解决移动端Retina屏幕1px边框问题?</a></li><li>Q2: </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Q1: &lt;a href=&quot;https://www.jianshu.com/p/7e63f5a32636&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解决移动端Retina屏幕1px边框问题?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Q2: &lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>发发牢骚</title>
    <link href="http://yoursite.com/2018/07/27/%E5%8F%91%E5%8F%91%E7%89%A2%E9%AA%9A/"/>
    <id>http://yoursite.com/2018/07/27/发发牢骚/</id>
    <published>2018-07-27T04:15:11.000Z</published>
    <updated>2018-09-12T16:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>2018年09月12日23:48:13</li></ul><p><img src="https://picturegit-1251927503.cos.ap-guangzhou.myqcloud.com/blog/IMG_20180912_152101.jpg" alt=""></p><p>今天去腾讯面试了,可能是太兴奋了,所以今天一整天我只喝了一杯牛奶,下午明显感觉有点饿,在做题的时候出现了一条过于DOM操作的题目,现在想想,面试官其实想考是是我对事件委托的理解,我那时不知道是不是饿昏了头,结果写出了时间捕获?什么,我为什么会这么sb,事件委托就是利用事件冒泡啊亲,我的乖乖~然后他们的岗位是很多node的应用场景,虽然我对node了解甚少,但如果我去学的话是可以很快上手的,总的来说,面试偏基础,我中间某些方面处理的不够好(想想我平时的表现跟面试就是两个人的存在,不应该啊).好吧,接下来如果他们没有答复我,我就继续投吧,看看鹅厂还有没有位置留给我,加油!</p><ul><li>2018年09月11日16:37:06</li></ul><p>这两天晚上都写代码到凌晨三点多,刚刚收到腾讯的面试,祝我好运吧,我想写代码</p><ul><li>2018年08月03日00:06:49</li></ul><p>太亮的光线让我无法集中注意力写代码</p><ul><li>2018年08月01日23:17:11</li></ul><p>耳机现在播放<u>再见理想</u>这首歌,我很担心,其实也不必担心,按照记忆曲线,随时间推移你了如指掌的东西也会沦为陌生人,例如上周面试的时候,我居然忘了mvvm中的监听者,真是惭愧,我之前还写了一篇文章去讲解mvvm原理,我曾经引以为豪的android,如今我也忘得差不多了,压根就没在实际项目中写过(严格上说吧),希望,我看过的每一行代码,能领悟它背后的思想,就算外壳忘了也无所谓,毕竟梦想,是为了颠覆传统.</p><ul><li>2018年07月28日00:30:49</li></ul><p>可能是酒精作用,看了下三年前的git提交记录,在我的mac上有一种东西是我不可能删除的–我写的代码,迫于内存原因,我把他们都提交到了git上,可是有些东西,时间一长,它的本质就变了,你再也看不懂三年前你写的代码,代码的编译运行环境也好像跟你作对,工程也跑不起来,人就这样,喜欢恋旧而不思进取,不懂得舍弃,永远得不到进步,果断<u>delete</u>吧,dude</p><ul><li>2018年07月27日12:17:16</li></ul><p>很烦是当前内心的代名词,整个人又变得很浮躁,想学的技术太多,前端东西很杂,很碎,并且越来越难,加上我这段时间状态很差,注意力不集中,懒撒,无规划,心存侥幸等所有坏词都可以来形容此时此刻的我,what should i do, dude?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;2018年09月12日23:48:13&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://picturegit-1251927503.cos.ap-guangzhou.myqcloud.com/blog/IMG_20180912_152101.jp
      
    
    </summary>
    
    
      <category term="person business" scheme="http://yoursite.com/tags/person-business/"/>
    
  </entry>
  
  <entry>
    <title>团队协作代码规范</title>
    <link href="http://yoursite.com/2018/06/18/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/06/18/团队协作代码规范/</id>
    <published>2018-06-18T08:37:36.000Z</published>
    <updated>2018-06-18T14:43:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两个程序员可以写出3种风格代码,前端尤其明显(我也曾经是写过后端代码的人),主要是JS留下的后遗症。虽然现在主流的编辑器如webstorm或者Visual Studio可能加上eslint强行限制你那天马行空的代码。我对代码本身就有”洁癖”,对自己对别人也一样,如何防止你那讨厌的同事写上糟糕的代码来”污染”你那圣神的代码,这篇文章会给出”紧箍咒”让所有人必须遵从约定好的代码风格以保存项目的整洁性。</p></blockquote><h2 id="eslint-standards"><a href="#eslint-standards" class="headerlink" title="eslint standards"></a>eslint standards</h2><p>业界已经提出一种标准方案–<u>JavaScript Standard Style</u></p><blockquote><p>以下的代码演示均来<u>《webpack渐入佳境之打包优化篇》</u></p></blockquote><p>我们需要安装以下依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.02.01.png" alt=""></p><ul><li>根目录下创建.eslintrc文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"extends"</span>: <span class="string">"standard"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样eslint就可以帮我们校验代码,但因为我们这个项目是vue开发,eslint它并不能识别里面的js代码(.vue文件并非传统的.js文件),我们需要有一个东西可以识别任意格式文件里面的javascript标签</p><ul><li>eslint-plugin-html</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint-plugin-html -D</div></pre></td></tr></table></figure><p>修改.eslintrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">"plugins"</span>: [</div><div class="line">   <span class="string">"html"</span></div><div class="line"> ],</div></pre></td></tr></table></figure><p>修改package.json 添加命令去校验代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">   ...</div><div class="line"> + &quot;lint&quot;: &quot;eslint --ext .js --ext .jsx --ext .vue src/&quot;,</div><div class="line">   &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</div><div class="line"> &#125;,</div></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.09.00.png" alt=""></p><p>可以看到控制台已经抛出错误,例如空格符跟tab缩进混用, 多打了一个空格之类。eslint可以帮我们处理比较简单错误</p><p>修改package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js --ext .jsx --ext .vue src/"</span>,</div><div class="line">+ <span class="string">"lint-fix"</span>: <span class="string">"eslint --fix --ext .js --ext .jsx --ext .vue src/"</span>,</div></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint-fix</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2016.20.28.png" alt=""></p><p>我们发现错误减少了,但还是报了空格和tab缩进混合使用错误,这些问题在很多现代编辑器很帮你处理好,我们也可以手动修改覆盖编辑器默认属性。</p><p>创建.editorconfig</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = <span class="literal">true</span></div><div class="line"></div><div class="line">[*]</div><div class="line">charset = utf-8</div><div class="line">end_of_line = lf</div><div class="line">indent_size = 2   //缩进单位</div><div class="line">indent_style = space   //空格   </div><div class="line">insert_final_newline = <span class="literal">true</span> //最后换行</div><div class="line">trim_trailing-whitesplace = <span class="literal">true</span>  //句尾去掉空格</div></pre></td></tr></table></figure><blockquote><p>“root = true”是指只读取到这个配置文件就结束,不再往上层目录找,end_of_line指定回车换行符,window使用的是CRLF,linux和osx都是LF</p></blockquote><p>但是每次都敲命令行感觉又很繁琐,能不能让它自动检查每次代码更新进行eslint</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i eslint-loader babel-eslint -D</div></pre></td></tr></table></figure><p>修改.eslintrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&quot;parser&quot;: &quot;babel-eslint&quot;</div></pre></td></tr></table></figure><p>这样处理是因为webpack最终都是需要经过babel编译(es5),而eslint它是支持es6和es7,这样可能会导致一些奇奇怪怪的问题。</p><p>配置eslint-loader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">    rules: [</div><div class="line">     + &#123;</div><div class="line">     +  <span class="built_in">test</span>: /\.(vue|js|jsx)$/,</div><div class="line">     +   loader: <span class="string">'eslint-loader'</span>,</div><div class="line">     +   exclude: /node_modules/, //已经经过babel处理,所以去掉</div><div class="line">     +   enforce: <span class="string">'pre'</span></div><div class="line">     + &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">test</span>: /\.vue$/,</div><div class="line">        loader: <span class="string">'vue-loader'</span></div><div class="line">      &#125;,</div><div class="line">      ...</div></pre></td></tr></table></figure><blockquote><p>enforce: ‘pre’  是因为.vue文件我们已经制定vue-loader去处理,我们不希望eslint-loader处理.vue文件,我们只是希望在vue-loader处理之前先进行eslint语法检查。</p></blockquote><p>最后,如果你希望所有人都把本地的代码规范问题都解决后才能提交,可以尝试这么做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i husky -D</div></pre></td></tr></table></figure><p>它会在.git文件里面生成一个hooks,它会读取我们在package.json里面配置的信息</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-18%2022.29.27.png" alt=""></p><p>修改package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  ...</div><div class="line">+ <span class="string">"precommit"</span>: <span class="string">"npm run lint-fix"</span>,</div><div class="line">  <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"</span></div></pre></td></tr></table></figure><p>这样我们每次 <u>git commit -m ‘log’</u>的时候它都会先进行一次eslint检查,通过了才能成功commit</p><blockquote><p>注意,安装husky之前必须确保项目中已经有.git文件,否者hook将会写入失败。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;两个程序员可以写出3种风格代码,前端尤其明显(我也曾经是写过后端代码的人),主要是JS留下的后遗症。虽然现在主流的编辑器如webstorm或者Visual Studio可能加上eslint强行限制你那天马行空的代码。我对代码本身就有”洁癖”,对自己
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="eslint" scheme="http://yoursite.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>webpack渐入佳境之打包优化篇</title>
    <link href="http://yoursite.com/2018/06/16/webpack%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%E4%B9%8B%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/16/webpack渐入佳境之打包优化/</id>
    <published>2018-06-16T14:59:29.000Z</published>
    <updated>2018-06-16T15:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>继上一篇,我们已经做了build操作,但我们只做了webpack的构建工作,它目前并不具备服务器功能,接下来我们先来完善它</p></blockquote><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server跟webpack不同点在于它提供了实时加载的服务,并且只能用于开发环境</p><blockquote><p>修改 package.json</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">...</div><div class="line">   <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.config.js"</span></div><div class="line"> &#125;,</div></pre></td></tr></table></figure><blockquote><p>配置区分对应模式</p><ul><li>package.json</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --config webpack.config.js"</span>,</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure><p>这里需要安装<u>cross-env</u>这个包来处理不同平台(osx、win)的差异,如win需要配置成<strong>set NODE_ENV= development</strong> 之类</p><ul><li>webpack.config.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">+ const isDev = process.env.NODE_ENV === <span class="string">'development'</span></div></pre></td></tr></table></figure><p>可以通过process.env去读取在命令设置的变量名NODE_ENV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">+ target: <span class="string">'web'</span>  //运行在浏览器</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">+ <span class="keyword">if</span> (isDev) &#123;</div><div class="line">+  config.devtool = <span class="string">'#cheap-module-eval-source-map'</span>  //帮助调试代码 <span class="built_in">source</span>Map</div><div class="line">+  config.devServer = &#123;</div><div class="line">+   port: <span class="string">'8000'</span>,</div><div class="line">+    host: <span class="string">'0.0.0.0'</span>,</div><div class="line">+   overlay: &#123;</div><div class="line">+      errors: <span class="literal">true</span>  //捕获webpack编译过程错误,并显示到页面</div><div class="line">+   &#125;,</div><div class="line">+    open: <span class="literal">true</span>   //自动打开浏览器</div><div class="line">+  &#125;</div><div class="line">+ &#125;</div></pre></td></tr></table></figure><p>上面就是简单的服务器配置</p><blockquote><p>创建入口文件 index.html</p></blockquote><p>到目前为止我们还看不到效果,我们需要把前面打包压缩的文件放到一个html文件去显示。正好webpack已经为我们提供了一个插件–<u>html-webpack-plugin</u>,会自动为我们创建一个简单的html文件,文档是这么说明的,这里贴上就不做翻译。</p><blockquote><p>This is a webpack plugin that simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation. You can either let the plugin generate an HTML file for you, supply your own template using lodash templates or use your own loader.</p></blockquote><ul><li>webpack.config.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ const HtmlPlugin = require(<span class="string">'html-webpack-plugin'</span>)</div><div class="line">+ const webpack = require(<span class="string">'webpack'</span>)</div><div class="line"></div><div class="line">  ...</div><div class="line">+ plugins: [</div><div class="line">+  new webpack.DefinePlugin(&#123;</div><div class="line">+    <span class="string">'process.env'</span>: &#123;</div><div class="line">+      NODE_ENV: isDev ? <span class="string">'"development"'</span> :<span class="string">'"production"'</span></div><div class="line">+    &#125;</div><div class="line">+  &#125;),</div><div class="line">+  new HtmlPlugin()</div><div class="line">+ ]</div></pre></td></tr></table></figure><p>此外我们添加了一个webpack提供的一个插件<u>DefinePlugin</u>,它会在编译时期创建全局变量,我们在写js代码也可以引用process.env.NODE_ENV去做逻辑判断。</p><p>敲下<strong>npm run dev</strong>你会看到如下:</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wpcode1.png" alt="code"></p><ul><li>HMR配置</li></ul><p>webpack为我们提供了热加载的功能,这样不会因为节点的增删改而刷新整个页面影响体验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config.devServer = &#123;</div><div class="line">   + hot: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line">+ config.plugins.push(</div><div class="line">+    new webpack.HotModuleReplacementPlugin(),</div><div class="line">+    new webpack.NoEmitOnErrorsPlugin()</div><div class="line">+ )</div></pre></td></tr></table></figure><h2 id="分离css打包"><a href="#分离css打包" class="headerlink" title="分离css打包"></a>分离css打包</h2><p>从这里开始讲会webpack的打包优化,首先我们先看看bundle.js打包后的样子</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wp2.png" alt="code"></p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/wp3.png" alt="code"></p><p>上面的图片可以看到,css依旧以js的形式打包在一起,显然这样子做浏览器缓存并不合理.</p><ul><li>extract-text-webpack-plugin</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i extract-text-webpack-plugin</div></pre></td></tr></table></figure><p>通过装这个插件,webpack会自动帮我们把除javascript文件以外的文件打包成静态文件,最终作为外链的形式加入到html的head中</p><blockquote><p>修改配置文件对开发环境和正式环境打包进行调整</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isDev) &#123;</div><div class="line">+  config.module.rules.push(&#123;</div><div class="line">+    <span class="built_in">test</span>: /\.styl$/,</div><div class="line">+    use: [</div><div class="line">+          <span class="string">'style-loader'</span>,  //将 JS 字符串生成为 style 节点</div><div class="line">+         <span class="string">'css-loader'</span>,   //将 CSS 转化成 CommonJS 模块</div><div class="line">+          &#123;</div><div class="line">+            loader: <span class="string">'postcss-loader'</span>,</div><div class="line">+            options: &#123;</div><div class="line">+            <span class="built_in">source</span>Map: <span class="literal">true</span>   //复用上一个loader的<span class="built_in">source</span>Map</div><div class="line">+          &#125;</div><div class="line">+        &#125;,</div><div class="line">+          <span class="string">'stylus-loader'</span></div><div class="line">+      ]</div><div class="line">  &#125;)</div><div class="line"> ...</div><div class="line">+ &#125; <span class="keyword">else</span> &#123;</div><div class="line">+  config.output.filename = <span class="string">'[name].[chunkhash:8].js'</span></div><div class="line">+  config.module.rules.push(</div><div class="line">+    &#123;</div><div class="line">+     <span class="built_in">test</span>: /\.styl$/,</div><div class="line">+      use: ExtractPlugin.extract(&#123;</div><div class="line">+        fallback: <span class="string">'style-loader'</span>,</div><div class="line">+        use: [</div><div class="line">+          <span class="string">'css-loader'</span>,</div><div class="line">+          &#123;</div><div class="line">+            loader: <span class="string">'postcss-loader'</span>,</div><div class="line">+            options: &#123;</div><div class="line">+              <span class="built_in">source</span>Map: <span class="literal">true</span></div><div class="line">+            &#125;</div><div class="line">+          &#125;,</div><div class="line">+          <span class="string">'stylus-loader'</span></div><div class="line">+        ]</div><div class="line">+      &#125;)</div><div class="line">+    &#125;,</div><div class="line">+  )</div><div class="line">+  config.plugins.push(</div><div class="line">+    new ExtractPlugin(<span class="string">'styles.[contentHash:8].js'</span>)</div><div class="line">+  )</div></pre></td></tr></table></figure><blockquote><p>注意:所有打包出来的js模块的hash值都是一样的,chunkhash会根据每个chunk(entry里面定义的不同节点)生产不同的hash值,如果我们用了不同的entry或者把类库文件单独打包,必须使用chunkhash.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run buid</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/extract1.png" alt="code"></p><h2 id="第三方类库打包"><a href="#第三方类库打包" class="headerlink" title="第三方类库打包"></a>第三方类库打包</h2><p>第三方类库对比业务代码比较稳定,我们希望浏览器能够长缓存它,所以我们也要讲它们分离出来减少http请求和流量</p><p>先看代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ config.entry = &#123;</div><div class="line">+    app: path.join(__dirname, <span class="string">'./src/index'</span>),</div><div class="line">+    vendor: [<span class="string">'vue'</span>]</div><div class="line">+  &#125;</div><div class="line">  config.output.filename = <span class="string">'[name].[chunkhash:8].js'</span></div><div class="line">  ...</div><div class="line">  </div><div class="line">config.plugins.push(</div><div class="line">    new ExtractPlugin(<span class="string">'styles.[contentHash:8].js'</span>),</div><div class="line">+   new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">+   name: <span class="string">'vendor'</span></div><div class="line">+  &#125;)</div><div class="line">  )</div></pre></td></tr></table></figure><p>我们定了一个新的entry,指定了app和vendor,app是原来打包的入口模块, vendor则是存放第三方库,如vue</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.20.16.png" alt="code"></p><p>我们发现生成app.xxx和vendor.xxx,并且app的体积变小了</p><h2 id="分离webpack相关代码"><a href="#分离webpack相关代码" class="headerlink" title="分离webpack相关代码"></a>分离webpack相关代码</h2><p>使用webpack构建应用程序中,主要有三种代码类型:</p><ul><li>你编写的代码</li><li>代码中依赖的第三方库</li><li>webpack的runtime和manifest</li></ul><p>这里的<u>Manifest</u>不是android里面的manifest.xml。试想一下,当你敲下<u>npm run build</u>之后会生成一个html去承载分离出来的各种资源文件如css,这时候你在里面所引用的绝对路径或者相对路径对应目录都不复存在,webpack就是利用manifest数据来处理所有模块的交互。<br>当浏览器开始执行、解析和映射应用程序时,它会保存所有模块的详细要点,这个数据集合就是<strong>Manifest</strong>,当完成打包应发送给浏览器,会在运行时通过Manifest来解析和加载模块,这时候你代码中的<u>import</u>或者<u>require</u>都会转换为<strong>webpack_require</strong>方法。,通过使用manifest中的数据,<strong>runtime</strong>能够通过ID检索对对应模块,在模块交互的时候,runtime处理内容包括: 链接模块所需的加载和解析逻辑(如浏览器中的已加载模块的连接以及懒加载模块的执行逻辑)</p><blockquote><p>webpack.config.js </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">config.plugins.push(</div><div class="line">  ...</div><div class="line">+   new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">+      name: <span class="string">'runtime'</span></div><div class="line">+   &#125;)</div><div class="line">  )</div></pre></td></tr></table></figure><p>这里把app.js中连接各个模块的webpack代码分离出来, 当有新模块加入,webpack给每个模块加id区分,插入顺序可能会在中间,从而是id发生变化, 这样会使hash值发生变化导致长缓存失效。</p><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.51.17.png" alt="code"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.file.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-16%2022.53.36.png" alt="code"></p><p>好了,一些webpack的基本操作就先写这些, 等后面再更新一篇关于webpack深入高级的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;继上一篇,我们已经做了build操作,但我们只做了webpack的构建工作,它目前并不具备服务器功能,接下来我们先来完善它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webpack-dev-server&quot;&gt;&lt;a href=&quot;#webpac
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>mvvm底层原理及伪代码实现</title>
    <link href="http://yoursite.com/2018/06/06/mvvm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/06/06/mvvm底层原理及伪代码实现/</id>
    <published>2018-06-06T02:10:06.000Z</published>
    <updated>2018-06-08T08:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于mvc、mvp和mvvm 这三者的关系这篇文章不会展开叙述,如果你不了解他们, 暂且可以理解他们的演变过程为mvc -&gt; mvp -&gt; mvvm。写这篇文章的时候,mvvm其实网上已经有很多写的不错的文章,为什么还要写这篇文章,你可以说我是浪费时间,but,我只想站在我的角度把我的思考方式写出来,至于是否已经有人发表过,I don’t give a shit!这篇文章会以<u><strong>Vue</strong></u>的角度来分析,但并不影响另外两个框架的理解, 你懂的~</p></blockquote><h2 id="谈一谈设计模式"><a href="#谈一谈设计模式" class="headerlink" title="谈一谈设计模式"></a>谈一谈设计模式</h2><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/mvvm.png" alt="design"></p><p>mvvm采用的是观察者模式,如图所示, 我们需要监听者(Observer)、观察者列表(Dep)、订阅者(Watcher)这三个身份。</p><table><thead><tr><th>身 份</th><th>职 责</th></tr></thead><tbody><tr><td>监听者(Observer)</td><td>监听ViewModel中Data的变化,并通知观察者列表,但它并不关心观察者列表有是谁从哪来。</td></tr><tr><td>观察者列表(Dep)</td><td>订阅者给了观察者列表一个特殊能力, Data数据一旦变动, 利用这个特殊能力(update)回调给订阅者。</td></tr><tr><td>订阅者(Watcher)</td><td>负责向观察者列表中添加(订阅)列表,并附带buff给它,一旦接收到观察者列表回调回来的data后,就将它更新到View。</td></tr></tbody></table><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>我们先贴上一段代码,如果你是vuer肯定很熟悉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  data: &#123;</div><div class="line">   title: <span class="string">'vue code'</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">   clickMe: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    this.title = <span class="string">'vue code click'</span>;</div><div class="line">   &#125;,</div><div class="line">  &#125;,</div><div class="line">  mounted: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">    window.setTimeout(() =&gt; &#123;</div><div class="line">    this.title = <span class="string">'timeout 1000'</span>;</div><div class="line">   &#125;, 1000);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>下面要介绍Vue双向数据绑定中用到的一个核心Api(<strong>Object.defineProperty()</strong>)去实现数据监听的。它的详细用法我们不会详细展开,如果你不清楚,点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">MDN</a>花个5分钟就知道怎么回事了。</p><p>代码呈上</p><blockquote><p>defineProperty.html</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"input"</span> onchange=<span class="string">"dochange(this)"</span>&gt;</div></pre></td></tr></table></figure><blockquote><p>defineProperty.js</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var data = &#123;name: <span class="string">'lynhao'</span>&#125;;</div><div class="line">observe(data);</div><div class="line"></div><div class="line"><span class="keyword">function</span> observe(data) &#123;</div><div class="line"> <span class="keyword">if</span> (!data || typeof data !== <span class="string">'object'</span>) <span class="built_in">return</span>;</div><div class="line"> // 取出所有属性遍历</div><div class="line"> Object.keys(data).forEach(<span class="keyword">function</span>(key) &#123;</div><div class="line">   defineReactive(data, key, data[key]);</div><div class="line"> &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> defineReactive(data, key, val) &#123;</div><div class="line">  Object.defineProperty(data, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">false</span>,</div><div class="line">    get: <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">     <span class="built_in">return</span> val;</div><div class="line">    &#125;,</div><div class="line">  <span class="built_in">set</span>: <span class="keyword">function</span>(newVal) &#123;</div><div class="line">console.log(<span class="string">'监听到值变化了 '</span>, val, <span class="string">' --&gt; '</span>, newVal);</div><div class="line">val = newVal;</div><div class="line">  &#125;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> dochange(e) &#123;</div><div class="line">  data.name = e.value</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-1-实现监听者"><a href="#2-1-实现监听者" class="headerlink" title="2.1 实现监听者"></a>2.1 实现监听者</h4><p>代码呈上</p><blockquote><p>定义Observer构造函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Observer (data) &#123;</div><div class="line">  this.data = data;</div><div class="line">  this.loop2React(data);  //遍历data</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在Observer原型对象中添加loop2React和defineReactive,实现对data中的属性监听</p></blockquote><ul><li>Observer</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observer.prototype = &#123;</div><div class="line">    loop2React: <span class="keyword">function</span> (data) &#123;</div><div class="line">        var self = this;</div><div class="line">        Object.keys(data).forEach(<span class="keyword">function</span> (key) &#123;</div><div class="line">            self.defineReactive(data, key, data[key]);</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    defineReactive: <span class="keyword">function</span> (data, key, val) &#123;</div><div class="line">        var childObj = observe(val);</div><div class="line">        Object.defineProperty(data, key, &#123;</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            get: <span class="keyword">function</span> <span class="function"><span class="title">getter</span></span> () &#123;</div><div class="line">             <span class="built_in">return</span> val;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> observe (value, vm) &#123;</div><div class="line">    <span class="keyword">if</span> (!value || typeof value !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> new Observer(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="2-1-1-添加观察者列表Dep"><a href="#2-1-1-添加观察者列表Dep" class="headerlink" title="2.1.1 添加观察者列表Dep"></a>2.1.1 添加观察者列表Dep</h5><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">Observer.prototype = &#123;</div><div class="line">    ...省略</div><div class="line">    defineReactive: <span class="keyword">function</span> (data, key, val) &#123;</div><div class="line">  +      var dep = new Dep();</div><div class="line">    /**</div><div class="line">     * var childObj = observe(val); </div><div class="line">     * 通过递归调用observe,可以深度遍历data对象,如</div><div class="line">     * data: &#123;</div><div class="line">     *  category: &#123;</div><div class="line">     *  animal: xxx</div><div class="line">     * &#125;</div><div class="line">     * &#125;</div><div class="line">    **/</div><div class="line">        var childObj = observe(val);</div><div class="line">        Object.defineProperty(data, key, &#123;</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            get: <span class="keyword">function</span> <span class="function"><span class="title">getter</span></span> () &#123;</div><div class="line">               /**</div><div class="line">                * Dep.target其实指向Watcher的实例</div><div class="line">                * 前面我们说过订阅者会添加观察者列表</div><div class="line">                **/</div><div class="line">  +              <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">  +                 dep.addSub(Dep.target);</div><div class="line">  +              &#125;</div><div class="line">                <span class="built_in">return</span> val;</div><div class="line">            &#125;,</div><div class="line">  +          <span class="built_in">set</span>: <span class="keyword">function</span> setter (newVal) &#123;</div><div class="line">  +              <span class="keyword">if</span> (newVal === val) &#123;</div><div class="line">  +                  <span class="built_in">return</span>;</div><div class="line">  +              &#125;</div><div class="line">  +              val = newVal;</div><div class="line">  +              dep.notify(); //data数据变动触发</div><div class="line">  +          &#125;,</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> observe (value, vm) &#123;</div><div class="line">    <span class="keyword">if</span> (!value || typeof value !== <span class="string">'object'</span>) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> new Observer(value);</div><div class="line">&#125; </div><div class="line">+ <span class="keyword">function</span> <span class="function"><span class="title">Dep</span></span> () &#123;</div><div class="line">+    this.subs = [];  //列表</div><div class="line">+ &#125;</div><div class="line">+ Dep.prototype = &#123;</div><div class="line">+    addSub: <span class="keyword">function</span> (sub) &#123;</div><div class="line">+        this.subs.push(sub);</div><div class="line">+    &#125;,</div><div class="line">+    notify: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">+        this.subs.forEach(<span class="keyword">function</span> (sub) &#123;</div><div class="line">+            sub.update();  //update 最终调用的是watcher的回调函数</div><div class="line">+        &#125;);</div><div class="line">+    &#125;</div><div class="line">+ &#125;;</div></pre></td></tr></table></figure><h4 id="2-2-实现订阅者"><a href="#2-2-实现订阅者" class="headerlink" title="2.2 实现订阅者"></a>2.2 实现订阅者</h4><ul><li>Watcher</li></ul><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Watcher (vm, exp, cb) &#123;</div><div class="line">    this.cb = cb;  //回调函数</div><div class="line">    this.vm = vm;</div><div class="line">    this.exp = exp;</div><div class="line">    this.value = this.get();  // 将自己添加到订阅器的操作</div><div class="line">&#125;</div><div class="line">Watcher.prototype = &#123;</div><div class="line">    update: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        this.run();</div><div class="line">    &#125;,</div><div class="line">    run: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        var value = this.vm.data[this.exp];  // 取到最新值</div><div class="line">        var oldVal = this.value;</div><div class="line">        <span class="keyword">if</span> (value !== oldVal) &#123;</div><div class="line">            this.value = value;</div><div class="line">            this.cb.call(this.vm, value, oldVal);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">        Dep.target = this;  // 缓存自己</div><div class="line">        /**</div><div class="line">         *  强制执行监听器里的get函数,把</div><div class="line">         *  this指向了Dep.target,也就是说这个时候订阅者已经</div><div class="line">         *  向Dep中添加了观察者列表</div><div class="line">         *  例如当前我们观察到data中name这个属性,会自动触发</div><div class="line">         *  观察者中监听的getter函数</div><div class="line">         *  </div><div class="line">        **/</div><div class="line">        var value = this.vm.data[this.exp];</div><div class="line">        Dep.target = null;  // 释放自己,确保不会重复添加</div><div class="line">        <span class="built_in">return</span> value;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="实现Compile编译器"><a href="#实现Compile编译器" class="headerlink" title="实现Compile编译器"></a>实现Compile编译器</h2><p>前面的工作只是做了数据层面操作,我们还得将那些data定义的变量解析成数据。</p><p>代码呈上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Compile (el, vm) &#123;</div><div class="line">    this.vm = vm;</div><div class="line">    this.el = document.querySelector(el);</div><div class="line">    this.fragment = null;</div><div class="line">    this.init();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Compile.prototype = &#123;</div><div class="line">    init: function () &#123;</div><div class="line">        if (this.el) &#123;</div><div class="line">            this.fragment = this.nodeToFragment(this.el);</div><div class="line">            this.compileElement(this.fragment);</div><div class="line">            this.el.appendChild(this.fragment);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(&apos;Dom元素不存在&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    nodeToFragment: function (el) &#123;</div><div class="line">        var fragment = document.createDocumentFragment();</div><div class="line">        var child = el.firstChild;</div><div class="line">        while (child) &#123;</div><div class="line">            // 将Dom元素移入fragment中</div><div class="line">            fragment.appendChild(child);</div><div class="line">            child = el.firstChild;</div><div class="line">        &#125;</div><div class="line">        return fragment;</div><div class="line">    &#125;,</div><div class="line">    compileElement: function (el) &#123;</div><div class="line">        var childNodes = el.childNodes;</div><div class="line">        var self = this;</div><div class="line">        [].slice.call(childNodes).forEach(function (node) &#123;</div><div class="line">            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</div><div class="line">            var text = node.textContent;</div><div class="line">  //判断是否元素节点还是文本节点以及其他类型的节点</div><div class="line">            if (self.isElementNode(node)) &#123;</div><div class="line">                self.compile(node);</div><div class="line">            &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</div><div class="line">                self.compileText(node, reg.exec(text)[1]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</div><div class="line">                self.compileElement(node);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>考虑到初始化是页面渲染带来的重绘和重排带来的性能问题,这里我们用到document.createDocumentFragment去创建了一个虚拟节点,我们知道DocumentFragment是不属于文档流的,但它却拥有其他创建dom节点的方法。</p><ul><li>compile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">compile: function (node) &#123;</div><div class="line">        var nodeAttrs = node.attributes;</div><div class="line">        var self = this;</div><div class="line">        Array.prototype.forEach.call(nodeAttrs, function (attr) &#123;</div><div class="line">            var attrName = attr.name;</div><div class="line">            //判断是否是指令,例如v-text</div><div class="line">            if (self.isDirective(attrName)) &#123;</div><div class="line">                var exp = attr.value;</div><div class="line">                var dir = attrName.substring(2);</div><div class="line">                if (self.isEventDirective(dir)) &#123;  // 事件指令</div><div class="line">                    self.compileEvent(node, self.vm, exp, dir);</div><div class="line">                &#125; else &#123;  // v-model 指令</div><div class="line">                    self.compileModel(node, self.vm, exp, dir);</div><div class="line">                &#125;</div><div class="line">                node.removeAttribute(attrName);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>剩余代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Compile.prototype = &#123;</div><div class="line">     ...省略</div><div class="line">      compileText: function (node, exp) &#123;</div><div class="line">        var arr = exp.split(&apos;.&apos;)</div><div class="line">        var self = this;</div><div class="line">        /**深度遍历,例如:</div><div class="line">         * &#123; </div><div class="line">         *   data: &#123;</div><div class="line">         *     a: &#123;</div><div class="line">         *       b: &quot;c&quot;</div><div class="line">         *     &#125;</div><div class="line">         *   &#125;</div><div class="line">         * &#125;</div><div class="line">        **/</div><div class="line">        </div><div class="line">        var _vm = this.vm</div><div class="line">        for(let i=0; i&lt;arr.length; i++) &#123;</div><div class="line">            _vm = _vm[arr[i]]</div><div class="line">        &#125;</div><div class="line">        var initText = _vm[exp];</div><div class="line">        this.updateText(node, initText);</div><div class="line">        new Watcher(this.vm, exp, function (value) &#123;</div><div class="line">            self.updateText(node, value);</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    compileEvent: function (node, vm, exp, dir) &#123;</div><div class="line">        var eventType = dir.split(&apos;:&apos;)[1];</div><div class="line">        var cb = vm.methods &amp;&amp; vm.methods[exp];</div><div class="line"></div><div class="line">        if (eventType &amp;&amp; cb) &#123;</div><div class="line">            node.addEventListener(eventType, cb.bind(vm), false);</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    compileModel: function (node, vm, exp, dir) &#123;</div><div class="line">        var self = this;</div><div class="line">        var val = this.vm[exp];</div><div class="line">        this.modelUpdater(node, val);</div><div class="line">        new Watcher(this.vm, exp, function (value) &#123;</div><div class="line">            self.modelUpdater(node, value);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        node.addEventListener(&apos;input&apos;, function (e) &#123;</div><div class="line">            var newValue = e.target.value;</div><div class="line">            if (val === newValue) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            self.vm[exp] = newValue;</div><div class="line">            val = newValue;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    updateText: function (node, value) &#123;</div><div class="line">        node.textContent = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class="line">    &#125;,</div><div class="line">    modelUpdater: function (node, value, oldValue) &#123;</div><div class="line">        node.value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class="line">    &#125;,</div><div class="line">    isDirective: function (attr) &#123;</div><div class="line">        return attr.indexOf(&apos;v-&apos;) == 0;</div><div class="line">    &#125;,</div><div class="line">    isEventDirective: function (dir) &#123;</div><div class="line">        return dir.indexOf(&apos;on:&apos;) === 0;</div><div class="line">    &#125;,</div><div class="line">    isElementNode: function (node) &#123;</div><div class="line">        return node.nodeType == 1;</div><div class="line">    &#125;,</div><div class="line">    isTextNode: function (node) &#123;</div><div class="line">        return node.nodeType == 3;</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="实例化MVVM"><a href="#实例化MVVM" class="headerlink" title="实例化MVVM"></a>实例化MVVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Vue (options) &#123;</div><div class="line">    var self = this;</div><div class="line">    this.data = options.data;</div><div class="line">    this.methods = options.methods;</div><div class="line"></div><div class="line">    observe(this.data);</div><div class="line">    new Compile(options.el, this);</div><div class="line">    options.mounted.call(this); // 所有事情处理好后执行mounted函数</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>测试代码</p></blockquote><ul><li>index.js</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">       el: <span class="string">'#app'</span>,</div><div class="line">       data: &#123;</div><div class="line">           title: <span class="string">'hello mvvm'</span></div><div class="line">         &#125;,</div><div class="line">         methods: &#123;</div><div class="line">           clickMe: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">               this.title = <span class="string">'mvvm click'</span>;</div><div class="line">           &#125;,</div><div class="line">       &#125;,</div><div class="line">       mounted: <span class="function"><span class="title">function</span></span> () &#123;</div><div class="line">           window.setTimeout(() =&gt; &#123;</div><div class="line">               this.title = <span class="string">'timeout 1000'</span>;</div><div class="line">           &#125;, 1000);</div><div class="line">       &#125;,</div><div class="line">   &#125;);</div></pre></td></tr></table></figure><p>index.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">       &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</div><div class="line">       &lt;input v-model=<span class="string">"name"</span>&gt;</div><div class="line">       &lt;button v-on:click=<span class="string">"clickMe"</span>&gt;click me!&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><blockquote><p>此处为效果图</p></blockquote><p><img src="http://picturegit-1251927503.file.myqcloud.com/blog/mvvm.gif" alt="mvvm"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于mvc、mvp和mvvm 这三者的关系这篇文章不会展开叙述,如果你不了解他们, 暂且可以理解他们的演变过程为mvc -&amp;gt; mvp -&amp;gt; mvvm。写这篇文章的时候,mvvm其实网上已经有很多写的不错的文章,为什么还要写这篇文章,你可
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>原型链深入透彻全面释疑及应用</title>
    <link href="http://yoursite.com/2018/05/20/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B7%B1%E5%85%A5%E9%80%8F%E5%BD%BB%E5%85%A8%E9%9D%A2%E9%87%8A%E7%96%91%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/20/原型链深入透彻全面释疑及应用/</id>
    <published>2018-05-20T03:22:41.000Z</published>
    <updated>2018-09-11T15:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开始文章之前,大家先自查对原型链的认知到哪里?能否给自己讲清楚原型、构造函数、实例对象、原型链的概念以及他们彼此的联系,还有经常用的instanceof背后原理是否理解,等看完整篇文章后再回头看看这段话,看看对他们的理解是否有进一步加深</p></blockquote><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>什么是原型,我觉得可以这么通俗去理解,只要它是对象,它就有属于它的原型。用代码解释我觉得应该可以让大脑更容易理解并记忆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;</div><div class="line">  this.name = <span class="string">'foo'</span></div><div class="line">&#125;</div><div class="line">var foo = new Foo()</div></pre></td></tr></table></figure><p>这段代码再常见不过,我们定义了一个Foo函数,然后实例化,你能快速指出哪个是实例对象和构造函数器吗?</p><blockquote><p>《在你不知道的JS》一书中,作者说了js其实不像其他oop语言一样会有构造函数,准确说应该是构造函数调用。</p></blockquote><p>是的,我们通过new的方式创建对象,这时<strong>Foo()</strong>就是构造函数,而foo就是实例对象,你答对了吗?也许你有个疑问,为什么new就可以创建一个对象?这个问题我们后面再会解释</p><h3 id="1-1-原型对象"><a href="#1-1-原型对象" class="headerlink" title="1.1 原型对象"></a>1.1 原型对象</h3><p><img src="http://picturegit-1251927503.file.myqcloud.com/prototype.png" alt="bower_gulp"></p><p>如上图,如果你看懂了,原型链这块你就已经掌握了,就没必要看下去了,或者你想挑刺也行</p><p>首先原型对象的好处在于它可以让所以的对象实例共享它所包含的属性和方法,换句话就是我们不用再构造函数中重复定义对象实例的信息</p><p>不推荐的代码呈上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Cat(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> this.eat = eat</div><div class="line">&#125;</div><div class="line">function eat() &#123;</div><div class="line"> console.log(this.food)</div><div class="line">&#125;</div><div class="line">function Dog(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> this.eat = eat</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将eat函数添加到原型对象上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Animal() &#123;&#125;</div><div class="line">Animal.prototype.eat = function() &#123;</div><div class="line"> console.log(this.food)</div><div class="line">&#125;</div><div class="line">function Cat(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> Animal.call(this, this.food)</div><div class="line">&#125;</div><div class="line">function Dog(food) &#123;</div><div class="line"> this.food = food</div><div class="line"> Animal.call(this, this.food)</div><div class="line">&#125;</div><div class="line">Cat.prototype = new Animal()</div><div class="line">Dog.prototype = new Animal()</div></pre></td></tr></table></figure><p>如果看不懂或者因代码量变多而困惑也没关系,你只要先知道原型对象是干啥用就行,至于为什么这么写后面我们会详细讲解。</p><p>构造函数和实例是如何联系?</p><ul><li>通过new关键字创建对象</li></ul><p>js引擎会给每个构造函数都添加一个<strong>prototype</strong>对象,我们通过Function.prototype就可以访问到原型对象,同理,实例对象也有一个访问原型对象的的属性__proto__,如前面那段代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo.__proto__ === Foo.prototype //<span class="literal">true</span></div></pre></td></tr></table></figure><p>如果对象有继承关系我们怎么去区分它的原型对象指向那个构造函数呢?<strong>constructor</strong>就是来做这件事</p><h3 id="1-2-原型链原理"><a href="#1-2-原型链原理" class="headerlink" title="1.2 原型链原理"></a>1.2 原型链原理</h3><p>原型链常作为实现继承的主要方法,前面说过,每个构造函数都有自己的原型对象,原型对象都有一个指向构造函数的指针,而实例对象都包含一个(__proto__)指向原型对象的内部。那么如果让原型对象指向另一个类型的实例对象,很显然原型对象将包含一个指向另一个原型的指针,另一个原型也包含一个指向另一个构造函数的指针,层层递进就成为了<strong>原型链</strong>,注意,访问一个实例的时候, 如果在实例本身没有找到调用的属性或者方法, 它会通过__proto__向原型对象上找,如果找不到,继续往上一个原型对象里面的__proto__找,直到Object.prototype,如果找不到则原路返回 。</p><p>如下面代码,我们通过实例对象去访问category对象上的name,因为实例本身并没有name,所有它会通过原型链往上找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Cat(food) &#123;</div><div class="line">  this.food = food</div><div class="line">&#125;</div><div class="line">Cat.prototype.eat = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(this.food)</div><div class="line">&#125;</div><div class="line">Cat.prototype.category = &#123;</div><div class="line">  name: <span class="string">"animal"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">let</span> cat = new Cat(<span class="string">"fish"</span>)</div><div class="line">cat.category.name</div></pre></td></tr></table></figure><h3 id="1-3-instanceof-原理"><a href="#1-3-instanceof-原理" class="headerlink" title="1.3 instanceof 原理"></a>1.3 instanceof 原理</h3><p>我们经常用<strong>instanceof</strong>去判断对象类型,实质上它是判断实例对象的__proto__跟构造函数.prototype 是不是同一个引用</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p> js有哪几种创建对象方式?给你3秒钟想想</p><p> …</p><p> …</p><p> …</p><p>时间到,答案是3种</p><ol><li>字面量创建</li><li>构造函数</li><li>Object.create()</li></ol><h3 id="2-1-字面量创建"><a href="#2-1-字面量创建" class="headerlink" title="2.1 字面量创建"></a>2.1 字面量创建</h3><p>通过直接声明对象的方式比较常见,这里直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;name: &apos;o1&apos;&#125;;</div><div class="line">var o2 = new Object(&#123;name: &apos;o2&apos;&#125;);</div></pre></td></tr></table></figure><h3 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h3><p>前面我们提到到通过普通函数如何通过<strong>new</strong>关键字”处理”后它就升级为构造函数,那么new背后做了什么操作呢?</p><p> new原理:</p><ul><li>第一步: 创建一个空对象,[继承]构造函数的原型对象</li><li>第二步: 执行构造函数,上下文(this)指向新的实例</li><li>第三步: 判断是否有返回值,如果返回对象,这返回,如果不是,则返回关联构造函数对象</li></ul><blockquote><p>伪代码实现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var _new = <span class="keyword">function</span>(cst) &#123;</div><div class="line">  var obj = Object.create(cst.prototype)</div><div class="line">  var o = cst.call(obj)</div><div class="line">  <span class="keyword">if</span>(o.constructor === Object) &#123;</div><div class="line">   <span class="built_in">return</span> o</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">return</span> obj</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-Object-create"><a href="#2-3-Object-create" class="headerlink" title="2.3 Object.create()"></a>2.3 Object.create()</h3><p><strong>Object.create()</strong>这种对象的方式我觉得你应该很少用,但你有想过它背后的工作原理,或者说它创建对象的过程都做什么?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aa = Object.create(a)</div></pre></td></tr></table></figure><ul><li>释疑</li></ul><p>Object.create会创建一个新对象的原型对象赋值给aa</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aa.__proto__ === a</div></pre></td></tr></table></figure><p>aa本身是个空对象,要访问a上的属性 也通过__proto__ 去访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var p = &#123;name: <span class="string">'p'</span>&#125;</div><div class="line">var o = Object.create(p)</div><div class="line"></div><div class="line">o.__proto__.name // <span class="string">'p'</span></div></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>在原生js中,一般继承有两种方式</p><ol><li>通过call/apply 改变this指针</li><li>通过原型链继承</li></ol><h3 id="3-1-借用构造函数实现继承"><a href="#3-1-借用构造函数实现继承" class="headerlink" title="3.1 借用构造函数实现继承"></a>3.1 借用构造函数实现继承</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"></div><div class="line">new Child().type // <span class="string">'one'</span></div></pre></td></tr></table></figure><p>缺点: <strong>只能继承构造函数上的属性和方法,不能访问父类原型对象上的属性或方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'group'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"><span class="built_in">let</span> child = new Child()</div><div class="line">child.hasOwnProperty(<span class="string">'group'</span>) // <span class="literal">false</span></div></pre></td></tr></table></figure><h3 id="3-2-继承原型链实现继承"><a href="#3-2-继承原型链实现继承" class="headerlink" title="3.2 继承原型链实现继承"></a>3.2 继承原型链实现继承</h3><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'group'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent()</div><div class="line"><span class="built_in">let</span> child = new Child()</div><div class="line">child.type   // <span class="string">'one'</span></div><div class="line">child.hasOwnProperty(<span class="string">'group'</span>)  //<span class="literal">true</span></div></pre></td></tr></table></figure><p>缺点: <strong>原型链被污染</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype.group = [1,2,3]</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent()</div><div class="line"><span class="built_in">let</span> child1 = new Child()</div><div class="line"><span class="built_in">let</span> child2 = new Child()</div><div class="line">child1.group.push(<span class="string">'4'</span>) // [1, 2, 3, 4]</div><div class="line">child2.group // [1, 2, 3, 4]</div></pre></td></tr></table></figure><p>可以看到,我们分别实例化了两个对象child1和child2,我们只希望在child1添加一个元素,但child2的表现出乎我们意料.为什么呢? 因为new这个操作实际上this指向了被实例的对象上,所以从原型链的角度child1和child2都指向Child的原型对象上</p><h3 id="3-3-组合方式"><a href="#3-3-组合方式" class="headerlink" title="3.3 组合方式"></a>3.3 组合方式</h3><p>结合前面两种继承方式实现功能互补</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">    Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line"><span class="built_in">let</span> child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line"></div><div class="line">child1.group.push(<span class="string">'4'</span>) ;</div><div class="line">// Child &#123;<span class="built_in">type</span>: <span class="string">"one"</span>, group: Array(4)&#125;</div><div class="line">child2.group ;</div><div class="line">// Child &#123;<span class="built_in">type</span>: <span class="string">"one"</span>, group: Array(3)&#125;</div></pre></td></tr></table></figure><p>似乎问题得到解决,我们通过实例化构造函数生成两个不同地址的实例,同时又拥有相同的实例属性。细心的你可能已经发现我把group声明在构造函数,那么如果将它添加到原型链上呢是否还可以呢? 你可以暂停阅读先自己去试试</p><p>同样,上面的写法也有缺点: <strong>在子类构造函数执行父类构造函数,没法判断子类的构造函数</strong></p><h3 id="3-4-组合方式优化"><a href="#3-4-组合方式优化" class="headerlink" title="3.4 组合方式优化"></a>3.4 组合方式优化</h3><p>上面那种组合方式,我们在new Child的时候,父类的构造函数被调用了两次,但其实这是多余的.</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = Parent.prototype;</div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div></pre></td></tr></table></figure><p>恩,同样虽然解决多次(2次)调用父类构造函数问题后,它同样存在瑕疵: <strong>没法判断子类的构造函数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line">Child.prototype = Parent.prototype;</div><div class="line"><span class="built_in">let</span> child1 = new Child();</div><div class="line"><span class="built_in">let</span> child2 = new Child();</div><div class="line"></div><div class="line">child1 instanceof Child  //<span class="literal">true</span></div><div class="line">child1 instanceof Parent //<span class="literal">true</span></div></pre></td></tr></table></figure><h3 id="3-5-组合方式再优化"><a href="#3-5-组合方式再优化" class="headerlink" title="3.5 组合方式再优化"></a>3.5 组合方式再优化</h3><p><img src="http://picturegit-1251927503.file.myqcloud.com/prototype.png" alt="bower_gulp"></p><p>不知道你对前面这张原型链还有没印象, 我们说通过<strong>constructor</strong>来区分原型对象的构造函数</p><p>代码呈上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</div><div class="line">  this.type = <span class="string">'one'</span></div><div class="line">  this.group = [1,2,3]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</div><div class="line">  Parent.call(this)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = Object.create(Parent.prototype);</div><div class="line">Child.prototype.constructor = Child; //弥补重写原型丢失的constructor</div><div class="line"></div><div class="line">var child1 = new Child();</div><div class="line">var child2 = new Child();</div><div class="line"></div><div class="line">child1.__proto__.constructor === Child //<span class="literal">true</span></div><div class="line">child1.__proto__.constructor === Parent //<span class="literal">false</span></div></pre></td></tr></table></figure><p>有人把这种方式叫做<strong>寄生组合方式继承</strong>,它优点在于弥补前面几种继承方式的缺点,高效体现在只调用了一次父函数,避免了在子函数原型对象上创建多余属性,同时原型链又保持”干净”不变.</p><blockquote><p>好了,原型链这块的所以知识点就这么多了,不知道你看完大脑有没有回路呢?</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;开始文章之前,大家先自查对原型链的认知到哪里?能否给自己讲清楚原型、构造函数、实例对象、原型链的概念以及他们彼此的联系,还有经常用的instanceof背后原理是否理解,等看完整篇文章后再回头看看这段话,看看对他们的理解是否有进一步加深&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>{}+{} in Javascript</title>
    <link href="http://yoursite.com/2018/05/17/in-Javascript/"/>
    <id>http://yoursite.com/2018/05/17/in-Javascript/</id>
    <published>2018-05-17T07:37:48.000Z</published>
    <updated>2018-06-02T05:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>【译】by lynhao</p><blockquote><p>涉及Javascript专有名词考虑不影响理解均不作翻译</p></blockquote><p>最近,Gary Bernhardt在”Wat”的闪电讲座上指出Javascript的一个有趣的怪癖:当你添加对象或者数组的时候会得到意想不到的结果.这篇文章解释了这些结果</p><p>在javascript中添加常用的规则很简单:你只能添加数字和字符串,其他类型的值将会转换成他们其中的一种,为了理解它的转换的工作原理,我们首先需要先了解其他一些事情.每当提到段落（如§9.1）时,它就是指代ECMA-262语言标准（ECMAScript 5.1）。</p><p>让我们先从一个快速的复习开始.javascript有两种类型:primitives(基元) and objects(对象),原始类型包括:undefined,null, booleans,numbers,和strings,除此之外其他值都是对象,包括了数组和函数</p><a id="more"></a><h2 id="1-转换值"><a href="#1-转换值" class="headerlink" title="1.转换值"></a>1.转换值</h2><p>加号运算符执行三种转换:  把值转换为<em>primitives</em>, <em>numbers</em>和<em>strings</em></p><h3 id="1-1-通过ToPrimitive-将值转化为primitives"><a href="#1-1-通过ToPrimitive-将值转化为primitives" class="headerlink" title="1.1 通过ToPrimitive()将值转化为primitives"></a>1.1 通过ToPrimitive()将值转化为primitives</h3><pre><code>ToPrimitive(input, PreferredType?)</code></pre><p>可选参数<em>PreferredType</em>是Number 或 String。它只是表示一种<br>偏好, 结果总是可以是任何原始值。如果PreferredType是Number,则执行以下步骤来转换输入的值(§9.1):</p><ol><li>如果输入是原始类型, 则直接返回它</li><li>否者, 输入的值是一个对象, 则调用obj.valueOf().如果结果返回是原始类型,则返回</li><li>否者,调用obj.toString. 如果结果是一个原始类型,则返回</li><li>否者,抛出一个TypeError异常</li></ol><p>如果PreferredType 是String, 2和3步骤交换.如果缺失PreferredType, 那么对于Date的实例设置为String, 其他的值设置为Number</p><h3 id="1-2-通过ToNumber-将值转换为数字"><a href="#1-2-通过ToNumber-将值转换为数字" class="headerlink" title="1.2 通过ToNumber()将值转换为数字"></a>1.2 通过ToNumber()将值转换为数字</h3><ul><li>undefined -&gt; NaN</li><li>null -&gt; +0</li><li>boolean -&gt; (  true -&gt; 1, false -&gt; 0 )</li><li>number -&gt; 不需要转换</li><li>string -&gt; 解析字符串中的数字. 例如: “324”-&gt; 324 (译者: 除字符串数字之外都转为 “NaN”)</li></ul><h3 id="1-3通过ToString（）将值转换为字符串"><a href="#1-3通过ToString（）将值转换为字符串" class="headerlink" title="1.3通过ToString（）将值转换为字符串"></a>1.3通过ToString（）将值转换为字符串</h3><ul><li>undefined -&gt; “undefined”</li><li>null -&gt; + “null”</li><li>oolean -&gt; (  true -&gt; “true” , false -&gt; “false” )</li><li>number -&gt; 解析成字符串数字</li><li>string -&gt; 不需要转换</li></ul><h3 id="1-4-小试牛刀"><a href="#1-4-小试牛刀" class="headerlink" title="1.4 小试牛刀"></a>1.4 小试牛刀</h3><p>下面object允许您观察转换过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">      valueOf: function () &#123;</div><div class="line">          console.log(&quot;valueOf&quot;);</div><div class="line">          return &#123;&#125;; // 不是原始类型</div><div class="line">      &#125;,</div><div class="line">      toString: function () &#123;</div><div class="line">          console.log(&quot;toString&quot;);</div><div class="line">          return &#123;&#125;; // 不是原始类型</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>Number作为函数调用(跟构造函数相反)内部调用ToNumber():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; Number(obj)</div><div class="line">valueOf</div><div class="line">toString</div><div class="line">typeError: 不能将object转换成原始类型的值</div></pre></td></tr></table></figure><h2 id="2-加法"><a href="#2-加法" class="headerlink" title="2. 加法"></a>2. 加法</h2><p>给出下面的加法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value1 + value2</div></pre></td></tr></table></figure><p>为了分析上面的表达式, 采取以下步骤(§11.6.1):</p><ol><li>将两个操作符转换为primitives (数学表示法，而不是JavaScript <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">prim1：= ToPrimitive（value1）</div><div class="line">rim2：= ToPrimitive（value2）</div></pre></td></tr></table></figure></li></ol><pre><code>&gt; PreferredType 被忽略因此Number为non-dates,String为dates</code></pre><ol><li>如果prim1或prim2是一个字符串,则将其转换为字符串并返回连接的结果</li><li>否者,将prim1和prim2都转换成数字并返回他们的总和 </li></ol><h3 id="2-1-预期结果"><a href="#2-1-预期结果" class="headerlink" title="2.1 预期结果"></a>2.1 预期结果</h3><p>添加两个数组,一切按预期运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [] + []</div><div class="line">&apos;&apos;</div></pre></td></tr></table></figure><p>首先将[]转换为primitives尝试返回数组本身（this）的valueOf（）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; var arr = [];</div><div class="line">&gt; arr.valueOf() === arr</div><div class="line">true</div></pre></td></tr></table></figure><p>因为返回的结果不是原始类型,紧接着调用toString()返回空字符串(原始类型的值).因此[]+[]返回是两个空字符串联后的结果</p><p>添加数组和对象也符合我们的期望:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [] + &#123;&#125; </div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>补充说明: 将空对象转换成字符串会得到下面的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; String(&#123;&#125;)</div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>之前的结果是””和 ‘[object Object]’ 串联后的返回的。</p><p>更多对象转换为primitives的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 5 + new Number（7）</div><div class="line">12 </div><div class="line">&gt; 6 + &#123;valueOf：function（）&#123;return 2&#125;&#125; </div><div class="line">8 </div><div class="line">&gt;“abc”+ &#123;toString：function（）&#123;return“def”&#125;&#125; </div><div class="line">&apos;abcdef&apos;</div></pre></td></tr></table></figure><h3 id="2-2-意外的结果"><a href="#2-2-意外的结果" class="headerlink" title="2.2. 意外的结果"></a>2.2. 意外的结果</h3><p>如果+的第一个操作符是一个空的对象字面量(如在FireFox的控制台看到的结果)情况就会变得很诡异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + &#123;&#125;</div><div class="line">NaN</div></pre></td></tr></table></figure><p>这里发生了什么?问题在于javascript将第一个{}解析成空的<br>代码块并忽略它.NaN是通过判断+{}(加号后跟第二个{})来计算的.<br>你在这里看到的加号不是二进制的加法运算符而是一个<br>一元前缀运算符,它用与Number()相同方式将其操作符转换<br>成数字.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; +“3.65” </div><div class="line">3.65</div></pre></td></tr></table></figure><p>下面的表达式都是等效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+&#123;&#125;</div><div class="line">   Number(&#123;&#125;)</div><div class="line">   Number(&#123;&#125;.toString())  // &#123;&#125;.valueOf() 不是原始类型的值</div><div class="line">   Number(&quot;[object Object]&quot;)</div><div class="line">   NaN</div></pre></td></tr></table></figure><p>为什么第一个{}被解析成代码块?因为完整的输入值被解析成语句,并且在语句的<br>花括号被解析成开始代码块.因此,你可以通过强制将输入值解析为表达式来解决问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;（&#123;&#125; + &#123;&#125;）</div><div class="line">&apos;[object Object] [object Object]&apos;</div></pre></td></tr></table></figure><p>function或者method的参数也总是被解析成表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; console.log(&#123;&#125; + &#123;&#125;)</div><div class="line">[object Object][object Object]</div></pre></td></tr></table></figure><p>前面解释之后,你应该不再对以下结果感到好奇了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + []</div><div class="line">0</div></pre></td></tr></table></figure><p>再分析一次, 被解析成代码块后跟着+[],以下表达式是等效的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+[]</div><div class="line">   Number([])</div><div class="line">   Number([].toString())  // [].valueOf() 不是原始类型的值</div><div class="line">   Number(&quot;&quot;)</div><div class="line">   0</div></pre></td></tr></table></figure><p>有趣的是,<em>Node.js REPL</em>分析其输入值与<em>Firefox</em>或<em>Chrome</em>不同(它甚至使用与Node.js相同的V8 JavaScript引擎.以下的输入值被解析成表达式结果并没有那么出乎意料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;&#125; + &#123;&#125;</div><div class="line">&apos;[object Object][object Object]&apos;</div><div class="line">&gt; &#123;&#125; + []</div><div class="line">&apos;[object Object]&apos;</div></pre></td></tr></table></figure><p>这样做的好处是更像使用输入值作为console.log()的参数时获得的结果。但它也不像使用输入值作为程序中的语句。</p><h2 id="3-这是什么意思呢？"><a href="#3-这是什么意思呢？" class="headerlink" title="3.这是什么意思呢？"></a>3.这是什么意思呢？</h2><p>在大多数情况下,理解+在javascript运行机制并没有那么难.你只能添加数字或者字符串.</p><p>对象被转换为字符串（如果另一个操作符是字符串）或数字（否则),如果你想合并数组,你需要用一个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; [1, 2].concat([3, 4])</div><div class="line">[ 1, 2, 3, 4 ]</div></pre></td></tr></table></figure><p>Javascript中没有内置的方式去”拼接”(合并)对象.你需要使用库如<em>Underscore</em>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; var o1 = &#123;eeny:1, meeny:2&#125;;</div><div class="line">&gt; var o2 = &#123;miny:3, moe: 4&#125;;</div><div class="line">&gt; _.extend(o1, o2)</div><div class="line">&#123; eeny: 1,</div><div class="line">  meeny: 2,</div><div class="line">  miny: 3,</div><div class="line">  moe: 4 &#125;</div></pre></td></tr></table></figure><p>注意：与Array.prototype.concat（）不同，extend（）修改它的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; o1</div><div class="line">&#123; eeny: 1,</div><div class="line">  meeny: 2,</div><div class="line">  miny: 3,</div><div class="line">  moe: 4 &#125;</div><div class="line">&gt; o2</div><div class="line">&#123; miny: 3, moe: 4 &#125;</div></pre></td></tr></table></figure><p>如果您对操作符有更多兴趣，可以阅读<u>“Fake operator overloading in JavaScript”</u>。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ol><li><strong>JavaScript values: not everything is an object</strong></li></ol><hr><p>原文地址: <a href="http://2ality.com/2012/01/object-plus-object.html" target="_blank" rel="external"><strong>http://2ality.com/2012/01/object-plus-object.html</strong></a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【译】by lynhao&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;涉及Javascript专有名词考虑不影响理解均不作翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近,Gary Bernhardt在”Wat”的闪电讲座上指出Javascript的一个有趣的怪癖:当你添加对象或者数组的时候会得到意想不到的结果.这篇文章解释了这些结果&lt;/p&gt;
&lt;p&gt;在javascript中添加常用的规则很简单:你只能添加数字和字符串,其他类型的值将会转换成他们其中的一种,为了理解它的转换的工作原理,我们首先需要先了解其他一些事情.每当提到段落（如§9.1）时,它就是指代ECMA-262语言标准（ECMAScript 5.1）。&lt;/p&gt;
&lt;p&gt;让我们先从一个快速的复习开始.javascript有两种类型:primitives(基元) and objects(对象),原始类型包括:undefined,null, booleans,numbers,和strings,除此之外其他值都是对象,包括了数组和函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件委托之一二事</title>
    <link href="http://yoursite.com/2018/04/08/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%B9%8B%E4%B8%80%E4%BA%8C%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/04/08/事件委托之一二事/</id>
    <published>2018-04-08T04:03:23.000Z</published>
    <updated>2018-06-01T01:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是指用户或者浏览器自身执行的某种动作, 例如点击事件(click), 鼠标事件(mouseover),按键事件(keyup) 等,为响应某个事件的函数叫做事件处理程序(监听器)</p><h3 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托/代理"></a>事件委托/代理</h3><p>首先之所以需要有时间委托这个概念, 是因为考虑到内存开销和性能优化.试想一下如果我们为了操作一个DOM而到处声明新的引用(对象),会导致增加DOM的访问次数,而JS中函数也是一个对象,对象需要内存空间,所以性能会受影响,如果我们可以在页面生命周期的任何时间点是为它添加事件处理程序,无需等待DOMContentLoaded和load 这两个过程, 并且在同一个范畴内的事件处理程序能够被重用,那么DOM引用减少,内存得到释放,性能就上来.</p><p>所谓的事件委托,是利用了冒泡事件, 通过制定一个处理程序去管理同一类型的事件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=<span class="string">"mylick"</span>&gt;</div><div class="line">&lt;li id=<span class="string">"1"</span>&gt;1&lt;/li&gt;</div><div class="line">&lt;li id=<span class="string">"2"</span>&gt;2&lt;/li&gt;</div><div class="line">&lt;li id=<span class="string">"3"</span>&gt;3&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var list = document.getElementById(<span class="string">'mylick'</span>)</div><div class="line">list.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(event) &#123;</div><div class="line">  var target = event.target.id</div><div class="line">  switch (target) &#123;</div><div class="line">     <span class="keyword">case</span> <span class="string">'1'</span>:</div><div class="line">       alert(1)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     <span class="keyword">case</span> <span class="string">'2'</span>:</div><div class="line">       alert(2)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     <span class="keyword">case</span> <span class="string">'3'</span>:</div><div class="line">       alert(3)</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">     default:</div><div class="line">       <span class="built_in">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure><p>ul下的子元素都公用同一个事件处理程序,这就是事件委托</p><h4 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h4><p>传统的事件处理程序,将一个函数赋值给一个事件处理程序属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.onclick = function () &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h4><p>DOM2 包含<u>addEventLinstener</u>和<u>removeEventLinstener</u>两个处理事件方法,接收三个参数: 事件处理名称, 处理函数 和一个布尔值, true表示采用事件捕获, false表示采用事件冒泡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var handler = function () &#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">btn.addEventListener(&apos;click&apos;, handler, false)</div><div class="line">btn.removeEventListener(&apos;click&apos;, handler, false)</div></pre></td></tr></table></figure><h4 id="IE事件处理"><a href="#IE事件处理" class="headerlink" title="IE事件处理"></a>IE事件处理</h4><p>IE跟DOM有所区别, 它提供了attachEvent和detachEvent 两个事件处理方法,但attachEvent()添加的事件处理都会默认被添加到事件冒泡阶段.<br>跟DOM2不同的是, 第一个参数指定的时间名必须是”on+type”开头,而且,attachEvent事件处理是在全局作用域中执行,而DOM却是在所属元素作用域中执行,这一点要注意.</p><h3 id="跨浏览器限制"><a href="#跨浏览器限制" class="headerlink" title="跨浏览器限制"></a>跨浏览器限制</h3><p>我们可以用polyfill写法来越过浏览器对事件处理的差异,一般做法是提供addHandler和removeHandler这两个Api, 分别传入三个参数: 操作元素, 事件名称, 事件处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">  addHandler: function (ele, type, fn) &#123;</div><div class="line">    if (ele.addEventListener) &#123;</div><div class="line">      ele.addEventListner(type, fn, false)</div><div class="line">    &#125; else if (ele.attachEvent) &#123;</div><div class="line">      ele.attachEvent(&apos;on&apos;+type, fn, false)</div><div class="line">    &#125; else &#123;</div><div class="line">      ele[&apos;on&apos;+type] = fn</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">   removeHandler: function (ele, type, fn) &#123;</div><div class="line">    if (ele.removeEventListener) &#123;</div><div class="line">      ele.removeEventListner(type, fn, false)</div><div class="line">    &#125; else if (ele.detachEvent) &#123;</div><div class="line">      ele.detachEvent(&apos;on&apos;+type, fn, false)</div><div class="line">    &#125; else &#123;</div><div class="line">      ele[&apos;on&apos;+type] = null</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>–<br>参考资料: 红宝书</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h3&gt;&lt;p&gt;事件是指用户或者浏览器自身执行的某种动作, 例如点击事件(click), 鼠标事件(mouseover)
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack渐入佳境</title>
    <link href="http://yoursite.com/2018/04/03/webpack%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/"/>
    <id>http://yoursite.com/2018/04/03/webpack渐入佳境/</id>
    <published>2018-04-02T16:22:13.000Z</published>
    <updated>2018-08-21T14:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只会使用CLI,技术永远得不到提升,既然你看到这篇文章说明你渴望学习到webpack更多干货,不讲太多废话,直接进入主题,此文假设您已经具备一定的前端基础,至少知道node是什么玩意就行.</p></blockquote><a id="more"></a><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir wpDemo   //新建目录</div><div class="line">npm init       //初始化工程</div></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm i vue -S</div><div class="line">npm i webpack@3.10.0 vue-loader css-loader vue-template-compiler -D</div></pre></td></tr></table></figure><ul><li>这里我们的工程以3.+为示例</li><li>-D 是指将webpack安装到devDependencies, 因为最终的生产环境并不需要</li><li>-S 会装到dependencies中</li></ul><h2 id="创建src目录"><a href="#创建src目录" class="headerlink" title="创建src目录"></a>创建src目录</h2><p>分别创建App.vue, index.js</p><p>App.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line"> &lt;div id=<span class="string">"app"</span>&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">  <span class="built_in">export</span> default &#123;</div><div class="line">  <span class="function"><span class="title">data</span></span>() &#123;</div><div class="line">   <span class="built_in">return</span> &#123;</div><div class="line">    text: <span class="string">'text'</span></div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style scoped&gt;</div><div class="line"></div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><p>这部分代码只是拿来做模板显示</p><p>index.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import Vue from <span class="string">'vue'</span></div><div class="line">import App from <span class="string">'./app.vue'</span></div><div class="line">const root = document.createElement(<span class="string">'div'</span>)</div><div class="line">document.body.appendChild(root)</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">  render: (h) =&gt; h(App)</div><div class="line">&#125;).<span class="variable">$mount</span>(root)</div></pre></td></tr></table></figure><p>这个将会作为webpack的入口文件, 我们通过声明一个Vue的实例,通过render函数去渲染template模块(App),之后调用$mount()进行编译,将生成的dom节点挂载到root上</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> wpDemo</div><div class="line">touch webpack-config.js</div></pre></td></tr></table></figure><p>这里我们要实现将代码用webpack进行打包,放到dist目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const path = require(<span class="string">'path'</span>)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: path.join(__dirname, <span class="string">'./src/index'</span>),  //指定入口文件</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,   //指定打包后的文件名</div><div class="line">    path: path.join(__dirname, <span class="string">'dist'</span>)  //打包后输出路径</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">test</span>: /\.vue$/,</div><div class="line">        loader: <span class="string">'vue-loader'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>module.rules 我们用来配置它的规则, 告诉webpack要处理哪种类型的文件,这里是以.vue格式类型文件, 再指定对应的loader去解析它, 因为我们的webpack它只认识javascript,不认得vue</p></blockquote><h2 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h2><p>package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure><p>这样我们就可以通过下面命令去打包项目,最终生成dist,里面存放我们指定的”bundle.js”文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run build</div></pre></td></tr></table></figure><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/lynhao/wpDemo" target="_blank" rel="external"><strong>源码地址</strong></a></h2><p>NOT EDN~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;只会使用CLI,技术永远得不到提升,既然你看到这篇文章说明你渴望学习到webpack更多干货,不讲太多废话,直接进入主题,此文假设您已经具备一定的前端基础,至少知道node是什么玩意就行.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread之源码完全解析</title>
    <link href="http://yoursite.com/2018/03/19/HandlerThread%E4%B9%8B%E6%BA%90%E7%A0%81%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/03/19/HandlerThread之源码完全解析/</id>
    <published>2018-03-19T08:36:32.000Z</published>
    <updated>2018-06-01T01:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文是我还在学校[2016-06-28]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在正文开始之前如果你对Handler还存有疑惑，建议先看看我的另一篇文章<strong><u>从源码角度分析Handler、Looper、MessageQueue三角关系</u></strong>再继续看下去，如果已经有了一定的了解了，接下来这篇文章读起来将会很轻松哒~</p><p>在开始HandlerThread源码之前我们先写一个与线程相关的Handler</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><ul><li>time.xml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    android:orientation=<span class="string">"vertical"</span></div><div class="line">    &gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=<span class="string">"@+id/id_textview"</span></div><div class="line">        android:text=<span class="string">"正在加载..."</span></div><div class="line">        android:layout_width=<span class="string">"wrap_content"</span></div><div class="line">        android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">        android:paddingTop=<span class="string">"100dp"</span></div><div class="line">        android:textSize=<span class="string">"15sp"</span>/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure><p>布局很简单，一个TextView去展示界面</p><ul><li>TimeActivity.java</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by linhao on 16/6/26.</div><div class="line"> */</div><div class="line">public class TimeActivity extends Activity &#123;</div><div class="line">    private TextView textView;</div><div class="line">    private static int MSG_UPDATE_INFO = 1;</div><div class="line"></div><div class="line">    class MyThread extends Thread&#123;</div><div class="line">        public  Handler mhandler ;</div><div class="line">        public Looper looper;</div><div class="line">        @Override</div><div class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">            super.run();</div><div class="line">            Looper.prepare();</div><div class="line">            looper = Looper.myLooper();</div><div class="line">            mhandler = new <span class="function"><span class="title">Handler</span></span>()&#123;</div><div class="line">                @Override</div><div class="line">                public void handleMessage(Message msg) &#123;</div><div class="line">                    super.handleMessage(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private MyThread myThread;</div><div class="line">    //创建主线程handler</div><div class="line">    private Handler mHandler = new Handler();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        <span class="built_in">set</span>ContentView(R.layout.block);</div><div class="line">        textView = (TextView) findViewById(R.id.id_textview);</div><div class="line">        //创建后台线程</div><div class="line"></div><div class="line">        initBackThread();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private void <span class="function"><span class="title">initBackThread</span></span>() &#123;</div><div class="line">        myThread = new MyThread();</div><div class="line">        myThread.start();</div><div class="line"></div><div class="line">        myThread.mhandler = new Handler(myThread.looper)&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                checkForUpdate();</div><div class="line">                myThread.mhandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    private void <span class="function"><span class="title">checkForUpdate</span></span>() &#123;</div><div class="line">        //模拟耗时操作</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">            mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">                @Override</div><div class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">                    Date date = new Date();</div><div class="line">                    DateFormat today = new SimpleDateFormat(<span class="string">"yyyy年MM月dd日 hh时mm分ss秒 EE"</span>, Locale.CHINA);</div><div class="line">                    textView.setText(today.format(date));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onResume</span></span>() &#123;</div><div class="line">        super.onResume();</div><div class="line">        myThread.mhandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onPause</span></span>() &#123;</div><div class="line">        super.onPause();</div><div class="line">        myThread.mhandler.removeMessages(MSG_UPDATE_INFO);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    protected void <span class="function"><span class="title">onDestroy</span></span>() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码我们定义一个内部类MyThread，紧接着通过<u>looper = Looper.myLooper()</u>拿到储存在sThreadLocal的Looper实例,如果这里听不懂的话建议回头看看从源码角度分析Handler、Looper、MessageQueue三角关系这篇文章,重写handleMessage最后调用Looper的loop方法，从MessageQueue中去取消息。定义一个checkForUpdate方法模拟从服务器解析数据，通过post方法创建一个线程，最后在run方法里面更新UI，模拟时钟。</p><blockquote><p>咳咳,这里我得先打住,有谁看到这段代码以为是创建了一个线程请举个手(yo~put ur hands up🙌)！！！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我告诉你其实什么线程都没有被创建，请看源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean post(Runnable r)</div><div class="line">&#123;</div><div class="line">   <span class="built_in">return</span>  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>是不是觉得这几行代码很亲切呢，继续看下去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static Message getPostMessage(Runnable r) &#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="built_in">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，getPostMessage将Runnable的对象r复制给了Message的callback。回头看看sendMessageDelayed是不是很熟悉呢？没错，跟handler的sendMessageDelayed一模一样。我们再看看下面这段代码  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != null) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们拿到Looper对象后通过Looper.loop()方法在MessageQueue中不断轮回拿取数据，然后回调msg.target.dispatch(…),这里通过判断msg.callback是否为空，如果不为空就执行回调方法handleCallback(msg),而在前面我们已经给callback赋值了，就是<strong>Runnable</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static void handleCallback(Message message) &#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>紧接着调用run方法在里面更新我们的UI代码，代码其实就这些，一点也不复杂是不是？<br>插叙就这么多，接着我们打开模拟器Genymotion运行下我们的代码</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/andr1.jpg?raw=true" alt="stack"></p><p>我们发现程序奔溃了，正常思维我们看看日志报什么错误</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/errorCut/andr.jpg?raw=true" alt="stack"></p><p>日志报了个RuntimeException空指针错误，为什么呢？我们再看看这行代码myThread.mhandler = new Handler(myThread.looper)，我们传入新建的thread的looper，这里涉及到了线程并发的问题因为两个线程交叉运行当编译器运行到这段代码时但此时的looper却没被创建就会报出空指正的问题。那我们改如何避免这个问题呢？很幸运google已经帮我事先考虑到了，所以才有了HandlerThread，下面修改下代码，仅两处</p><ul><li>1、定义一个HandlerThread和Handler</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private HandlerThread mCheckMsgThread;</div><div class="line">private Handler mCheckHandler;</div></pre></td></tr></table></figure><p>这里我们不再需要MyThread这个类了，在initBackThread方法内实例化HandlerThread</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mCheckMsgThread = new HandlerThread(<span class="string">"随意"</span>);</div><div class="line">mCheckMsgThread.start();</div></pre></td></tr></table></figure><p>HandleThread需要传入有个线程名字，这里随意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mCheckHandler = new Handler(mCheckMsgThread.getLooper())&#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                super.handleMessage(msg);</div><div class="line">                checkForUpdate();</div><div class="line">                mCheckHandler.sendEmptyMessage(MSG_UPDATE_INFO);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>我们重新跑一次程序(掉帧得好厉害，但效果还是看得出来啦~)</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/andr.gif?raw=true" alt="stack"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文是我还在学校[2016-06-28]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从源码角度分析Handler、Looper、MessageQueue三角关系</title>
    <link href="http://yoursite.com/2018/03/19/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Handler%E3%80%81Looper%E3%80%81MessageQueue%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/03/19/从源码角度分析Handler、Looper、MessageQueue三角关系/</id>
    <published>2018-03-19T08:03:18.000Z</published>
    <updated>2018-06-01T01:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文是我还在学校[2016-06-27]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.</p></blockquote><hr><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上次更新已经有一个多星期了，最近忙于找工作所以更新速度有所延迟，最近老是碰壁，但文章咱们还是要更新的。今天我们来讲讲Handler、Looper、MessageQueue三者的那些事，这是上篇，后面我会继续更新我对Handler的理解。Ok，下面进入今天正题。</p><h3 id="💭什么是Handler？它有啥存在价值？"><a href="#💭什么是Handler？它有啥存在价值？" class="headerlink" title="💭什么是Handler？它有啥存在价值？"></a>💭什么是Handler？它有啥存在价值？</h3><blockquote><p><a href=""><strong>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</strong></a></p><p>我把它概括为:handler是一套消息传递机制，我们可以通过通过它来发消息和接收消息</p></blockquote><h3 id="💭我们可以拿它做什么："><a href="#💭我们可以拿它做什么：" class="headerlink" title="💭我们可以拿它做什么："></a>💭我们可以拿它做什么：</h3><ul><li>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.<br>翻译过来就是：可以调度消息和runnable对象作为将来的执行；将被执行在一个不同的线程自己的行动。其实我们最常见的就是通过handler来更新UI。下面我们就开始从源码角度分析Handler、Looper、MessageQueue。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>每个应用程序都是通过ActivityThread创建的，而在这个线程中里面有个main方法</p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/handler.jpg?raw=true" alt="stack"></p><p>我们可以看到在main中有一个Looper.prepareMainLooper(),我们按住cmd+shift+R跳转过去看这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void <span class="function"><span class="title">prepareMainLooper</span></span>() &#123;</div><div class="line">       prepare(<span class="literal">false</span>);</div><div class="line">       synchronized (Looper.class) &#123;</div><div class="line">           <span class="keyword">if</span> (sMainLooper != null) &#123;</div><div class="line">               throw new IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">           &#125;</div><div class="line">           sMainLooper = myLooper();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>单击进入prepare方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里通过<u>判断sThreadLocal.get()判断存储变量是否为空，默认是没有的，所以会调用sThreadLocal.set(new Looper(quitAllowed))创建一个Looper对象。</u>我们继续跟进Looper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到在构造方法中创建了一个MessageQueue(我们称之为消息队列)我们创建了looper对象之后，会通过Looper.loop()去从消息队列中进行消息轮回。紧接着我们单击进入loop这个方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static void <span class="function"><span class="title">loop</span></span>() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == null) &#123;</div><div class="line">        throw new RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    // Make sure the identity of this thread is that of the <span class="built_in">local</span> process,</div><div class="line">    // and keep track of what that identity token actually is.</div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        <span class="keyword">if</span> (msg == null) &#123;</div><div class="line">            // No message indicates that the message queue is quitting.</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        // This must be <span class="keyword">in</span> a <span class="built_in">local</span> variable, <span class="keyword">in</span> <span class="keyword">case</span> a UI event sets the logger</div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != null) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">     <span class="keyword">if</span> (logging != null) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback    );</div><div class="line">        &#125;</div><div class="line">       // Make sure that during the course of dispatching the</div><div class="line">        // identity of the thread wasn<span class="string">'t corrupted.</span></div><div class="line">        final long newIdent = Binder.clearCallingIdentity();</div><div class="line">        if (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, "Thread identity changed from 0x"</div><div class="line">                    + Long.toHexString(ident) + " to 0x"</div><div class="line">                    + Long.toHexString(newIdent) + " while dispatching to "</div><div class="line">                    + msg.target.getClass().getName() + " "</div><div class="line">                    + msg.callback + " what=" + msg.what);</div><div class="line">        &#125;</div><div class="line">     msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面代码第一句的位置我们看到有个myLooper方法，跟进进去我们看到它的返回值是从ThreadLocal存储的Looper实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static @Nullable Looper <span class="function"><span class="title">myLooper</span></span>() &#123;</div><div class="line">    <span class="built_in">return</span> sThreadLocal.get();</div><div class="line">&#125;  </div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != null) &#123;</div><div class="line">       throw new RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);    &#125;</div><div class="line">   sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>final MessageQueue queue = me.mQueue;是拿到looper实例中的消息队列MessageQueue 源码上边已经贴出了</p><p>第三处高亮( for (;;)…)就是消息轮回最关键的部分，可以看到它其实就是一个死循环，并从消息队列中取出消息，如果为空的话就阻塞，不为空的话它会调用第四处高亮位置的代码 msg.target.dispatchMessage(msg)。这里的msg.target其实指的就是handler自己本身，我们使用handler去更新UI，通过sendEmptyMessage发送消息，然后重写handleMessage去回调，这里面底层就是通过msg.target.dispatchMessage去发送的。下面我们看看具体的涉及的源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessage(Message msg)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">return</span> sendMessageDelayed(msg, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; 0) &#123;</div><div class="line">        delayMillis = 0;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一直跳到sendMessageAtTime后拿到mQueue，进行放空判断，最后返回我们期待已久的enqueueMessage方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>msg.target = this;这句代码就是把当前的handler赋值给msg的目标地址，最终调用queue.enqueueMessage将消息发送给handler自己，最终保存到消息队列中去。<br>到这里流程已经很清晰了，首先我们先通过Looper的prepare去创建一个looper对象，该实例中保存了一个MessageQueue给mQueue，紧接着通过Looper的loop方法，通过一个没有任何参数约束的for语句死循环将消息队列中的消息不断轮回，最后调用msg.target.dispatchMessage(msg)</p><p><em>我们回过来看看dispatchMessage</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != null) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="built_in">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也就是为什么我们要重写handleMessage这个方法的原因 ，因为msg.target.dispatchMessage(msg)是最终调用的方法，而msg的值是什么？就是我们之前在enqueueMessage消息队列中储存的信息~<br>最后总结handler、Messagequeue和looper这三者中的三角关系：<br>首先handler负责去发送消息，通过looper进行一对一的绑定【Looper.myLooper()】，然后looper将消息回传给handler，最后handler自己对发送过来消息进行处理。p.s可能你会跟我一样在第一次第一次接触handler有这样的疑惑—为什么我们很多时候没有通过Looper.prepare()和Looper.loop()方法去创建一个Looper对象？如果你还有这个问题的话，请回头看看第一段~<br>ok，这篇文章就先说到这儿，如有哪儿说得不好请麻烦指出不尽感激哈~最后再说一句个人感受：就是每一次用到handler这种异步处理机制都会有不同的认识，大家一起加油吧😊</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文是我还在学校[2016-06-27]那段时间写的文章, 当时记录在公众号中,由于长期没有继续维护,随搬迁至此博客.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018,请抓紧时间</title>
    <link href="http://yoursite.com/2018/02/23/2018-%E8%AF%B7%E6%8A%93%E7%B4%A7%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2018/02/23/2018-请抓紧时间/</id>
    <published>2018-02-23T12:31:21.000Z</published>
    <updated>2018-06-01T01:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时不待人"><a href="#时不待人" class="headerlink" title="时不待人"></a>时不待人</h3><p>明天就要返工了, 难免有点抵触情绪, 我也好久没更新博客了,这篇文章归类为<a href=""><strong>生活类</strong></a>, 我不想在这里写太多我的太多心声, 因为我不想让一些认识我的人但不了解我的人知道或揣摩我的动态, 前几天在扇贝看到一句话, 翻译过来大概意思就是 做事要抓紧,尽快实现它,越拖延实现它的概率越低, 我就是这么一个人, 我有时总会以我只读了两年大学安慰自己, 或者以我才转前端不到一年给自己找借口(我从17年3月份从Java转为web前端), 既然”书”读的少, 那自己就要更加约束自己, 2018, 我有自己的目标, 去年我在工作的之余投入学习的时间不科学, 以至于每到年底总有一种啥都不会的想法, 18年,我希望我能从日常一些小事做起, 例如给自己做饭, 给日常事情安排先后顺序, 这样我就可以少熬夜, 因为熬夜会让人变笨. 好了, 就写到这里, 我并不希望有人看到这篇文章 [当然如果被游客或者爬虫无意看到也无妨, 因为这样的逻辑估计也很难看懂]</p><hr><p><a href=""><strong>Bye</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时不待人&quot;&gt;&lt;a href=&quot;#时不待人&quot; class=&quot;headerlink&quot; title=&quot;时不待人&quot;&gt;&lt;/a&gt;时不待人&lt;/h3&gt;&lt;p&gt;明天就要返工了, 难免有点抵触情绪, 我也好久没更新博客了,这篇文章归类为&lt;a href=&quot;&quot;&gt;&lt;strong&gt;生活类&lt;/s
      
    
    </summary>
    
    
      <category term="person business" scheme="http://yoursite.com/tags/person-business/"/>
    
  </entry>
  
  <entry>
    <title>Charles实现代理</title>
    <link href="http://yoursite.com/2017/08/16/Charles%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2017/08/16/Charles实现代理/</id>
    <published>2017-08-16T13:20:25.000Z</published>
    <updated>2018-06-01T01:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="写文起因"><a href="#写文起因" class="headerlink" title="写文起因"></a>写文起因</h3><blockquote><p>今天早上后端一个同事让我改个页面,我一看很简单,花了几分钟就做完并commit到了git上,过了一会那个同事发扣扣说我改漏了一些东西…..</p></blockquote><a id="more"></a><p>是的,前端日常琐事可真不少,特别是改线上的项目,操作比较麻烦,那有什么方法可以解决这个问题呢?(多此一举题目不是说了…).是的,在win平台上很多前端都用一款抓包工具–<a href="http://www.telerik.com/fiddler" target="_blank" rel="external"><strong>Fiddler</strong></a> ,准确说它是一款代理工具,我们可以将服务器上需要改动的文件映射到本地文件,接着我们就可以在本地做需求修改,并且可以在外网上可以看到你修改的内容,是不是很激动还有这种操作呢,嘿嘿嘿~. But,很遗憾,fiddler在win平台上(基于C#开发)运行很完美但在OSX平台上却诟病诸多,所以今天笔者我发现了在OSX跟fiddler有得一拼的工具–<a href="https://www.charlesproxy.com/" target="_blank" rel="external"><strong>Charles</strong></a></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/charles.png?raw=true" alt="stack"></p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>既然说到这款神器,那就介绍它是如何实现代理的</p><ol><li>设置全局代理,否者你会抓不到包的</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/1.png?raw=true" alt="stack"></p><ol><li>设置匹配规则(这只是个筛选)</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic2.png?raw=true" alt="stack"></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic3.png?raw=true" alt="stack"></p><ol><li>禁用缓存(这个不勾选也不影响), 设置代理的本地路径</li></ol><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic4.png?raw=true" alt="stack"></p><p><img src="https://github.com/lynhao/ImageStorage/blob/master/picture/tools/pic5.png?raw=true" alt="stack"></p><p>好了,通过上面的步骤就已经成功代理了! But, Charles是一款付费软件,试用期官方给了30天, 网上给了好多破解版,有的说把charles.jar替换了就行, 中间涉及到修改osx的安全隐私权限,笔者没有打算尝试这样做,好在,我无意发现有个<a href=""><strong>generous man</strong></a>无私贡献出了他的Registered Name和License Key,这里贴上他的<a href="https://zhile.io" target="_blank" rel="external"><strong>博客</strong></a>地址以示感谢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Charles Proxy License</div><div class="line">// 适用于Charles任意版本的注册码，谁还会想要使用破解版呢。</div><div class="line">// Charles 4.1.3目前是最新版，可用。</div><div class="line">Registered Name: https://zhile.io</div><div class="line">License Key: 48891cf209c6d32bf4</div></pre></td></tr></table></figure><blockquote><p>最后还要声明:尊重版权,尊重劳动成果,但如果有人像那位博主这么慷慨我们也不好拒绝🤗😌🤓</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;写文起因&quot;&gt;&lt;a href=&quot;#写文起因&quot; class=&quot;headerlink&quot; title=&quot;写文起因&quot;&gt;&lt;/a&gt;写文起因&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;今天早上后端一个同事让我改个页面,我一看很简单,花了几分钟就做完并commit到了git上,过了一会那个同事发扣扣说我改漏了一些东西…..&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>mongodb环境搭建(补充)</title>
    <link href="http://yoursite.com/2017/07/18/mongodb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/07/18/mongodb环境搭建/</id>
    <published>2017-07-18T04:59:35.000Z</published>
    <updated>2018-06-01T01:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>这里只做macos环境下搭建,用wins系统同学有兴趣也可以瞧瞧</p></blockquote><p>–<br>mac用户对<a href=""><strong>HomeBrew</strong></a>这个包管理工具应该再熟悉不过,还没有安装的童鞋可以通过下面命令行安装,具体请参照<a href="https://brew.sh/" target="_blank" rel="external"><strong>官网</strong></a>,这里不是我们这篇文章的重点.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div></pre></td></tr></table></figure><h3 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew update</div><div class="line">brew install mongoldb</div></pre></td></tr></table></figure><blockquote><p>这里有必要多说一句,每次执行brew都会默认执行update操作,请确保你已经开启科学上网模式不然速度你懂得,听说国内也有镜像大家可以自行搜索🔍</p></blockquote><p>安装完成你应该会看到类似这样<br><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.13.22.png" alt="stack"></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>打开终端第一个窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ sudo mongod --config /usr/<span class="built_in">local</span>/etc/mongod.conf  //启动配置文件</div></pre></td></tr></table></figure><p>这时服务器会呈现等待状态等待用户连接,接着command+d开启另一个窗口,连接服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ mongo</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.27.42.png" alt="stack"></p><p>最后打开浏览器,mongodb默认端口是27017,输入127.0.0.1:27017或者localhost:27017,你看到下图就表示成功了~</p><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-18%2013.21.23.png" alt="stack"></p><blockquote><p>修改补充  time: <a href=""><strong>2017年07月21日16:19:49</strong></a></p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>3天前说的那种方式可能不能完全你的需求,可能我是一个喜欢折腾的人吧,因为这两天我想自己创建一个项目数据库是单独出来而不是跟之前一样默认创建在<a href=""><strong>/data/db</strong></a>下.同样这篇文章不适用于wins系统,但Linux必须支持</p><h4 id="1-1-通过scons编译"><a href="#1-1-通过scons编译" class="headerlink" title="1.1 通过scons编译"></a>1.1 通过scons编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scons all</div></pre></td></tr></table></figure><p>如果编译不通过可以在官网下载对应编译好的二进制文件,我本地是osx,不用这么麻烦直接下载对应的zip文件解压就行,我用的版本是<a href=""><strong>3.4.6</strong></a>,mac用户如果是用前面说的brew直接安装,编译好的文件会放在这个目录下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/<span class="built_in">local</span>/Cellar/mongodb/3.4.6/</div></pre></td></tr></table></figure></p><p>bin目录有几个是要特别留意的</p><ul><li>mongo </li><li>mongod  </li><li>mongodump</li><li>mongorestore</li><li>mongoexport</li><li>mongoimport</li><li>mongooplog</li></ul><h3 id="创建mongodb-pro"><a href="#创建mongodb-pro" class="headerlink" title="创建mongodb_pro"></a>创建mongodb_pro</h3><p>分别创建四个二级目录,分别保存编译好的文件,配置文件,数据库,日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ mkdir mongodb_pro</div><div class="line">➜  ~ <span class="built_in">cd</span> mongodb_pro</div><div class="line">➜  mongodb_pro mkdir data</div><div class="line">➜  mongodb_pro mkdir <span class="built_in">log</span></div><div class="line">➜  mongodb_pro mkdir conf</div><div class="line">➜  mongodb_pro mkdir bin</div></pre></td></tr></table></figure><ul><li>紧接着把之前下载后编译的mongodb文件复制到bin目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -R -n /usr/<span class="built_in">local</span>/Cellar/mongodb/3.4.6/bin/ bin</div></pre></td></tr></table></figure><ul><li>编写conf配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim mongodb.conf</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">port = 12345   </div><div class="line">dbpath = data</div><div class="line">logpath = log/mongod.log </div><div class="line">fork = true   </div><div class="line"></div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">~</div><div class="line">&quot;mongodb.conf&quot; 5L, 65C</div></pre></td></tr></table></figure><ol><li><p>port:端口</p></li><li><p>dbpath:指明monogod数据存储目录</p></li><li><p>logpath:指明日志存储目录,需要指明一个路径</p></li><li><p>fork:表示linux下表明使用后台进程,但wins无效</p></li></ol><blockquote><p>如果不会使用vim的话可以通过本地文本编辑器</p></blockquote><ul><li>回到根目录启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ ./bin/mongod <span class="_">-f</span> conf/mongodb.conf</div></pre></td></tr></table></figure><p>接着你会看到输出这段信息,表示已经启动</p><blockquote><p>about to fork child process, waiting until server is ready for connections.<br>forked process: 4855<br>child process started successfully, parent exiting</p></blockquote><ul><li>查看data,发现里面已经有数据了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro cd data</div><div class="line">➜  data ls</div><div class="line">WiredTiger</div><div class="line">WiredTiger.lock</div><div class="line">WiredTiger.turtle</div><div class="line">WiredTiger.wt</div><div class="line">WiredTigerLAS.wt</div><div class="line">_mdb_catalog.wt</div><div class="line">collection-0-2146738068862245035.wt</div><div class="line">collection-2-2146738068862245035.wt</div><div class="line">diagnostic.data</div><div class="line">index-1-2146738068862245035.wt</div><div class="line">index-3-2146738068862245035.wt</div><div class="line">index-4-2146738068862245035.wt</div><div class="line">journal</div><div class="line">mongod.lock</div><div class="line">sizeStorer.wt</div><div class="line">storage.bson</div></pre></td></tr></table></figure><ul><li>查看日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro cd ./log</div><div class="line">➜  log ls</div><div class="line">mongod.log</div><div class="line">➜  log tail mongod.log</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017-07-21T15:53:58.140+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T15:53:58.281+0800 I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory &apos;/Users/linhao/mongodb_pro/data/diagnostic.data&apos;</div><div class="line">2017-07-21T15:53:58.388+0800 I INDEX    [initandlisten] build index on: admin.system.version properties: &#123; v: 2, key: &#123; version: 1 &#125;, name: &quot;incompatible_with_version_32&quot;, ns: &quot;admin.system.version&quot; &#125;</div><div class="line">2017-07-21T15:53:58.388+0800 I INDEX    [initandlisten]  building index using bulk method; build may temporarily use up to 500 megabytes of RAM</div><div class="line">2017-07-21T15:53:58.406+0800 I INDEX    [initandlisten] build index done.  scanned 0 total records. 0 secs</div><div class="line">2017-07-21T15:53:58.407+0800 I COMMAND  [initandlisten] setting featureCompatibilityVersion to 3.4</div><div class="line">2017-07-21T15:53:58.407+0800 I NETWORK  [thread1] waiting for connections on port 12345</div></pre></td></tr></table></figure><blockquote><p>最后一句可以看到服务等待端客户端连接,对应端口为12345而不是默认的27017</p></blockquote><p>最后利用bin目录下的mongo客户端连接服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/mongo localhost:12345/<span class="built_in">test</span></div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  mongodb_pro ./bin/mongo localhost:12345/test</div><div class="line">MongoDB shell version v3.4.6</div><div class="line">connecting to: mongodb://localhost:12345/test</div><div class="line">MongoDB server version: 3.4.6</div><div class="line">Server has startup warnings:</div><div class="line">2017-07-21T16:10:19.703+0800 I CONTROL  [initandlisten]</div><div class="line">2017-07-21T16:10:19.703+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017-07-21T16:10:19.704+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017-07-21T16:10:19.704+0800 I CONTROL  [initandlisten]</div></pre></td></tr></table></figure><p>如需关服务,在游标输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><blockquote><p>但这时会报这个错误:shutdown command only works with the admin database; try ‘use admin’</p></blockquote><p>按照提示这样解决:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server should be down...</div><div class="line">2017-07-21T16:10:09.556+0800 I NETWORK  [thread1] trying reconnect to localhost:12345 (127.0.0.1) failed</div><div class="line">2017-07-21T16:10:09.557+0800 W NETWORK  [thread1] Failed to connect to 127.0.0.1:12345, in(checking socket for error after poll), reason: Connection refused</div><div class="line">2017-07-21T16:10:09.557+0800 I NETWORK  [thread1] reconnect localhost:12345 (127.0.0.1) failed failed</div></pre></td></tr></table></figure><hr><p>全文结束😌</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这里只做macos环境下搭建,用wins系统同学有兴趣也可以瞧瞧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;–&lt;br&gt;mac用户对&lt;a href=&quot;&quot;&gt;&lt;strong&gt;HomeBrew&lt;/strong&gt;&lt;/a&gt;这个包管理工具应该再熟悉不过,还没有安装的童鞋可以通过下面命令行安装,具体请参照&lt;a href=&quot;https://brew.sh/&quot;&gt;&lt;strong&gt;官网&lt;/strong&gt;&lt;/a&gt;,这里不是我们这篇文章的重点.&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨Generator高逼格操作</title>
    <link href="http://yoursite.com/2017/07/14/%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8Generator%E9%AB%98%E9%80%BC%E6%A0%BC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/07/14/深入探讨Generator高逼格操作/</id>
    <published>2017-07-14T07:46:39.000Z</published>
    <updated>2018-06-01T01:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>es6 中引入了Generator Function（生成器函数）这个新特性,这篇文章会从以下4个点介绍,文章篇幅会有点长,请备好电源🤖</p></blockquote><ol><li>理解generator✅</li><li>如何用generator特性实现异步请求✅</li><li>generator结合co库实现实现异步请求,自动流程✅</li><li>generator其他应用✅</li></ol><a id="more"></a><h3 id="1-理解Generator"><a href="#1-理解Generator" class="headerlink" title="1.理解Generator"></a>1.理解Generator</h3><p>我们先上段代码,先瞧瞧generator是什么样子,当然你也可以把它叫做<a href=""><strong>生成器</strong></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let tell=function* ()&#123;</div><div class="line">    yield &apos;a&apos;;</div><div class="line">    yield &apos;b&apos;;</div><div class="line">    return &apos;c&apos;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">   let k=tell();</div><div class="line">   </div><div class="line">    k.next()      //&#123;value: &quot;a&quot;, done: false&#125;</div><div class="line">    k.next()      //&#123;value: &quot;b&quot;, done: false&#125;</div><div class="line">    k.next()      //&#123;value: &quot;c&quot;, done: true&#125;</div><div class="line">    k.next()      //&#123;value: undefined, done: true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不知大家有没有见过这种写法,反正我第一次看到也有点懵.首先上面定义了一个<a href=""><strong>function* ()</strong></a>,切记generator并<a href=""><strong>不是函数</strong></a>,它返回的是一个<a href=""><strong>Iterator</strong></a>对象,这个我们下文会解释.这里有必要强调这一点,此外我们还看到<a href=""><strong>yield</strong></a>这个关键字,干什么用的呢,<a href=""><strong>next</strong></a>又是做什么,带着这些困惑我们先看看这段代码是如何运行的</p><ul><li><p>tell()表示创建一个generator对象后,进入”暂停”状态 </p></li><li><p>当调用到next(),会执行yield,返回后面的”a”,返回的value就是它的值,done则表示是否最后一个值,类型是布尔值</p></li><li>当第三次调用next,很明显是最后一个值了,所以返回true,第四次因为压根就找不到值所以返回了’undefined’</li></ul><h4 id="1-1generator传参"><a href="#1-1generator传参" class="headerlink" title="1.1generator传参"></a>1.1generator传参</h4><p>我们也可以在next的时候传递参数,如果看懂了下面的示例相信大家对generator已经有个深刻的理解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">function* paramGenerator() &#123;</div><div class="line">  console.log(yield+&quot;1&quot;);</div><div class="line">  console.log(yield+&quot;2&quot;);</div><div class="line">  console.log(yield+&quot;3&quot;);</div><div class="line">&#125;</div><div class="line">let log = paramGenerator()</div><div class="line">log.next()</div><div class="line">log.next(&quot;a&quot;)</div><div class="line">log.next(&quot;b&quot;)</div><div class="line">log.next(&quot;c&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>恩,给大家10秒钟的时间想想会输出什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">log.next()</div><div class="line">Object &#123;value: 1, done: false&#125;</div><div class="line">log.next(&quot;a&quot;)</div><div class="line"> a</div><div class="line">Object &#123;value: 2, done: false&#125;</div><div class="line">log.next(&quot;b&quot;)</div><div class="line"> b</div><div class="line">Object &#123;value: 3, done: false&#125;</div><div class="line">log.next(&quot;c&quot;)</div><div class="line"> c</div><div class="line">Object &#123;value: undefined, done: true&#125;</div></pre></td></tr></table></figure><blockquote><p>恭喜你答对了,ok,我们来说说为什么会这样输出</p></blockquote><p>首先,当执行第一个next的时候,generator第一个yield被激活,返回了{value: 1, done: false},紧接立刻进入”暂停”状态,第二个next我们传入了字符串a,执行了第一个console.log语句输出了a,接着yield被激活返回{value: 2, done: false},这一点相信大家都没有疑问,接着它又进入”暂停”状态,同理,第三个next我们继续传入参数”b”,执行第二个console语句输出了b,接着yield被激活返回{value: 3, done: false}.当我们执行第四个语句时,首先执行了第三个console输出了c,这时候value已经没有值所以返回”undefined”,done则表示已经是最后一个值所以返回true.</p><h4 id="1-2-generator与Iterator关系"><a href="#1-2-generator与Iterator关系" class="headerlink" title="1.2 generator与Iterator关系"></a>1.2 generator与Iterator关系</h4><p>前面提到了generator返回是一个Iterator对象,而iterator拥有next的方法,所以我们才可以调用.说到了Iterator,这里要提到<a href=""><strong>Symbol.iterator</strong></a>这个es6的数据类型,迭代协议规定了一些内置类型具有默认迭代行为,而其他类型（如Object）不具有(这个其实很好理解,object就是让我们去往它那填充数据,它肯定不知道我们要填充什么类型数据啦~),带有@@iterator方法的内置类型有：</p><ul><li>Array.prototype<a href="">@@iterator</a></li><li>TypedArray.prototype<a href="">@@iterator</a></li><li>String.prototype<a href="">@@iterator</a></li><li>Map.prototype<a href="">@@iterator</a></li><li>Set.prototype<a href="">@@iterator</a></li></ul><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E7%BB%84%E5%9B%BE/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-19%2017.51.18.png" alt="stack"></p><p>说那么多不如举个🌰,see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let arr=[&apos;hello&apos;,&apos;iterator&apos;];</div><div class="line">  let map=arr[Symbol.iterator]();</div><div class="line">  console.log(map.next());  //&#123;value: &quot;hello&quot;, done: false&#125;</div><div class="line">  console.log(map.next());  //&#123;value: &quot;iterator&quot;, done: false&#125;</div><div class="line">  console.log(map.next());  //&#123;value: undefined, done: true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>怎么,看到它的输出是不是觉得很熟悉,没错前面我们generator调用next就是这种格式,同时也印证了generator返回是一个Iterator对象.<br><a href=""><strong>arr[Symbol.iterator]</strong></a>这个写法表示了这个arr对象具备了迭代的能力,那后面的括号是什么意思,表示arr数组调用iterator这个接口,这个接口已经内部实现好了.那么,我们可不可自定义iterator接口呢.恩可以的,同样举个🌰 see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let obj=&#123;</div><div class="line">    start:[1,3,2],</div><div class="line">    end:[7,9,8],</div><div class="line">    [Symbol.iterator]()&#123;</div><div class="line">      let self=this;</div><div class="line">      let index=0;</div><div class="line">      let arr=self.start.concat(self.end);</div><div class="line">      let len=arr.length;</div><div class="line">      return &#123;</div><div class="line">        next()&#123;</div><div class="line">          if(index&lt;len)&#123;</div><div class="line">            return &#123;</div><div class="line">              value:arr[index++],</div><div class="line">              done:false</div><div class="line">            &#125;</div><div class="line">          &#125;else&#123;</div><div class="line">            return &#123;</div><div class="line">              value:arr[index++],</div><div class="line">              done:true</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  for(let key of obj)&#123;</div><div class="line">    console.log(key);  //1,3,2,7,9,8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不知道大家有没有想过,for…of能不能遍历对象呢?答案是不能的,如果你强行要这么做,会报一个<a href=""><strong>obj[Symbol.iterator] is not a function</strong></a>的错误.代码看一下应该就懂我就不再过多解释了哈哈</p><h3 id="2-如何用generator特性实现异步请求"><a href="#2-如何用generator特性实现异步请求" class="headerlink" title="2.如何用generator特性实现异步请求"></a>2.如何用generator特性实现异步请求</h3><blockquote><p>我们先回顾下传统实现异步操作的方式,一般我们会想到<a href=""><strong>回调</strong></a>和<a href=""><strong>事件触发</strong></a>这两种形式.这里我们主要谈论回调函数,事件触发其实就是采用事件驱动模式,通过一个事件触发另一个事件.</p></blockquote><h4 id="2-1传统Ajax实现异步操作"><a href="#2-1传统Ajax实现异步操作" class="headerlink" title="2.1传统Ajax实现异步操作"></a>2.1传统Ajax实现异步操作</h4><ul><li>业务场景: 执行完a后执行b</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let ajax=function(callback)&#123;</div><div class="line">   console.log(&apos;执行a&apos;);</div><div class="line">   setTimeout(function () &#123;</div><div class="line">     callback&amp;&amp;callback.call()</div><div class="line">   &#125;, 1000);</div><div class="line"> &#125;;</div><div class="line"> ajax(function()&#123;</div><div class="line">   console.log(&apos;执行b&apos;);</div><div class="line"> &#125;)</div></pre></td></tr></table></figure><blockquote><p>代码比较简单,但试想如果执行b后还有c,d,e呢?那代码将会很复杂并且难以维护.为了解决这个问题,所以<a href=""><strong>Promise</strong></a>诞生了.</p></blockquote><h4 id="2-2Promise实现异步操作"><a href="#2-2Promise实现异步操作" class="headerlink" title="2.2Promise实现异步操作"></a>2.2Promise实现异步操作</h4><ul><li>直接上代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function()&#123;</div><div class="line">    console.log(&apos;执行a&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000);</div><div class="line">    &#125;)</div><div class="line">  &#125;;</div><div class="line">  ajax().then(function()&#123;</div><div class="line">    console.log(&apos;promise&apos;,&apos;执行b&apos;);</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>promise里面的匿名函数有两个参数<a href=""><strong>resolve</strong></a>和<a href=""><strong>reject</strong></a>,resolve表示表示执行下一步操作,reject当然就是中断操作~;</li><li>ajax().then…. 意思是当执行成功后会调用Promise实例的<a href=""><strong>then</strong></a>方法</li></ol><ul><li>如果后面也需要执行c,d,e…呢,代码如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function()&#123;</div><div class="line">    console.log(&apos;执行a&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">        resolve()</div><div class="line">      &#125;, 1000);</div><div class="line">    &#125;)</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  ajax()</div><div class="line">    .then(function()&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function () &#123;</div><div class="line">       console.log(&apos;执行b&apos;)</div><div class="line">        resolve()</div><div class="line">      &#125;, 2000);</div><div class="line">    &#125;);</div><div class="line">  &#125;)</div><div class="line">    .then(function()&#123;</div><div class="line">    console.log(&apos;执行c&apos;)</div><div class="line">    &#125;)</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>试想一下,如果执行到某一步抛异常了该怎么处理? 代码如下:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let ajax=function(num)&#123;</div><div class="line">    console.log(&apos;执行&apos;);</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">      if(num&gt;5)&#123;</div><div class="line">        resolve()</div><div class="line">      &#125;else&#123;</div><div class="line">        throw new Error(&apos;出错了&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ajax(6).then(function()&#123;</div><div class="line">    console.log(&apos;log&apos;,6);</div><div class="line">  &#125;).catch(function(err)&#123;</div><div class="line">    console.log(&apos;catch&apos;,err);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  ajax(3).then(function()&#123;</div><div class="line">    console.log(&apos;log&apos;,3);</div><div class="line">  &#125;).catch(function(err)&#123;</div><div class="line">    console.log(&apos;catch&apos;,err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Promise还有个更高级的用法<a href=""><strong>Promise.all()</strong></a>,它返回也是一个promise实例,它会把多个promise实例当成一个实例,等待所有promise实例都加载执行完后才执行一个新的Promise对象,所以它就可以调用then方法.业务场景:<a href=""><strong>加载网络图片</strong></a>.代码就不贴了毕竟不是这篇文章的主要讨论内容.</p></blockquote><h4 id="2-3-generator特性实现异步请求"><a href="#2-3-generator特性实现异步请求" class="headerlink" title="2.3 generator特性实现异步请求"></a>2.3 generator特性实现异步请求</h4><p>generator让人第一感觉就是用同步的写法做异步处理为行为,我们将前面说的方式用generator改写对比看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">co(function* () &#123;</div><div class="line">const c1 = yield ajax(5)</div><div class="line">const c2 = yield ajax(6)</div><div class="line">const c3 = yield ajax(3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里得我们用到了co库,它能做到自驱动流程,省去每次都得手动调用next,这一点下文会详细讲到co库</p><h3 id="3-generator结合co库实现实现异步请求-自动流程"><a href="#3-generator结合co库实现实现异步请求-自动流程" class="headerlink" title="3.generator结合co库实现实现异步请求,自动流程"></a>3.generator结合co库实现实现异步请求,自动流程</h3><p>co库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行,我们将上面的代码稍微改一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">const co = require(&apos;co&apos;)</div><div class="line"></div><div class="line">let c = function* () &#123;</div><div class="line">const c1 = yield ajax(5)</div><div class="line">const c2 = yield ajax(6)</div><div class="line">const c3 = yield ajax(3)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const cc = co(c)</div><div class="line"></div><div class="line">cc.then(data=&gt;&#123;</div><div class="line">....</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>co库返回的是一个Promise对象,所以then的操作大家一看就知道怎么回事了,那么co库究竟做了什么操作呢? see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function run(generator) &#123;</div><div class="line">    const g = generator()</div><div class="line">    function next(err, data) &#123;</div><div class="line">        const result = g.next(data)  </div><div class="line">          if (result.done) &#123;</div><div class="line">             return</div><div class="line">        &#125;</div><div class="line">        result.value(next)  </div><div class="line">      &#125;</div><div class="line">    next()</div><div class="line">&#125;</div><div class="line">//thunkify是一个开源库,其实就是一个经过封装处理的thunk函数</div><div class="line">const readFileThunk = thunkify(fs.readFile)</div><div class="line">const gen = function* () &#123;</div><div class="line">    const r1 = yield readFileThunk(&apos;data1.json&apos;)</div><div class="line">    console.log(r1.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 启动执行</div><div class="line">run(gen)</div></pre></td></tr></table></figure><p>看到这段代码理解起来有点难度,next(err, data)是什么意思?g.next(data)又是什么,头都大了.我们来拆分之后你就懂了.首先我们要引进thunk这个函数,它的作用在于将执行参数与回调参数分为两个函数去调用,举个读取文件的🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.readFile(&apos;data.json&apos;, &apos;utf-8&apos;, (err, data) =&gt; &#123;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>用thunk函数改写后,see:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let thunk = (file,meta)=&gt;&#123;</div><div class="line">return function (callback) &#123;</div><div class="line">        fs.readFile(fileName, meta, callback)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const fileRead = thunk(&apos;data.json&apos;,&apos;utf-8&apos;)</div><div class="line">fileRead((err,data)=&gt;&#123;</div><div class="line">...</div><div class="line">)&#125;</div></pre></td></tr></table></figure><p>ok,结合上面代码完整代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let thunk = (file,meta)=&gt;&#123;</div><div class="line">return function (callback) &#123;</div><div class="line">        fs.readFile(fileName, meta, callback)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function run(generator) &#123;</div><div class="line">    const g = generator()</div><div class="line">    function next(err, data) &#123;</div><div class="line">        const result = g.next(data)  </div><div class="line">          if (result.done) &#123;</div><div class="line">             return</div><div class="line">        &#125;</div><div class="line">        result.value(next)  </div><div class="line">      &#125;</div><div class="line">    next()</div><div class="line">&#125;</div><div class="line"></div><div class="line">const gen = function* () &#123;</div><div class="line">    const r1 = yield thunk(&apos;data.json&apos;,&apos;utf-8&apos;)</div><div class="line">    console.log(r1.toString())</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 启动执行</div><div class="line">run(gen)</div></pre></td></tr></table></figure><blockquote><p>g.next返回的是一个thunk函数,从代码可以清楚看到,result.value 返回也是thunk函数,传入的next就是它的回调函数</p></blockquote><h3 id="4-generator其他应用"><a href="#4-generator其他应用" class="headerlink" title="4.generator其他应用"></a>4.generator其他应用</h3><h4 id="4-1-抽奖"><a href="#4-1-抽奖" class="headerlink" title="4.1 抽奖"></a>4.1 抽奖</h4><p>举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  let draw = function(count)&#123;</div><div class="line">    //具体抽奖逻辑</div><div class="line">    console.info(`剩余$&#123;count&#125;次`)</div><div class="line">  &#125;</div><div class="line">  let residue = function* ()&#123;</div><div class="line">      while(count&gt;0)&#123;</div><div class="line">        count --;</div><div class="line">        yield draw(count);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  let star = residue(3);</div><div class="line">  let btn = document.createElement(&apos;button&apos;);</div><div class="line">  btn.id = &quot;start&quot;;</div><div class="line">  btn.textContent = &quot;抽奖&quot;;</div><div class="line">  doucment.body.appendChild(btn);</div><div class="line">  document.getElementById(&apos;start&apos;).addEventListener(&apos;click&apos;,function()&#123;</div><div class="line">    start.next();</div><div class="line">  &#125;,false)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从代码可以看到我们并没有创建count作为全局变量,为什么这么处理大家不妨想想,我们在draw这个函数就只是单单抽奖的逻辑,抽奖次数我们直接在初始化generator的时候给它传参,代码看起来非常干净(可耻的炫耀一下)</p><h4 id="4-2-长轮洵"><a href="#4-2-长轮洵" class="headerlink" title="4.2 长轮洵"></a>4.2 长轮洵</h4><p>当服务端某个数据定期会发生变化,前端需要做的工作就是会在它发生变化的时候实时取得数据并展现出来,同样举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"></div><div class="line">  let ajax = function* ()&#123;</div><div class="line">    yield new Promise(function(resolve,reject)&#123;</div><div class="line">      setTimeout(function() &#123;</div><div class="line">        resolve(&#123;code:0&#125;)</div><div class="line">      &#125;, 200);</div><div class="line">      </div><div class="line">    &#125;)</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">  let fetch = function()&#123;</div><div class="line">    let g = ajax();</div><div class="line">    let step = g.next();</div><div class="line">    step.value.then((d)=&gt;&#123;</div><div class="line">      if(d.code != 0)&#123;</div><div class="line">          setTimeout(function() &#123;</div><div class="line">            console.log(&apos;wait&apos;)</div><div class="line">            fetch()</div><div class="line">          &#125;, 1000);</div><div class="line">      &#125;else &#123;</div><div class="line">        console.log(d);  //&#123;code:0&#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们将generator和promise进行结合实现异步处理,g.next()会对generator进行一次迭代向服务端查询,step.value取得promise实例,通过then函数对拿到的数据做处理就行了</p><p>–</p><blockquote><p>后话:generator和co结合应用在了koa1,koa2则是用了es7 的提案<a href=""><strong>async/await</strong></a>来做异步开发,由于koa2正安排进我的学习计划中,那就等后面学到哪更到哪吧,第一篇koa2的文章已经更新了<a href="http://lynhao.cn/2017/07/13/进击Koa2系列-一/" target="_blank" rel="external"><strong>戳这里</strong></a>,敬请留意后续更新~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;es6 中引入了Generator Function（生成器函数）这个新特性,这篇文章会从以下4个点介绍,文章篇幅会有点长,请备好电源🤖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解generator✅&lt;/li&gt;
&lt;li&gt;如何用generator特性实现异步请求✅&lt;/li&gt;
&lt;li&gt;generator结合co库实现实现异步请求,自动流程✅&lt;/li&gt;
&lt;li&gt;generator其他应用✅&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>进击Koa2系列[一]</title>
    <link href="http://yoursite.com/2017/07/13/%E8%BF%9B%E5%87%BBKoa2%E7%B3%BB%E5%88%97-%E4%B8%80/"/>
    <id>http://yoursite.com/2017/07/13/进击Koa2系列-一/</id>
    <published>2017-07-13T02:41:52.000Z</published>
    <updated>2018-06-01T01:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="忏悔"><a href="#忏悔" class="headerlink" title="忏悔"></a>忏悔</h3><p>之所以起这个名字,原因是因为没好好坚持学node,14年node还是0.0.x版本我就开始用了,不过没坚持下来,现在node生态发展迅猛已经迭代到7.x版本了,框架已经从Express迭代到koa再到如今的koa2,额,好吧,又是一门全新的知识体系,只好硬着头皮学咯.这个系列将会把我学习的整个过程记录下来,敬请关注</p><h3 id="koa2环境搭建"><a href="#koa2环境搭建" class="headerlink" title="koa2环境搭建"></a>koa2环境搭建</h3><ul><li><p>操作系统: 不限</p></li><li><p>编译环境: nodejs      </p></li></ul><blockquote><p>因为koa2团队是基于es7这个未来标准开发的,所以推荐使用7.6版本以上,可以省去很多麻烦.</p></blockquote><h3 id="搭建第一个项目"><a href="#搭建第一个项目" class="headerlink" title="搭建第一个项目"></a>搭建第一个项目</h3><p>这里我们用<a href=""><strong>Hello World</strong></a>做演示</p><h5 id="安装koa2"><a href="#安装koa2" class="headerlink" title="安装koa2"></a>安装koa2</h5><h6 id="创建目录-初始化"><a href="#创建目录-初始化" class="headerlink" title="创建目录,初始化"></a>创建目录,初始化</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir Koa2</div><div class="line">npm init</div></pre></td></tr></table></figure><h6 id="安装koa2-1"><a href="#安装koa2-1" class="headerlink" title="安装koa2"></a>安装koa2</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install koa</div></pre></td></tr></table></figure><h6 id="创建index-js-编写代码"><a href="#创建index-js-编写代码" class="headerlink" title="创建index.js 编写代码"></a>创建index.js 编写代码</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch index.js</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const Koa = require(&apos;koa&apos;)</div><div class="line">const app = new Koa()</div><div class="line"></div><div class="line">app.use( async ( ctx ) =&gt; &#123;</div><div class="line">  ctx.body = &apos;hello koa2&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(3000)</div><div class="line">console.log(&apos;[demo] start-quick is starting at port 3000&apos;)</div></pre></td></tr></table></figure><h6 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node index.js</div></pre></td></tr></table></figure><p><img src="http://picturegit-1251927503.cosgz.myqcloud.com/%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-13%2011.08.06.png" alt="代码片段"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;忏悔&quot;&gt;&lt;a href=&quot;#忏悔&quot; class=&quot;headerlink&quot; title=&quot;忏悔&quot;&gt;&lt;/a&gt;忏悔&lt;/h3&gt;&lt;p&gt;之所以起这个名字,原因是因为没好好坚持学node,14年node还是0.0.x版本我就开始用了,不过没坚持下来,现在node生态发展迅猛已经
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="koa2" scheme="http://yoursite.com/tags/koa2/"/>
    
  </entry>
  
  <entry>
    <title>JS实现功能算法--持续更新👀</title>
    <link href="http://yoursite.com/2017/07/05/JS%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%AE%97%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%F0%9F%91%80/"/>
    <id>http://yoursite.com/2017/07/05/JS实现功能算法-持续更新👀/</id>
    <published>2017-07-05T02:52:11.000Z</published>
    <updated>2018-06-01T01:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将会记录一些日常开发用到的算法知识实现特定的业务需求,持续不定期更新,谢谢支持☺️</p></blockquote><a id="more"></a><h3 id="优化递归"><a href="#优化递归" class="headerlink" title="优化递归"></a>优化递归</h3><blockquote><p>一般代码,空间复杂度O(n)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">  console.trace()</div><div class="line">  if(n === 0) &#123;</div><div class="line">    return 1</div><div class="line">  &#125;</div><div class="line">  return n * factorial(n-1)</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>优化后代码(尾递归),避免执行栈过多溢出,空间复杂度O(1)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line">function factorial(n, total=1) &#123;</div><div class="line">  if(n === 1) &#123;</div><div class="line">    return total</div><div class="line">  &#125;</div><div class="line">  return factorial(n-1, n * total)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2018年05月31日10:28:41</strong></a></li></ul><h3 id="实现组合排列算法"><a href="#实现组合排列算法" class="headerlink" title="实现组合排列算法"></a>实现组合排列算法</h3><blockquote><p>我这里的业务场景是在计算彩票的多重组合结果,可直接运行调试,示例代码如下</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">static combine(arr,size)&#123;</div><div class="line">   <span class="built_in">let</span> allResult = [];</div><div class="line">   (<span class="keyword">function</span> f(arr,size,result)&#123;</div><div class="line">     <span class="built_in">let</span> arrLen = arr.length;</div><div class="line">     <span class="keyword">if</span>(size&gt;arrLen)&#123;</div><div class="line">       <span class="built_in">return</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(size === arrLen)&#123;</div><div class="line">       allResult.push([].concat(result,arr))</div><div class="line">     </div><div class="line">     &#125;<span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span>(<span class="built_in">let</span> i=0;i&lt;arrLen;i++)&#123;</div><div class="line">         <span class="built_in">let</span> newResult = [].concat(result);</div><div class="line">         newResult.push(arr[i]);</div><div class="line">         <span class="keyword">if</span>(size === 1)&#123;</div><div class="line">           allResult.push(newResult)</div><div class="line">         &#125;<span class="keyword">else</span> &#123;</div><div class="line">           <span class="built_in">let</span> newArr = [].concat(arr);</div><div class="line">           newArr.splice(0,i+1);</div><div class="line">           f(newArr,size-1,newResult)</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;)(arr,size,[])</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li>date <a href=""><strong>2017年07月05日10:58:11</strong></a></li></ul><hr><p>持续更新中,敬请期待…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章将会记录一些日常开发用到的算法知识实现特定的业务需求,持续不定期更新,谢谢支持☺️&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
